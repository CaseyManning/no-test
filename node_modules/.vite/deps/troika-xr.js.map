{
  "version": 3,
  "sources": ["../../troika-xr/node_modules/react/cjs/react.development.js", "../../troika-xr/node_modules/react/index.js", "../../troika-xr/dist/troika-xr.esm.js", "../../troika-xr/node_modules/troika-core/dist/troika-core.esm.js", "../../three/examples/jsm/utils/BufferGeometryUtils.js", "../../three/examples/jsm/loaders/GLTFLoader.js"],
  "sourcesContent": ["/** @license React v16.14.0\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar _assign = require('object-assign');\nvar checkPropTypes = require('prop-types/checkPropTypes');\n\nvar ReactVersion = '16.14.0';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\n/**\n * Keeps track of the current dispatcher.\n */\nvar ReactCurrentDispatcher = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\n/**\n * Keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */\nvar ReactCurrentBatchConfig = {\n  suspense: null\n};\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\nvar BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\nfunction describeComponentFrame (name, source, ownerName) {\n  var sourceInfo = '';\n\n  if (source) {\n    var path = source.fileName;\n    var fileName = path.replace(BEFORE_SLASH_RE, '');\n\n    {\n      // In DEV, include code for a common special case:\n      // prefer \"folder/index.js\" instead of just \"index.js\".\n      if (/^index\\./.test(fileName)) {\n        var match = path.match(BEFORE_SLASH_RE);\n\n        if (match) {\n          var pathBeforeSlash = match[1];\n\n          if (pathBeforeSlash) {\n            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\n            fileName = folderName + '/' + fileName;\n          }\n        }\n      }\n    }\n\n    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';\n  } else if (ownerName) {\n    sourceInfo = ' (created by ' + ownerName + ')';\n  }\n\n  return '\\n    in ' + (name || 'Unknown') + sourceInfo;\n}\n\nvar Resolved = 1;\nfunction refineResolvedLazyComponent(lazyComponent) {\n  return lazyComponent._status === Resolved ? lazyComponent._result : null;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var functionName = innerType.displayName || innerType.name || '';\n  return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n}\n\nfunction getComponentName(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return \"Profiler\";\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        return 'Context.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        return 'Context.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        return getComponentName(type.type);\n\n      case REACT_BLOCK_TYPE:\n        return getComponentName(type.render);\n\n      case REACT_LAZY_TYPE:\n        {\n          var thenable = type;\n          var resolvedThenable = refineResolvedLazyComponent(thenable);\n\n          if (resolvedThenable) {\n            return getComponentName(resolvedThenable);\n          }\n\n          break;\n        }\n    }\n  }\n\n  return null;\n}\n\nvar ReactDebugCurrentFrame = {};\nvar currentlyValidatingElement = null;\nfunction setCurrentlyValidatingElement(element) {\n  {\n    currentlyValidatingElement = element;\n  }\n}\n\n{\n  // Stack implementation injected by the current renderer.\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var stack = ''; // Add an extra top frame while an element is being validated\n\n    if (currentlyValidatingElement) {\n      var name = getComponentName(currentlyValidatingElement.type);\n      var owner = currentlyValidatingElement._owner;\n      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));\n    } // Delegate to the injected renderer-specific implementation\n\n\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n\n    if (impl) {\n      stack += impl() || '';\n    }\n\n    return stack;\n  };\n}\n\n/**\n * Used by act() to track whether you're inside an act() scope.\n */\nvar IsSomeRendererActing = {\n  current: false\n};\n\nvar ReactSharedInternals = {\n  ReactCurrentDispatcher: ReactCurrentDispatcher,\n  ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n  ReactCurrentOwner: ReactCurrentOwner,\n  IsSomeRendererActing: IsSomeRendererActing,\n  // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n  assign: _assign\n};\n\n{\n  _assign(ReactSharedInternals, {\n    // These should not be included in production.\n    ReactDebugCurrentFrame: ReactDebugCurrentFrame,\n    // Shim for React DOM 16.0.0 which still destructured (but not used) this.\n    // TODO: remove in React 17.0.\n    ReactComponentTreeHook: {}\n  });\n}\n\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\n\nfunction warn(format) {\n  {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    printWarning('warn', format, args);\n  }\n}\nfunction error(format) {\n  {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    printWarning('error', format, args);\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === 'string' && args[args.length - 1].indexOf('\\n    in') === 0;\n\n    if (!hasExistingStack) {\n      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n      var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n      if (stack !== '') {\n        format += '%s';\n        args = args.concat([stack]);\n      }\n    }\n\n    var argsWithFormat = args.map(function (item) {\n      return '' + item;\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      var argIndex = 0;\n      var message = 'Warning: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n      });\n      throw new Error(message);\n    } catch (x) {}\n  }\n}\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var _constructor = publicInstance.constructor;\n    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n    var warningKey = componentName + \".\" + callerName;\n\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n\n    error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n/**\n * This is the abstract API for an update queue.\n */\n\n\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\nvar emptyObject = {};\n\n{\n  Object.freeze(emptyObject);\n}\n/**\n * Base class helpers for the updating state of a component.\n */\n\n\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n  // renderer.\n\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\n\nComponent.prototype.setState = function (partialState, callback) {\n  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {\n    {\n      throw Error( \"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\" );\n    }\n  }\n\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\n\n\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n\n\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n\n        return undefined;\n      }\n    });\n  };\n\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\n\nComponentDummy.prototype = Component.prototype;\n/**\n * Convenience component with default shallow equality check for sCU.\n */\n\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\n_assign(pureComponentPrototype, Component.prototype);\n\npureComponentPrototype.isPureReactComponent = true;\n\n// an immutable object with a single mutable value\nfunction createRef() {\n  var refObject = {\n    current: null\n  };\n\n  {\n    Object.seal(refObject);\n  }\n\n  return refObject;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n      var componentName = getComponentName(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://fb.me/react-strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\n\nfunction createElement(type, config, children) {\n  var propName; // Reserved names are extracted\n\n  var props = {};\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n\n      {\n        warnIfStringRefCannotBeAutoConverted(config);\n      }\n    }\n\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n\n    props.children = childArray;\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  {\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n  return newElement;\n}\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\n\nfunction cloneElement(element, config, children) {\n  if (!!(element === null || element === undefined)) {\n    {\n      throw Error( \"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\" );\n    }\n  }\n\n  var propName; // Original props are copied\n\n  var props = _assign({}, element.props); // Reserved names are extracted\n\n\n  var key = element.key;\n  var ref = element.ref; // Self is preserved since the owner is preserved.\n\n  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n\n  var source = element._source; // Owner will be preserved, unless ref is overridden\n\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    } // Remaining properties override existing props\n\n\n    var defaultProps;\n\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\n\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = ('' + key).replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n  return '$' + escapedString;\n}\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\n\nvar didWarnAboutMaps = false;\nvar userProvidedKeyEscapeRegex = /\\/+/g;\n\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\nvar POOL_SIZE = 10;\nvar traverseContextPool = [];\n\nfunction getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n  if (traverseContextPool.length) {\n    var traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0\n    };\n  }\n}\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\n\n\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n\n    }\n  }\n\n  if (invokeCallback) {\n    callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  var child;\n  var nextName;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n\n    if (typeof iteratorFn === 'function') {\n\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === children.entries) {\n          if (!didWarnAboutMaps) {\n            warn('Using Maps as children is deprecated and will be removed in ' + 'a future major release. Consider converting children to ' + 'an array of keyed ReactElements instead.');\n          }\n\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(children);\n      var step;\n      var ii = 0;\n\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n      }\n    } else if (type === 'object') {\n      var addendum = '';\n\n      {\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();\n      }\n\n      var childrenString = '' + children;\n\n      {\n        {\n          throw Error( \"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \").\" + addendum );\n        }\n      }\n    }\n  }\n\n  return subtreeCount;\n}\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\n\n\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\n\n\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof component === 'object' && component !== null && component.key != null) {\n    // Explicit key\n    return escape(component.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  var func = bookKeeping.func,\n      context = bookKeeping.context;\n  func.call(context, child, bookKeeping.count++);\n}\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\n\n\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n\n  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  var result = bookKeeping.result,\n      keyPrefix = bookKeeping.keyPrefix,\n      func = bookKeeping.func,\n      context = bookKeeping.context;\n  var mappedChild = func.call(context, child, bookKeeping.count++);\n\n  if (Array.isArray(mappedChild)) {\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {\n      return c;\n    });\n  } else if (mappedChild != null) {\n    if (isValidElement(mappedChild)) {\n      mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n      // traverseAllChildren used to do for objects as children\n      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\n    }\n\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  var escapedPrefix = '';\n\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n\n  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\n\n\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\n\n\nfunction countChildren(children) {\n  return traverseAllChildren(children, function () {\n    return null;\n  }, null);\n}\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\n\n\nfunction toArray(children) {\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, function (child) {\n    return child;\n  });\n  return result;\n}\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\n\n\nfunction onlyChild(children) {\n  if (!isValidElement(children)) {\n    {\n      throw Error( \"React.Children.only expected to receive a single React element child.\" );\n    }\n  }\n\n  return children;\n}\n\nfunction createContext(defaultValue, calculateChangedBits) {\n  if (calculateChangedBits === undefined) {\n    calculateChangedBits = null;\n  } else {\n    {\n      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {\n        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);\n      }\n    }\n  }\n\n  var context = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    _calculateChangedBits: calculateChangedBits,\n    // As a workaround to support multiple concurrent renderers, we categorize\n    // some renderers as primary and others as secondary. We only expect\n    // there to be two concurrent renderers at most: React Native (primary) and\n    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n    // Secondary renderers store their context values on separate fields.\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    // Used to track how many concurrent renderers this context currently\n    // supports within in a single renderer. Such as parallel server rendering.\n    _threadCount: 0,\n    // These are circular\n    Provider: null,\n    Consumer: null\n  };\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context\n  };\n  var hasWarnedAboutUsingNestedContextConsumers = false;\n  var hasWarnedAboutUsingConsumerProvider = false;\n\n  {\n    // A separate object, but proxies back to the original context object for\n    // backwards compatibility. It has a different $$typeof, so we can properly\n    // warn for the incorrect usage of Context as a Consumer.\n    var Consumer = {\n      $$typeof: REACT_CONTEXT_TYPE,\n      _context: context,\n      _calculateChangedBits: context._calculateChangedBits\n    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n    Object.defineProperties(Consumer, {\n      Provider: {\n        get: function () {\n          if (!hasWarnedAboutUsingConsumerProvider) {\n            hasWarnedAboutUsingConsumerProvider = true;\n\n            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n          }\n\n          return context.Provider;\n        },\n        set: function (_Provider) {\n          context.Provider = _Provider;\n        }\n      },\n      _currentValue: {\n        get: function () {\n          return context._currentValue;\n        },\n        set: function (_currentValue) {\n          context._currentValue = _currentValue;\n        }\n      },\n      _currentValue2: {\n        get: function () {\n          return context._currentValue2;\n        },\n        set: function (_currentValue2) {\n          context._currentValue2 = _currentValue2;\n        }\n      },\n      _threadCount: {\n        get: function () {\n          return context._threadCount;\n        },\n        set: function (_threadCount) {\n          context._threadCount = _threadCount;\n        }\n      },\n      Consumer: {\n        get: function () {\n          if (!hasWarnedAboutUsingNestedContextConsumers) {\n            hasWarnedAboutUsingNestedContextConsumers = true;\n\n            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n          }\n\n          return context.Consumer;\n        }\n      }\n    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n    context.Consumer = Consumer;\n  }\n\n  {\n    context._currentRenderer = null;\n    context._currentRenderer2 = null;\n  }\n\n  return context;\n}\n\nfunction lazy(ctor) {\n  var lazyType = {\n    $$typeof: REACT_LAZY_TYPE,\n    _ctor: ctor,\n    // React uses these fields to store the result.\n    _status: -1,\n    _result: null\n  };\n\n  {\n    // In production, this would just set it on the object.\n    var defaultProps;\n    var propTypes;\n    Object.defineProperties(lazyType, {\n      defaultProps: {\n        configurable: true,\n        get: function () {\n          return defaultProps;\n        },\n        set: function (newDefaultProps) {\n          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n          defaultProps = newDefaultProps; // Match production behavior more closely:\n\n          Object.defineProperty(lazyType, 'defaultProps', {\n            enumerable: true\n          });\n        }\n      },\n      propTypes: {\n        configurable: true,\n        get: function () {\n          return propTypes;\n        },\n        set: function (newPropTypes) {\n          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n          propTypes = newPropTypes; // Match production behavior more closely:\n\n          Object.defineProperty(lazyType, 'propTypes', {\n            enumerable: true\n          });\n        }\n      }\n    });\n  }\n\n  return lazyType;\n}\n\nfunction forwardRef(render) {\n  {\n    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n    } else if (typeof render !== 'function') {\n      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n    } else {\n      if (render.length !== 0 && render.length !== 2) {\n        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n      }\n    }\n\n    if (render != null) {\n      if (render.defaultProps != null || render.propTypes != null) {\n        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n      }\n    }\n  }\n\n  return {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render: render\n  };\n}\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction memo(type, compare) {\n  {\n    if (!isValidElementType(type)) {\n      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\n    }\n  }\n\n  return {\n    $$typeof: REACT_MEMO_TYPE,\n    type: type,\n    compare: compare === undefined ? null : compare\n  };\n}\n\nfunction resolveDispatcher() {\n  var dispatcher = ReactCurrentDispatcher.current;\n\n  if (!(dispatcher !== null)) {\n    {\n      throw Error( \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.\" );\n    }\n  }\n\n  return dispatcher;\n}\n\nfunction useContext(Context, unstable_observedBits) {\n  var dispatcher = resolveDispatcher();\n\n  {\n    if (unstable_observedBits !== undefined) {\n      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\\n\\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://fb.me/rules-of-hooks' : '');\n    } // TODO: add a more generic warning for invalid values.\n\n\n    if (Context._context !== undefined) {\n      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n      // and nobody should be using this in existing code.\n\n      if (realContext.Consumer === Context) {\n        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n      } else if (realContext.Provider === Context) {\n        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n      }\n    }\n  }\n\n  return dispatcher.useContext(Context, unstable_observedBits);\n}\nfunction useState(initialState) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\nfunction useReducer(reducer, initialArg, init) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\nfunction useRef(initialValue) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\nfunction useEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\nfunction useLayoutEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\nfunction useCallback(callback, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\nfunction useMemo(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\nfunction useImperativeHandle(ref, create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\nfunction useDebugValue(value, formatterFn) {\n  {\n    var dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentName(ReactCurrentOwner.current.type);\n\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  if (source !== undefined) {\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendumForProps(elementProps) {\n  if (elementProps !== null && elementProps !== undefined) {\n    return getSourceInfoErrorAddendum(elementProps.__source);\n  }\n\n  return '';\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n    if (parentName) {\n      info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n    }\n  }\n\n  return info;\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n\n  element._store.validated = true;\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n\n  var childOwner = '';\n\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\n  }\n\n  setCurrentlyValidatingElement(element);\n\n  {\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);\n  }\n\n  setCurrentlyValidatingElement(null);\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step;\n\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var name = getComponentName(type);\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      setCurrentlyValidatingElement(element);\n      checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);\n      setCurrentlyValidatingElement(null);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true;\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    setCurrentlyValidatingElement(fragment);\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n    }\n\n    setCurrentlyValidatingElement(null);\n  }\n}\nfunction createElementWithValidation(type, props, children) {\n  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n\n  if (!validType) {\n    var info = '';\n\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    var typeString;\n\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    {\n      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n  }\n\n  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n\n  if (element == null) {\n    return element;\n  } // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\nvar didWarnAboutDeprecatedCreateFactory = false;\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n\n  {\n    if (!didWarnAboutDeprecatedCreateFactory) {\n      didWarnAboutDeprecatedCreateFactory = true;\n\n      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n    } // Legacy hook: remove it\n\n\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n\n  validatePropTypes(newElement);\n  return newElement;\n}\n\n{\n\n  try {\n    var frozenObject = Object.freeze({});\n    var testMap = new Map([[frozenObject, null]]);\n    var testSet = new Set([frozenObject]); // This is necessary for Rollup to not consider these unused.\n    // https://github.com/rollup/rollup/issues/1771\n    // TODO: we can remove these if Rollup fixes the bug.\n\n    testMap.set(0, 0);\n    testSet.add(0);\n  } catch (e) {\n  }\n}\n\nvar createElement$1 =  createElementWithValidation ;\nvar cloneElement$1 =  cloneElementWithValidation ;\nvar createFactory =  createFactoryWithValidation ;\nvar Children = {\n  map: mapChildren,\n  forEach: forEachChildren,\n  count: countChildren,\n  toArray: toArray,\n  only: onlyChild\n};\n\nexports.Children = Children;\nexports.Component = Component;\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.Profiler = REACT_PROFILER_TYPE;\nexports.PureComponent = PureComponent;\nexports.StrictMode = REACT_STRICT_MODE_TYPE;\nexports.Suspense = REACT_SUSPENSE_TYPE;\nexports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\nexports.cloneElement = cloneElement$1;\nexports.createContext = createContext;\nexports.createElement = createElement$1;\nexports.createFactory = createFactory;\nexports.createRef = createRef;\nexports.forwardRef = forwardRef;\nexports.isValidElement = isValidElement;\nexports.lazy = lazy;\nexports.memo = memo;\nexports.useCallback = useCallback;\nexports.useContext = useContext;\nexports.useDebugValue = useDebugValue;\nexports.useEffect = useEffect;\nexports.useImperativeHandle = useImperativeHandle;\nexports.useLayoutEffect = useLayoutEffect;\nexports.useMemo = useMemo;\nexports.useReducer = useReducer;\nexports.useRef = useRef;\nexports.useState = useState;\nexports.version = ReactVersion;\n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n", "import React from 'react';\nimport T from 'prop-types';\nimport { utils, Facade, ParentFacade } from 'troika-core';\nimport { Object3DFacade, createDerivedMaterial, Group3DFacade, PerspectiveCamera3DFacade, World3DFacade, Canvas3D, MeshFacade, CircleFacade } from 'troika-3d';\nimport { setAnimationScheduler } from 'troika-animation';\nimport { SphereGeometry, MeshBasicMaterial, Vector3, Quaternion, Mesh, Group, CylinderGeometry, MeshStandardMaterial, Matrix4, Euler, Ray, PerspectiveCamera, Vector4, Vector2, DoubleSide, Shape, Path, ExtrudeGeometry, BufferGeometry, ShaderMaterial, Color, BufferAttribute, DynamicDrawUsage, MeshLambertMaterial, Plane, Sphere } from 'three';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { invertMatrix4 } from 'troika-three-utils';\n\nclass XRLauncher extends React.PureComponent {\n  constructor(props) {\n    super(props);\n\n    this._onClick = this._onClick.bind(this);\n  }\n\n  _onClick() {\n    this.props.onSelectSession(this.props.xrSession ? null : 'immersive-vr'); //TODO handle other modes\n  }\n\n  render() {\n    const props = this.props;\n    return React.createElement(\n      'button',\n      {\n        onClick: this._onClick,\n        disabled: !props.xrSupported\n      },\n      props.xrSupported ? (props.xrSession ? 'Exit XR' : 'Enter XR') : 'XR Not Available'\n    )\n  }\n}\n\nconst cursorGeom = new SphereGeometry();\nconst cursorMaterial = new MeshBasicMaterial({color: 0xffffff});\nconst tempVec3 = new Vector3();\nconst tempQuat = new Quaternion();\nconst degToRadMult = Math.PI / 180;\n\nclass CursorFacade extends Object3DFacade {\n  constructor(parent) {\n    super(parent, new Mesh(\n      cursorGeom,\n      cursorMaterial.clone()\n    ));\n\n    /**\n     * Visual size at which the cursor should be drawn, regardless of its distance.\n     * This is measured in degrees of the field of view.\n     * @type {number}\n     */\n    this.size = 0.3;\n\n    /**\n     * If nonzero, defines the default distance at which the cursor should be displayed when\n     * the targetRay does not intersect any pointable objects in the scene. Defaults to `0`,\n     * which means it is hidden by default.\n     * @type {number}\n     */\n    this.defaultDistance = 0;\n  }\n\n  afterUpdate() {\n    const {rayIntersection, defaultDistance, targetRayPose} = this;\n\n    // Only display if there is a valid ray intersection, or we're configured with a default distance\n    let point = rayIntersection && rayIntersection.point;\n    if (!point && defaultDistance && targetRayPose) {\n      point = tempVec3.set(0, 0, -1)\n        .multiplyScalar(defaultDistance) //length\n        .applyQuaternion(tempQuat.copy(targetRayPose.transform.orientation)) //rotation\n        .add(targetRayPose.transform.position); //origin\n    }\n    if (point) {\n      point.copy.call(this, point);\n      this.scale = point.distanceTo(this.getCameraPosition()) * Math.sin(this.size * degToRadMult);\n      this.visible = true;\n    } else {\n      this.visible = false;\n    }\n\n    super.afterUpdate();\n  }\n}\n\n/**\n * A `renderOrder` for the target ray that ensures proper transparency\n */\nconst TARGET_RAY_RENDERORDER = 1e8;\n\n/**\n * Given a XRPose, copy its transform's position and orientation to the corresponding\n * properties on a Object3DFacade.\n * @param {XRPose} pose\n * @param {Object3DFacade} facade\n */\nfunction copyXRPoseToFacadeProps(pose, facade) {\n  if (pose && facade) {\n    const {position, orientation} = pose.transform;\n    facade.x = position.x;\n    facade.y = position.y;\n    facade.z = position.z;\n    facade.quaternionX = orientation.x;\n    facade.quaternionY = orientation.y;\n    facade.quaternionZ = orientation.z;\n    facade.quaternionW = orientation.w;\n  }\n}\n\nlet getGeometry = () => {\n  const geometry = new CylinderGeometry(1, 1, 1, 4, 1, false)\n    .translate(0, 0.5, 0)\n    .rotateY(Math.PI / 4)\n    .rotateX(Math.PI / -2);\n  getGeometry = () => geometry;\n  return geometry\n};\n\nlet getMaterial = () => {\n  const material = createDerivedMaterial(\n    new MeshBasicMaterial({\n      transparent: true,\n      opacity: 0.5,\n      color: 0xffffff,\n      depthTest: false\n    }), {\n      vertexDefs: `varying float dist;`,\n      vertexMainIntro: `dist = -position.z;`,\n      fragmentDefs: `varying float dist;`,\n      fragmentColorTransform: `gl_FragColor.a *= smoothstep(1.0, 0.6, dist);`\n    }\n  );\n  getMaterial = () => material;\n  return material\n};\n\n\n\nclass TargetRayFacade extends Object3DFacade {\n  constructor(parent) {\n    super(parent, new Group());\n\n    this.threeObject.add(this.laserMesh = new Mesh(getGeometry(), getMaterial()));\n\n    this.radius = 0.003;\n    this.startDistance = 0.05;\n    this.maxLength = 0.4;\n    this.renderOrder = TARGET_RAY_RENDERORDER;\n  }\n\n  afterUpdate() {\n    const {laserMesh, targetRayPose, radius, rayIntersection, startDistance, maxLength} = this;\n    if (targetRayPose) {\n      // Sync group to the targetRay pose\n      copyXRPoseToFacadeProps(targetRayPose, this);\n\n      // Update laser size from radius/rayIntersection props\n      laserMesh.scale.set(\n        radius,\n        radius,\n        (rayIntersection ? Math.min(rayIntersection.distance, maxLength) : maxLength) - startDistance\n      );\n      laserMesh.position.z = -startDistance;\n      laserMesh.visible = true;\n    } else {\n      laserMesh.visible = false;\n    }\n\n    super.afterUpdate();\n  }\n}\n\nlet getGeometry$1 = () => {\n  const geometry = new CylinderGeometry(0.03, 0.05, 0.1, 8)\n    .rotateX(Math.PI / -2)\n    .translate(0, 0, 0.05);\n  getGeometry$1 = () => geometry;\n  return geometry\n};\n\nlet getMaterial$1 = () => {\n  const material = new MeshStandardMaterial({\n    color: 0x666666,\n    emissive: 0x666666,\n    roughness: 0.5,\n    metalness: 0.5\n  });\n  getMaterial$1 = () => material;\n  return material\n};\n\n\n/**\n * Very basic tracked controller model\n */\nclass Basic extends Object3DFacade {\n  constructor(parent) {\n    const mesh = new Mesh(getGeometry$1(), getMaterial$1());\n    super(parent, mesh);\n  }\n}\n\nclass GLTFFacade extends Object3DFacade {\n  constructor (parent) {\n    super(parent, new Group());\n    this.url = null;\n    this.rootTransform = null;\n    this.autoDispose = true;\n  }\n\n  afterUpdate () {\n    let { url } = this;\n    if (url !== this._url) {\n      this._url = url;\n      this.removeObjects();\n      if (url) {\n        let loader = new GLTFLoader();\n        loader.setCrossOrigin('anonymous');\n        loader.load(\n          url,\n          result => {\n            this.onLoad(result);\n          },\n          null,\n          err => {\n            console.error('Failed loading controller model', err);\n          }\n        );\n      }\n    }\n    super.afterUpdate();\n  }\n\n  onLoad (gltf) {\n    if (this.threeObject) {\n      gltf = this.normalize(gltf);\n      let root = gltf.scene;\n      if (this.rootTransform) {\n        root.applyMatrix4(this.rootTransform);\n      }\n      this.threeObject.add(root);\n      root.updateMatrixWorld(true);\n      this.gltf = gltf;\n      this.afterUpdate();\n    }\n  }\n\n  normalize(gltf) {\n    return gltf\n  }\n\n  removeObjects () {\n    const { gltf } = this;\n    if (gltf && gltf.scene) {\n      if (this.autoDispose) {\n        gltf.scene.traverse(({ geometry, material }) => {\n          if (geometry) {\n            geometry.dispose();\n          }\n          if (material) {\n            if (material.texture) {\n              material.texture.dispose();\n            }\n            material.dispose();\n          }\n        });\n      }\n      if (this.threeObject) {\n        this.threeObject.remove(gltf.scene);\n      }\n      this.gltf = null;\n    }\n  }\n\n  destructor () {\n    this.removeObjects();\n    super.destructor();\n  }\n}\n\nconst MODEL_GEN = 'gen2';\n\nfunction getModelUrl (gen, hand) {\n  return `https://cdn.aframe.io/controllers/oculus/oculus-touch-controller-${gen}-${hand}.gltf`\n}\n\nconst MODEL_PARAMS = {\n  gen1: {\n    left: {\n      url: getModelUrl('gen1', 'left'),\n      transform: new Matrix4().compose(\n        new Vector3(0, 0, -0.1),\n        new Quaternion(),\n        new Vector3(1, 1, 1)\n      )\n    },\n    right: {\n      url: getModelUrl('gen1', 'right'),\n      transform: new Matrix4().compose(\n        new Vector3(0, 0, -0.1),\n        new Quaternion(),\n        new Vector3(1, 1, 1)\n      )\n    }\n  },\n  gen2: {\n    left: {\n      url: getModelUrl('gen2', 'left'),\n      transform: new Matrix4().compose(\n        new Vector3(0.01, -0.01, -0.05),\n        new Quaternion().setFromEuler(new Euler(-0.67, 0, 0)),\n        new Vector3(1, 1, 1)\n      )\n    },\n    right: {\n      url: getModelUrl('gen2', 'right'),\n      transform: new Matrix4().compose(\n        new Vector3(-0.01, -0.01, -0.05),\n        new Quaternion().setFromEuler(new Euler(-0.67, 0, 0)),\n        new Vector3(1, 1, 1)\n      )\n    }\n  }\n};\n\n// TODO define mapping here that will allow us to pass in a set of active button\n//  ids and highlight their corresponding meshes when pressed...\n// const buttonIdsToMeshNames = {}\n\nclass OculusTouchGrip extends GLTFFacade {\n  /**\n   * @property bodyColor\n   * @property emissive\n   * @property emissiveIntensity\n   * @property buttonColor\n   * @property buttonActiveColor\n   */\n\n  constructor (parent) {\n    super(parent);\n\n    this.xrInputSource = null;\n    this.bodyColor = 0x999999;\n    this.buttonColor = 0xffffff;\n    this.buttonActiveColor = 0xccffcc;\n    this.emissiveIntensity = 0.3;\n  }\n\n  afterUpdate () {\n    let hand = this.xrInputSource.handedness;\n    if (hand !== 'left' && hand !== 'right') {\n      hand = 'left';\n    }\n    if (hand !== this._hand) {\n      this._hand = hand;\n      this.url = MODEL_PARAMS[MODEL_GEN][hand].url;\n      this.rootTransform = MODEL_PARAMS[MODEL_GEN][hand].transform;\n    }\n\n    this.updateMaterials();\n    super.afterUpdate();\n  }\n\n  normalize (gltf) {\n    // Track all the individual meshes\n    this.meshes = Object.create(null);\n    gltf.scene.traverse(obj => {\n      if (obj.isMesh) {\n        obj.material = obj.material.clone(); //workaround for some meshes sharing a material instance\n        this.meshes[obj.name] = obj;\n      }\n    });\n    return gltf\n  }\n\n  updateMaterials () {\n    const { meshes } = this;\n    if (meshes) {\n      for (let name in meshes) {\n        const color = name === 'body' ? this.bodyColor : this.buttonColor;\n        const material = meshes[name].material;\n        if (color !== material._lastColor) {\n          material.color.set(color);\n          material.emissive.set(color);\n          material._lastColor = color;\n        }\n        material.emissiveIntensity = this.emissiveIntensity;\n      }\n    }\n  }\n}\n\n//import { HandsGrip } from './grip-models/HandsGrip.js'\n\n\nconst PROFILE_MODELS = [\n  /*{\n    match: xrInputSource => {\n      return true //TODO\n    },\n    facade: HandsGrip\n  },*/\n  {\n    match: xrInputSource => {\n      return /Oculus/.test(navigator.userAgent) || (\n        xrInputSource.profiles && xrInputSource.profiles.some(profile => /oculus-touch/.test(profile))\n      )\n    },\n    facade: OculusTouchGrip\n  },\n  {\n    match: xrInputSource => true,\n    facade: Basic,\n    space: 'targetRay'\n  }\n];\n\nfunction findModelConfig(xrInputSource) {\n  for (let i = 0; i < PROFILE_MODELS.length; i++) {\n    if (PROFILE_MODELS[i].match(xrInputSource)) {\n      const result = utils.assign({}, PROFILE_MODELS[i]);\n      delete result.match;\n      return result\n    }\n  }\n}\n\n\nclass GripFacade extends Group3DFacade {\n  afterUpdate() {\n    const {xrInputSource} = this;\n    let modelConfig = this.modelConfig;\n    if (xrInputSource && xrInputSource !== this._lastSource) {\n      this._lastSource = xrInputSource;\n      modelConfig = this.modelConfig = findModelConfig(xrInputSource);\n      if (modelConfig) {\n        modelConfig.xrInputSource = xrInputSource;\n      }\n    }\n\n    // Update to match the appropriate pose\n    if (modelConfig) {\n      const pose = modelConfig.space === 'targetRay' ? this.targetRayPose : this.gripPose;\n      this.visible = !!pose;\n      if (pose) {\n        copyXRPoseToFacadeProps(pose, this);\n      }\n      modelConfig.rayIntersection = this.rayIntersection;\n    }\n\n    this.children = modelConfig || null;\n    super.afterUpdate();\n  }\n}\n\n// xr-standard gamepad button/axis index mappings\n// https://immersive-web.github.io/webxr-gamepads-module/\n\nconst BUTTON_TRIGGER = 0;\nconst BUTTON_SQUEEZE = 1;\nconst BUTTON_TOUCHPAD = 2;\nconst BUTTON_THUMBSTICK = 3;\nconst BUTTON_DEFAULT_BACK = 5;\n\nconst AXIS_TOUCHPAD_X = 0;\nconst AXIS_TOUCHPAD_Y = 1;\nconst AXIS_THUMBSTICK_X = 2;\nconst AXIS_THUMBSTICK_Y = 3;\n\nconst SCENE_EVENTS = ['mousemove', 'mouseover', 'mouseout', 'mousedown', 'mouseup', 'click'];\nconst XRSESSION_EVENTS = ['selectstart', 'selectend', 'squeezestart', 'squeezeend'];\nconst CLICK_MAX_DUR = 300;\n\nconst HAPTICS = { //TODO allow control\n  mouseover: {value: 0.3, duration: 10},\n  click: {value: 1, duration: 20}\n};\n\nconst DEFAULT_CURSOR = {\n  facade: CursorFacade\n};\nconst DEFAULT_TARGET_RAY = {\n  facade: TargetRayFacade\n};\nconst DEFAULT_GRIP = {\n  facade: GripFacade\n};\n\nfunction toggleEvents (target, on, eventTypes, handler) {\n  if (target) {\n    eventTypes.forEach(type => {\n      target[`${on ? 'add' : 'remove'}EventListener`](type, handler);\n    });\n  }\n}\n\n/**\n * Controls the behavior and visual representation of a single XRInputSource.\n *\n * |                   | Highlight | Cursor | Pointing Ray | Renderable Model |\n * | ------------------| --------- | ------ | ------------ | ---------------- |\n * | 'screen'          |          | X      | X            | X                |\n * | 'gaze'            |          |       | X            | X                |\n * | 'tracked-pointer' |          |       |             |  (if possible)  |\n */\nclass XRInputSourceFacade extends Group3DFacade {\n  constructor (parent) {\n    super(parent);\n    this.isXRInputSource = true;\n\n    // Required props\n    this.xrInputSource = null;\n    this.xrSession = null;\n    this.xrReferenceSpace = null;\n\n    // Current frame state data, passed to all children:\n    this.targetRayPose = null;\n    this.gripPose = null;\n    this.rayIntersection = null;\n\n    // Child object configs:\n    this.cursor = utils.assign(DEFAULT_CURSOR);\n    this.targetRay = utils.assign(DEFAULT_TARGET_RAY);\n    this.grip = utils.assign(DEFAULT_GRIP);\n\n    // Pointing - true for all inputs by default\n    this.isPointing = true;\n\n    this.clickOnPoke = false;\n\n    this.children = [\n      null, //cursor\n      null, //targetRay\n      null //grip\n    ];\n\n    this._ray = new Ray();\n\n    this._onSessionEvent = this._onSessionEvent.bind(this);\n    this._onSceneRayEvent = this._onSceneRayEvent.bind(this);\n    this.addEventListener('xrframe', this._onXrFrame.bind(this));\n\n    // Listen to ray intersection related events at the scene level, so we can respond to intersection changes\n    toggleEvents(this.getSceneFacade(), true, SCENE_EVENTS, this._onSceneRayEvent);\n  }\n\n  afterUpdate () {\n    const {xrSession, _lastXrSession, xrInputSource, rayIntersection, children, isPointing, cursor, targetRay, grip, targetRayPose, gripPose} = this;\n\n    if (xrSession !== _lastXrSession) {\n      this._lastXrSession = xrSession;\n      toggleEvents(_lastXrSession, false, XRSESSION_EVENTS, this._onSessionEvent);\n      // Only listen for XRSession 'select' event if we won't be handling the xr-standard\n      // gamepad button tracking ourselves\n      if (!this._isXrStandardGamepad()) {\n        toggleEvents(xrSession, true, XRSESSION_EVENTS, this._onSessionEvent);\n      }\n    }\n\n    // Update child objects\n    let cursorCfg = null, targetRayCfg = null, gripCfg = null;\n    if (xrInputSource.targetRayMode !== 'screen') {\n      cursorCfg = isPointing && cursor;\n      if (cursorCfg) {\n        cursorCfg.key = 'cursor';\n        cursorCfg.targetRayPose = targetRayPose;\n        cursorCfg.gripPose = gripPose;\n        cursorCfg.rayIntersection = rayIntersection;\n        cursorCfg.xrInputSource = xrInputSource;\n      }\n    }\n    if (xrInputSource.targetRayMode === 'tracked-pointer') {\n      targetRayCfg = isPointing && targetRay;\n      if (targetRayCfg) {\n        targetRayCfg.key = 'targetRay';\n        targetRayCfg.targetRayPose = targetRayPose;\n        targetRayCfg.gripPose = gripPose;\n        targetRayCfg.rayIntersection = rayIntersection;\n        targetRayCfg.xrInputSource = xrInputSource;\n      }\n      gripCfg = gripPose ? grip : null;\n      if (gripCfg) {\n        gripCfg.key = 'grip';\n        gripCfg.targetRayPose = targetRayPose;\n        gripCfg.gripPose = gripPose;\n        gripCfg.rayIntersection = rayIntersection;\n        gripCfg.xrInputSource = xrInputSource;\n      }\n    }\n    children[0] = cursorCfg;\n    children[1] = targetRayCfg;\n    children[2] = gripCfg;\n\n    super.afterUpdate();\n  }\n\n  _onXrFrame (time, xrFrame) {\n    const {xrInputSource, isPointing, _ray: ray} = this;\n    const offsetReferenceSpace = this.getCameraFacade().offsetReferenceSpace;\n\n    if (offsetReferenceSpace) {\n      // Update current poses\n      const {targetRaySpace, gripSpace} = xrInputSource;\n      const targetRayPose = xrFrame.getPose(targetRaySpace, offsetReferenceSpace);\n      if (targetRayPose && isPointing) {\n        ray.origin.copy(targetRayPose.transform.position);\n        ray.direction.set(0, 0, -1).applyQuaternion(targetRayPose.transform.orientation);\n        this.notifyWorld('rayPointerMotion', ray);\n      }\n      this.targetRayPose = targetRayPose;\n      this.gripPose = gripSpace ? xrFrame.getPose(gripSpace, offsetReferenceSpace) : null;\n    }\n\n    // If this is a tracked-pointer with a gamepad, track its button/axis states\n    if (this._isXrStandardGamepad()) {\n      this._trackGamepadState(xrInputSource.gamepad);\n    }\n\n    this.afterUpdate();\n  }\n\n  _isXrStandardGamepad() {\n    const {gamepad} = this.xrInputSource;\n    return gamepad && gamepad.mapping === 'xr-standard'\n  }\n\n  _trackGamepadState(gamepad) {\n    // Handle button presses\n    const buttons = gamepad.buttons;\n    const pressedTimes = this._buttonPresses || (this._buttonPresses = []);\n    const now = Date.now();\n    const ray = this._ray; //assumes already updated to current frame pose\n    for (let i = 0; i < buttons.length; i++) {\n      if (buttons[i].pressed !== !!pressedTimes[i]) {\n        if (this.isPointing) {\n          this.notifyWorld('rayPointerAction', {\n            ray,\n            type: buttons[i].pressed ? 'mousedown' : 'mouseup',\n            button: i\n          });\n          if (pressedTimes[i] && !buttons[i].pressed && now - pressedTimes[i] <= CLICK_MAX_DUR) {\n            this.notifyWorld('rayPointerAction', {\n              ray,\n              type: 'click',\n              button: i\n            });\n          }\n        }\n        pressedTimes[i] = buttons[i].pressed ? now : null;\n      }\n      pressedTimes.length = buttons.length;\n    }\n\n    // Handle axis inputs\n    const axes = gamepad.axes;\n    for (let i = 0; i < axes.length; i += 2) {\n      // Map each pair of axes to wheel event deltaX/Y\n      // TODO investigate better mapping\n      const deltaX = (axes[i] || 0) * 10;\n      const deltaY = (axes[i + 1] || 0) * 10;\n      if (Math.hypot(deltaX, deltaY) > 0.1) {\n        if (this.isPointing) {\n          this.notifyWorld('rayPointerAction', {\n            ray,\n            type: 'wheel',\n            deltaX,\n            deltaY,\n            deltaMode: 0 //pixel mode\n          });\n        }\n      }\n    }\n  }\n\n  _onSessionEvent (e) {\n    if (e.inputSource === this.xrInputSource) {\n      // Redispatch select and squeeze events as standard pointer events to the world's event system.\n      // Note this is only used for non xr-standard gamepad inputs, otherwise it's handled in the\n      // gamepad button state tracking.\n      const button = /^squeeze/.test(e.type) ? BUTTON_SQUEEZE : BUTTON_TRIGGER;\n      this.notifyWorld('rayPointerAction', {\n        ray: this._ray,\n        type: /start$/.test(e.type) ? 'mousedown' : 'mouseup',\n        button\n      });\n      // If this was an \"end\" event, then we'll also want to fire a click event after the mouseup.\n      // This is a workaround for the fact that WebXR fires 'select' then 'selectend', which doesn't\n      // match with standard DOM mouse events which go 'mouseup' then 'click', and can lead to\n      // unexpected behaviors in downstram code that assumes the standard order.\n      if (/end$/.test(e.type)) {\n        this.notifyWorld('rayPointerAction', {\n          ray: this._ray,\n          type: 'click',\n          button\n        });\n      }\n    }\n  }\n\n  _onSceneRayEvent (e) {\n    // Only handle events where this was the ray's source\n    if (e.nativeEvent.eventSource === this) {\n      const {gamepad, targetRayMode} = this.xrInputSource;\n\n      // Copy intersection info to local state and update subtree\n      this.rayIntersection = e.intersection;\n      this.afterUpdate();\n\n      // If haptics available, trigger a pulse\n      if (gamepad) {\n        const isScene = e.target === e.currentTarget;\n        const hapticPulse = e.type === 'click' ? HAPTICS.click\n          : (e.type === 'mouseover' && !isScene) ? HAPTICS.mouseover\n          : null;\n        if (hapticPulse) {\n          const hapticActuator = gamepad.hapticActuators && gamepad.hapticActuators[0];\n          if (hapticActuator) {\n            hapticActuator.pulse(hapticPulse.value || 1, hapticPulse.duration || 100);\n          }\n        }\n      }\n\n      // For gamepad buttons and select/squeeze session events, dispatch custom xr-specific\n      // events to the raycasted target facade:\n      let defaultPrevented = e.defaultPrevented;\n      const fireEvent = type => {\n        if (type) {\n          const customEvent = new Event(type, {bubbles: true});\n          customEvent.eventSource = this;\n          e.target.dispatchEvent(customEvent);\n          defaultPrevented = defaultPrevented || customEvent.defaultPrevented;\n        }\n      };\n      //TODO: fireEvent(RAY_TARGET_EVENTS.all[e.type]) //all buttons\n      fireEvent(RAY_TARGET_EVENTS[e.button] && RAY_TARGET_EVENTS[e.button][e.type]); //special select/squeeze\n\n      // Default gamepad button mapping to exit the XR session; authors can override this\n      // to use that button for other things by calling `preventDefault()`\n      if (!defaultPrevented && e.type === 'click' && e.button === BUTTON_DEFAULT_BACK) {\n        this.notifyWorld('endXRSession');\n      }\n\n      // Check physical proximity to trigger a click when poking an object\n      if (targetRayMode === 'tracked-pointer' && this.clickOnPoke) {\n        this._checkPokeGesture(e);\n      }\n    }\n  }\n\n  _checkPokeGesture(e) {\n    const DEBOUNCE = 500;\n    const RAY_DISTANCE = 0.1; //slight buffer\n    const {intersection, target} = e;\n    const pokeState = this._pokeState || (this._pokeState = {target: null, isPoking: false, time: 0});\n    const isPoking = !!intersection && intersection.distance < RAY_DISTANCE;\n    if (isPoking && (!pokeState.isPoking || target !== pokeState.target) && Date.now() - pokeState.time > DEBOUNCE) {\n      pokeState.time = Date.now();\n      this.notifyWorld('rayPointerAction', {\n        ray: e.ray,\n        type: 'click',\n        button: BUTTON_TRIGGER\n      });\n    }\n    pokeState.isPoking = isPoking;\n    pokeState.target = target;\n  }\n\n  destructor () {\n    toggleEvents(this.xrSession, false, XRSESSION_EVENTS, this._onSessionEvent);\n    toggleEvents(this.getSceneFacade(), false, SCENE_EVENTS, this._onSceneRayEvent);\n    super.destructor();\n  }\n}\n\n// this.onXrFrame = null //timestamp, XRFrame\n// this.onIntersectionEvent = null //???\n// this.onSelectStart = null\n// this.onSelect = null\n// this.onSelectEnd = null\n// this.onSqueezeStart = null\n// this.onSqueeze = null\n// this.onSqueezeEnd = null\n// this.onButtonTouchStart = null\n// this.onButtonPressStart = null\n// this.onButtonPress = null\n// this.onButtonPressEnd = null\n// this.onButtonTouchEnd = null\n\n\n// Define some custom xr-specific events that will be dispatched to the target Object3DFacade\n// intersecting the ray at the time of a button action:\nconst RAY_TARGET_EVENTS = {\n  [BUTTON_TRIGGER]: {\n    mousedown: 'xrselectstart',\n    mouseup: 'xrselectend',\n    click: 'xrselect'\n  },\n  [BUTTON_SQUEEZE]: {\n    mousedown: 'xrsqueezestart',\n    mouseup: 'xrsqueezeend',\n    click: 'xrsqueeze'\n  },\n  // TODO decide on event names, and handle touching without press:\n  // all: {\n  //   mousedown: 'xrbuttondown',\n  //   mouseup: 'xrbuttonup',\n  //   click: 'xrbuttonclick'\n  // }\n};\n\n// ...and add shortcut event handler properties on Object3DFacade for those events:\nFacade.defineEventProperty(Object3DFacade, 'onXRSelectStart', 'xrselectstart');\nFacade.defineEventProperty(Object3DFacade, 'onXRSelect', 'xrselect');\nFacade.defineEventProperty(Object3DFacade, 'onXRSelectEnd', 'xrselectend');\nFacade.defineEventProperty(Object3DFacade, 'onXRSqueezeStart', 'xrsqueezestart');\nFacade.defineEventProperty(Object3DFacade, 'onXRSqueeze', 'xrsqueeze');\nFacade.defineEventProperty(Object3DFacade, 'onXRSqueezeEnd', 'xrsqueezeend');\n\n/*\n\nAdditive or replace?\n\n\n{\n  key: 'primaryTool',\n  facade: XRInputSourceAnchored,\n  selector: xrInputSource => (\n    xrInputSource.targetRayMode === 'tracked-pointer' &&\n    xrInputSource.handedness === prefs.handedness\n  ),\n  referenceSpace: 'grip'\n},\n{\n  key: 'xrInputDefaultGrips',\n  facade: XRInputVendorGrips\n},\n{\n  facade: TrackedPointerXRInputSource,\n  matches: (xrInputSource, allSources) => (\n    xrInputSource.handedness === 'left'\n  ),\n\n  onSelectStart: e => {},\n  onSelect: e => {},\n  onSelectEnd: e => {},\n  onSqueezeStart: e => {},\n  onSqueeze: e => {},\n  onSqueezeEnd: e => {},\n\n  onButtonDown: e => {},\n  onButtonClick: e => {},\n  onButtonUp: e => {},\n  onAxisChange: e => {},\n\n  targetRay: true,\n  targetRay: {facade: MyCustomLaser},\n  targetRay: {color: 0x33ff33},\n  cursor: true,\n  cursor: {facade: MyCustomCursor},\n  cursor: {color: 0xff0000},\n  grip: true,\n  grip: {facade: PlatformGripModel},\n  grip: {\n    facade: Group3DFacade,\n    children: [{\n      key: 'main',\n      facade: PlatformGripModel\n    }, {\n      key: 'ui',\n      facade: GripTabletFacade,\n      visible: state.\n    }]\n  }\n}\n\n\n\n{\n  facade: XRInputSourceConfig,\n  configs: [\n    {\n      match: src => src.targetRayMode === 'tracked-pointer' && src.handedness === 'left'\n    }\n  ]\n}\n\n\n\n---\n\nFor each XRInputSource:\n  - Resolve a XRInputSourceFacade\n    - based on...?\n  - Find objects in scene matching the XRInputSource\n    - based on: targetRayMode, handedness, profiles, ...?\n    - if none found, supply a default set\n\n\n\n*/\n\n\n\n/**\n * A container facade, placed at the root of the scene, that manages the tracking of\n * `XRInputSource`s and the rendering of their related scene objects.\n *\n *\n */\nclass XRInputSourceManager extends ParentFacade {\n  constructor(parent) {\n    super(parent);\n    this._sourcesDirty = true;\n\n    // Required props:\n    this.xrSession = null;\n    this.xrReferenceSpace = null;\n\n    // Separate subtree for the XRInputSourceFacade instances:\n    this._xrInputSourceSubtree = new ParentFacade(this);\n\n    this._onInputSourcesChange = e => {\n      this._sourcesDirty = true;\n      this.afterUpdate();\n    };\n  }\n\n  afterUpdate() {\n    const {xrSession, _lastXrSession} = this;\n\n    if (xrSession !== _lastXrSession) {\n      this._lastXrSession = xrSession;\n      if (_lastXrSession) {\n        _lastXrSession.removeEventListener('inputsourceschange', this._onInputSourcesChange);\n      }\n      if (xrSession) {\n        xrSession.addEventListener('inputsourceschange', this._onInputSourcesChange);\n      }\n    }\n\n    if (this._sourcesDirty) {\n      this._sourcesDirty = false;\n      const inputSources = xrSession && xrSession.inputSources;\n      this._xrInputSourceSubtree.children = inputSources && Array.from(inputSources).map(xrInputSource => {\n        // TODO resolve config overrides?\n        return {\n          facade: XRInputSourceFacade,\n          key: utils.getIdForObject(xrInputSource),\n          xrInputSource,\n          xrSession: this.xrSession,\n          xrReferenceSpace: this.xrReferenceSpace\n        }\n      });\n      this._xrInputSourceSubtree.afterUpdate();\n    }\n    super.afterUpdate();\n  }\n\n  destructor () {\n    if (this.xrSession) {\n      this.xrSession.removeEventListener('inputsourceschange', this._onInputSourcesChange);\n    }\n    super.destructor();\n    this._xrInputSourceSubtree.destructor();\n  }\n}\n\n/*global XRRigidTransform*/\n\nconst tempVec3$1 = new Vector3();\nconst tempVec3b = new Vector3();\nconst tempQuat$1 = new Quaternion();\nconst dummyObj = {};\nconst tempMat4 = new Matrix4();\n\nfunction extendAsXRCamera (BaseCameraFacadeClass) {\n  return doExtendAsXRCamera(BaseCameraFacadeClass || PerspectiveCamera3DFacade)\n}\n\nconst doExtendAsXRCamera = utils.createClassExtender('xrCamera', function (BaseCameraFacadeClass) {\n  return class XRCameraFacade extends BaseCameraFacadeClass {\n    constructor (parent) {\n      super(parent);\n\n      // Required props\n      this.xrSession = null;\n      this.xrReferenceSpace = null;\n\n      // This will behave like an ArrayCamera with a sub-camera for each view.\n      // The individual view cameras will be created as needed based on the xrFrame's pose views.\n      const mainCam = this.threeObject;\n      mainCam.isArrayCamera = true;\n      mainCam.cameras = [];\n\n      // Expose the camera's configured position/orientation as an offset XRReferenceSpace.\n      this.offsetReferenceSpace = null;\n\n      // Update cameras on every render frame\n      this.addEventListener('xrframe', this._onXrFrame.bind(this));\n    }\n\n    afterUpdate () {\n      const { near, far, xrSession } = this;\n\n      // Update near/far planes\n      const { depthNear, depthFar } = xrSession.renderState;\n      if (near !== depthNear || far !== depthFar) {\n        xrSession.updateRenderState({\n          depthNear: near,\n          depthFar: far\n        });\n      }\n\n      super.afterUpdate();\n    }\n\n    updateMatrices () {\n      // Update offsetReferenceSpace to match configured camera position/rotation\n      // TODO test if this reacts to reset events properly\n      const { xrReferenceSpace } = this;\n      const offsetChanging = this._matrixChanged || xrReferenceSpace !== this._lastRefSpace;\n      super.updateMatrices();\n      if (offsetChanging) {\n        this._lastRefSpace = xrReferenceSpace;\n        invertMatrix4(this.threeObject.matrix, tempMat4).decompose(tempVec3$1, tempQuat$1, dummyObj);\n        this.offsetReferenceSpace = xrReferenceSpace\n          ? xrReferenceSpace.getOffsetReferenceSpace(new XRRigidTransform(tempVec3$1, tempQuat$1))\n          : null;\n      }\n    }\n\n    /**\n     * Handle syncing the cameras to the current XRFrame's pose data\n     */\n    _onXrFrame (timestamp, xrFrame) {\n      const { xrSession, offsetReferenceSpace, threeObject: mainCam } = this;\n      const pose = offsetReferenceSpace && xrFrame.getViewerPose(offsetReferenceSpace);\n\n      if (pose && xrSession && xrSession.renderState.baseLayer) {\n        const views = pose.views;\n        const viewCameras = mainCam.cameras;\n\n        // Remove extra cameras if the count is decreasing\n        while (viewCameras.length > views.length) {\n          mainCam.layers.disable(viewCameras.length--);\n        }\n\n        // Update each eye view\n        for (let i = 0; i < views.length; i++) {\n          const view = views[i];\n          let viewCam = viewCameras[i];\n\n          // Create the view's sub-camera if needed\n          if (!viewCam) {\n            viewCam = viewCameras[i] = new PerspectiveCamera();\n            viewCam.viewport = new Vector4();\n            // Match the ThreeJS convention of layer masks per eye\n            viewCam.layers.enable(i + 1);\n            mainCam.layers.enable(i + 1);\n          }\n\n          // Update the sub-camera viewport and matrices to match the view\n          const viewport = xrSession.renderState.baseLayer.getViewport(view);\n          viewCam.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);\n          viewCam.matrixWorld.fromArray(view.transform.matrix);\n          viewCam.matrixWorldInverse.fromArray(view.transform.inverse.matrix);\n          viewCam.projectionMatrix.fromArray(view.projectionMatrix);\n        }\n\n        // We also need to make the main camera match an overall pose/projection for use in\n        // frustum culling etc. For now let's just copy the first view's data.\n        // TODO this isn't good enough for the frustum, it results in overaggressive culling from the right eye.\n        //  Should use a combined frustum once available from API (https://github.com/w3c/webvr/issues/203)\n        //  or calculate it ourselves like ThreeJS does with WebVRUtils.setProjectionFromUnion\n        if (views.length === 2) {\n          setProjectionFromUnion(mainCam, viewCameras[0], viewCameras[1]);\n        }\n      }\n    }\n  }\n});\n\n/**\n * NOTE: mostly copied from private function in ThreeJS's WebXRManager at\n * https://github.com/mrdoob/three.js/blob/f43ec7c849d7cecbc4831d152cf6a5d97c45ad3b/src/renderers/webxr/WebXRManager.js#L281\n *\n * Assumes 2 cameras that are parallel and share an X-axis, and that\n * the cameras' projection and world matrices have already been set.\n * And that near and far planes are identical for both cameras.\n * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765\n */\nfunction setProjectionFromUnion (camera, cameraL, cameraR) {\n\n  tempVec3$1.setFromMatrixPosition(cameraL.matrixWorld);\n  tempVec3b.setFromMatrixPosition(cameraR.matrixWorld);\n\n  const ipd = tempVec3$1.distanceTo(tempVec3b);\n\n  const projL = cameraL.projectionMatrix.elements;\n  const projR = cameraR.projectionMatrix.elements;\n\n  // VR systems will have identical far and near planes, and\n  // most likely identical top and bottom frustum extents.\n  // Use the left camera for these values.\n  const near = projL[14] / (projL[10] - 1);\n  const far = projL[14] / (projL[10] + 1);\n  const topFov = (projL[9] + 1) / projL[5];\n  const bottomFov = (projL[9] - 1) / projL[5];\n\n  const leftFov = (projL[8] - 1) / projL[0];\n  const rightFov = (projR[8] + 1) / projR[0];\n  const left = near * leftFov;\n  const right = near * rightFov;\n\n  // Calculate the new camera's position offset from the\n  // left camera. xOffset should be roughly half `ipd`.\n  const zOffset = ipd / (-leftFov + rightFov);\n  const xOffset = zOffset * -leftFov;\n\n  // TODO: Better way to apply this offset?\n  cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);\n  camera.translateX(xOffset);\n  camera.translateZ(zOffset);\n  camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);\n  invertMatrix4(camera.matrixWorld, camera.matrixWorldInverse);\n\n  // Find the union of the frustum values of the cameras and scale\n  // the values so that the near plane's position does not change in world space,\n  // although must now be relative to the new union camera.\n  const near2 = near + zOffset;\n  const far2 = far + zOffset;\n  const left2 = left - xOffset;\n  const right2 = right + (ipd - xOffset);\n  const top2 = topFov * far / far2 * near2;\n  const bottom2 = bottomFov * far / far2 * near2;\n\n  camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);\n}\n\n/*global XRWebGLLayer*/\n\nconst emptyArray = [];\nconst tempVec2 = new Vector2();\n\nconst _xrSessions = new WeakMap();\n\n\nclass WorldXRFacade extends World3DFacade {\n  /**\n   * Relevant things passed in from XRAware:\n   * @property {XRSession} xrSession\n   * @property {XRSessionMode} xrSessionMode\n   * @property {XRReferenceSpace} xrReferenceSpace\n   * @property {XRReferenceSpaceType} xrReferenceSpaceType\n   * @property {number|string} xrFramebufferScaleFactor\n   *\n   * New global event types:\n   * `xrframe` - fired on each frame, with the current time and XRFrame object as arguments\n   */\n\n  afterUpdate() {\n    // Disable pointer events on the onscreen canvas when in an immersive XR session\n    this._togglePointerListeners(!this._isImmersive());\n\n    super.afterUpdate();\n\n    const {xrSession, _threeRenderer:renderer} = this;\n\n    const prevXrSession = _xrSessions.get(this);\n    if (xrSession !== prevXrSession) {\n      _xrSessions.set(this, xrSession);\n      this.renderingScheduler = xrSession || window;\n      setAnimationScheduler(xrSession || window);\n      if (xrSession) {\n        let baseLayer = xrSession.renderState.baseLayer;\n        const gl = renderer.getContext();\n\n        // If the session has an existing valid XRWebGLLayer, just grab its framebuffer.\n        // Otherwise, create a new XRWebGLLayer\n        if (baseLayer && baseLayer._glContext === gl) {\n          bindFramebuffer(renderer, baseLayer.framebuffer);\n        } else {\n          const promise = gl.makeXRCompatible ? gl.makeXRCompatible() : Promise.resolve(); //not always implemented?\n          promise.then(() => {\n            if (this.xrSession === xrSession) {\n              baseLayer = new XRWebGLLayer(xrSession, gl, {\n                antialias: !!renderer.getContextAttributes().antialias,\n                framebufferScaleFactor: parseFramebufferScaleFactor(this.xrFramebufferScaleFactor, xrSession)\n              });\n              baseLayer._glContext = gl;\n              xrSession.updateRenderState({ baseLayer });\n              bindFramebuffer(renderer, baseLayer.framebuffer);\n              this._queueRender();\n            }\n          });\n        }\n      } else {\n        bindFramebuffer(renderer, null);\n        renderer.setRenderTarget(renderer.getRenderTarget()); //see https://github.com/mrdoob/three.js/pull/15830\n        // reset canvas/viewport size in case something changed it (cough cough polyfill)\n        renderer.getSize(tempVec2);\n        renderer.setDrawingBufferSize(tempVec2.x, tempVec2.y, renderer.getPixelRatio());\n        this._queueRender();\n      }\n    }\n  }\n\n  /**\n   * @override\n   */\n  doRender(timestamp, xrFrame) {\n    // Invoke xrframe event handlers\n    if (xrFrame && xrFrame.session) {\n      this.eventRegistry.forEachListenerOfType('xrframe', fn => fn(timestamp, xrFrame), this);\n    }\n\n    super.doRender();\n  }\n\n  _isOpaque() { //TODO???\n    return this.xrSession && this.xrSession.environmentBlendMode === 'opaque'\n  }\n\n  _isImmersive() {\n    return this.xrSession && this.xrSessionMode !== 'inline'\n  }\n\n  /**\n   * @override to use an XR stereo camera when in immersive XR mode\n   */\n  _getCameraDef() {\n    const camera = super._getCameraDef();\n    if (this._isImmersive()) {\n      camera.facade = extendAsXRCamera(camera.facade);\n      camera.xrSession = this.xrSession;\n      camera.xrReferenceSpace = this.xrReferenceSpace;\n    }\n    return camera\n  }\n\n  /**\n   * @override to add VR controllers manager object\n   */\n  _getSceneDef() {\n    const scene = super._getSceneDef();\n    const {xrSession, xrReferenceSpace} = this;\n    if (xrSession && xrReferenceSpace) {\n      scene.objects = emptyArray.concat(\n        scene.objects,\n        {\n          key: 'xrInputMgr',\n          facade: XRInputSourceManager,\n          xrSession,\n          xrReferenceSpace\n        }\n      );\n    }\n    return scene\n  }\n\n  /**\n   * @override to always continuously render when in XR\n   */\n  _isContinuousRender() {\n    return this.xrSession || this.continuousRender\n  }\n\n  /**\n   * @override to skip rendering HTML overlays when in immersive mode\n   */\n  _doRenderHtmlItems() {\n    if (this._isImmersive()) {\n      if (this.renderHtmlItems) {\n        this.renderHtmlItems(emptyArray);\n      }\n    } else {\n      super._doRenderHtmlItems();\n    }\n  }\n}\n\nWorldXRFacade.prototype._notifyWorldHandlers = Object.create(\n  World3DFacade.prototype._notifyWorldHandlers,\n  {\n    // notification to end the XR session\n    endXRSession: {\n      value: function(source, data) {\n        if (this.xrSession) {\n          this.xrSession.end();\n        }\n      }\n    }\n  }\n);\n\nfunction parseFramebufferScaleFactor(value, xrSession) {\n  let scale = 1;\n  if (value != null) {\n    if (typeof value === 'string') {\n      if (/native/.test(value)) {\n        const mult = +value.replace(/\\s*native\\s*/, '') || 1;\n        const nativeScale = XRWebGLLayer.getNativeFramebufferScaleFactor(xrSession);\n        scale = nativeScale * mult;\n      }\n    } else {\n      scale = +value;\n    }\n    if (isNaN(scale)) scale = 1;\n  }\n  //console.info(`WebXR: using framebufferScaleFactor ${scale}`)\n  return scale\n}\n\n// Smooth out r127 framebuffer state refactor\nfunction bindFramebuffer(renderer, framebuffer) {\n  if (renderer.setFramebuffer) { //pre-r127\n    renderer.setFramebuffer(framebuffer);\n  } else if (renderer.state.bindXRFramebuffer) {\n    renderer.state.bindXRFramebuffer(framebuffer);\n  } else {\n    renderer.state.bindFramebuffer(framebuffer);\n  }\n}\n\nconst SESSION_MODES = ['inline', 'immersive-vr']; //TODO add others as they are added to the specs\nconst REFERENCE_SPACE_TYPES = ['viewer', 'local', 'local-floor', 'bounded-floor', 'unbounded'];\n\n\n/**\n * The types of the props that are passed down to the wrapped React component\n */\nconst XRAwarePropTypes = {\n  xrSupported: T.bool,\n  xrSupportedSessionModes: T.arrayOf(T.oneOf(SESSION_MODES)),\n  xrSession: T.object,\n  xrSessionMode: T.oneOf(SESSION_MODES),\n  xrReferenceSpace: T.object,\n  xrReferenceSpaceType: T.oneOf(REFERENCE_SPACE_TYPES),\n  xrLauncher: T.element\n};\n\n\n/**\n * Wraps a React component class/function in a higher-order component which enables support\n * for WebXR. The wrapper handles querying the browser for supported XR session types,\n * initiating a supported XR session, and upgrading any descendant `Canvas3D` components\n * with support for rendering XR stereo views and handling XR input controllers.\n *\n *\n *\n * @param {class|function} ReactClass\n * @param {object} options\n * @param {React.Component} options.xrLauncherRenderer - The React component to use for\n *        rendering the launcher button. Defaults to a basic launcher button implementation.\n * @param {string[]} options.sessionModes - The XRSessionMode(s) supported by this particular scene.\n *        Assumes an 'immersive-vr' experience only by default. Authors can add 'inline' as a\n *        fallback, or force 'inline' only.\n *        TODO: allow secondary mode to be chosen by the user, rather than just as a fallback?\n * @param {string[]} options.referenceSpaces - The XRReferenceSpaceType(s) supported by this particular scene.\n *        By default a floor-relative space is required, preferring 'bounded-floor', falling\n *        back to 'local-floor', and failing session initialization if neither is available or\n *        permitted by the user. Authors can change this list to support other reference space\n *        types as fallbacks. All but the final will be used as `optionalFeatures`, and the final\n *        will be used for `requiredFeatures`.\n *        TODO: allow secondary spaces to be chosen by the user, rather than just as a fallback?\n *        TODO: allow different spaces to be specified for immersive-vr vs. local modes?\n * @param {number|string} options.framebufferScaleFactor - Scaling factor for the XR framebuffer.\n *        A number is used directly as the WebGLLayer's `framebufferScaleFactor` parameter. The\n *        string \"native\" uses the device's native resolution. A string containing \"native\" and\n *        a number, e.g. \"0.5 native\", uses the device's native resolution multiplied by that\n *        number. Defaults to `1` per the WebXR spec.\n *        TODO: allow 'auto' adaptive scaling to maintain frame rate\n *        TODO: allow changing this value on the fly\n * @return {class}\n */\nfunction ReactXRAware(ReactClass, options) {\n  options = utils.assign({\n    xrLauncherRenderer: XRLauncher,\n    sessionModes: ['immersive-vr'],\n    referenceSpaces: ['bounded-floor', 'local-floor'],\n    framebufferScaleFactor: 1\n  }, options);\n\n  class XRAware extends React.Component {\n    constructor(props) {\n      super(props);\n\n      this.state = {\n        xrSupportedSessionModes: [],\n        xrSession: null,\n        xrSessionMode: null,\n        xrReferenceSpace: null,\n        xrReferenceSpaceType: null\n      }\n\n      // bind handler methods:\n      ;[\n        '_checkXrSupport',\n        '_onSessionEnded',\n        '_onLauncherSelect'\n      ].forEach(method => {\n        this[method] = this[method].bind(this);\n      });\n\n      const xr = navigator.xr;\n      if (xr) {\n        xr.addEventListener('devicechange', this._checkXrSupport);\n      }\n      this._checkXrSupport();\n    }\n\n    componentWillUnmount() {\n      const xr = navigator.xr;\n      if (xr) {\n        xr.removeEventListener('devicechange', this._checkXrSupport);\n      }\n    }\n\n    _checkXrSupport() {\n      const xr = navigator.xr;\n      if (xr) {\n        const xrSupportedSessionModes = [];\n        Promise.all(options.sessionModes.map(mode => {\n          if (typeof xr.isSessionSupported === 'function') {\n            return xr.isSessionSupported(mode)\n              .then(supported => {\n                if (supported) {\n                  xrSupportedSessionModes.push(mode);\n                } else {\n                  console.info(`XR session type '${mode}' not supported`);\n                }\n              })\n          } else {\n            // TODO remove this fallback for slightly old API impls...\n            return xr.supportsSession(mode)\n              .then(() => {\n                xrSupportedSessionModes.push(mode);\n              }, err => {\n                console.info(`XR session type '${mode}' not supported`, err);\n              })\n          }\n        })).then(() => {\n          this.setState({xrSupportedSessionModes});\n        });\n      } else {\n        this.setState({\n          xrSupportedSessionModes: []\n        });\n      }\n    }\n\n    _startSession(xrSessionMode) {\n      let {xrSupportedSessionModes, xrSession} = this.state;\n\n      // Stop current session if running\n      // TODO not sure if this is a potential race condition, but we can't wait for its promise\n      //  to resolve because that fails the \"user activation\" requirement for starting the new session.\n      //  We may want to make the selection UI require first ending a session before being able to select a new one.\n      if (xrSession) {\n        xrSession.end();\n      }\n\n      if (xrSupportedSessionModes.includes(xrSessionMode)) {\n        const candidateRefSpaces = options.referenceSpaces;\n        if (!candidateRefSpaces || !candidateRefSpaces.length) {\n          console.error('XRAware `referencesSpaces` cannot be empty');\n          return\n        }\n\n        navigator.xr.requestSession(xrSessionMode, {\n          optionalFeatures: candidateRefSpaces.slice(0, -1),\n          requiredFeatures: candidateRefSpaces.slice(-1)\n        })\n          .then(xrSession => {\n            xrSession.addEventListener('end', this._onSessionEnded, false);\n\n            // Get the first XRReferenceSpace supported by the hardware\n            const getRefSpace = (index=0) => {\n              const type = candidateRefSpaces[index];\n              return xrSession.requestReferenceSpace(type)\n                .then(xrReferenceSpace => [xrReferenceSpace, type])\n                .catch(err => {\n                  console.debug(`Reference space ${type} not supported or denied by user.`, err);\n                  if (index + 1 === candidateRefSpaces.length) {\n                    throw new Error(`All requested referenceSpaces (${candidateRefSpaces.join(', ')}) are either unsupported or were denied by the user.`)\n                  } else {\n                    return getRefSpace(index + 1)\n                  }\n                })\n            };\n            return getRefSpace().then(([xrReferenceSpace, xrReferenceSpaceType]) => {\n              this.setState({\n                xrSession,\n                xrSessionMode,\n                xrReferenceSpace,\n                xrReferenceSpaceType\n              });\n            })\n          })\n          .catch(err => {\n            console.error(err);\n            //TODO supply for user feedback... this.setState({xrSessionError: err})\n          });\n      }\n    }\n\n    _onSessionEnded(e) {\n      e.session.removeEventListener('end', this._onSessionEnded, false);\n      this.setState({\n        xrSession: null,\n        xrSessionMode: null,\n        xrReferenceSpace: null,\n        xrReferenceSpaceType: null\n      });\n    }\n\n    _onLauncherSelect(mode) {\n      // TODO this fails due to user activation requirement\n      // if (!mode || mode !== this.state.xrSessionMode) {\n      //   this._stopSession().then(() => {\n      //     if (mode) {\n      //       this._startSession(mode)\n      //     }\n      //   })\n      // } else {\n        this._startSession(mode);\n      //}\n    }\n\n    render() {\n      const {props, state} = this;\n      const {xrSupportedSessionModes, xrSession, xrSessionMode, xrReferenceSpace, xrReferenceSpaceType} = state;\n      const xrSupported = xrSupportedSessionModes.length > 0;\n\n      const xrLauncher = React.createElement(\n        options.xrLauncherRenderer,\n        {\n          xrSupportedSessionModes,\n          xrSupported,\n          xrSession,\n          onSelectSession: this._onLauncherSelect\n        }\n      );\n\n      const contextValue = {\n        worldFacade: WorldXRFacade,\n        worldProps: {\n          xrSession,\n          xrSessionMode,\n          xrReferenceSpace,\n          xrReferenceSpaceType,\n          xrFramebufferScaleFactor: options.framebufferScaleFactor\n        }\n      };\n\n      return React.createElement(Canvas3D.contextType.Provider, {value: contextValue},\n        React.createElement(\n          ReactClass,\n          utils.assign({}, props, {\n            xrSupported,\n            xrSupportedSessionModes,\n            xrSession,\n            xrSessionMode,\n            xrReferenceSpace,\n            xrReferenceSpaceType,\n            xrLauncher\n          }),\n          props.children\n        )\n      )\n    }\n  }\n\n  XRAware.displayName = `XRAware(${ReactClass.displayName || ReactClass.name || '?'})`;\n\n  return XRAware\n}\n\nconst getStrapGeometry = utils.memoize(() => {\n  return new CylinderGeometry(\n    1,\n    1,\n    1,\n    64,\n    1,\n    true,\n    // Math.PI / 4 * 3,\n    // Math.PI / 4 * 6\n  )\n    .rotateX(Math.PI / 2)\n});\n\nconst getStrapMaterial = utils.memoize(() => {\n  return new MeshStandardMaterial({\n    color: 0x333333,\n    side: DoubleSide\n  })\n});\n\nclass Strap extends Object3DFacade {\n  constructor (parent) {\n    super(parent, new Mesh(getStrapGeometry(), getStrapMaterial()));\n  }\n  set smallRadius(val) {\n    this.scaleX = val;\n  }\n  set largeRadius(val) {\n    this.scaleY = val;\n  }\n  set width(val) {\n    this.scaleZ = val;\n  }\n}\n\nconst getCogGeometry = utils.memoize(() => {\n  let outerRadius = 0.01;\n  let innerRadius = 0.006;\n  let midRadius = (innerRadius + outerRadius) * .75;\n  let teeth = 8;\n  let twoPi = Math.PI * 2;\n  let shape = new Shape().moveTo(midRadius, 0);\n  for (let i = 0; i < teeth; i++) {\n    let angle = i / teeth * twoPi;\n    shape.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);\n    angle = (i + 0.5) / teeth * twoPi;\n    shape.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);\n    shape.lineTo(Math.cos(angle) * midRadius, Math.sin(angle) * midRadius);\n    if (i === teeth - 1) {\n      shape.lineTo(midRadius, 0); //close shape exactly\n    } else {\n      angle = (i + 1) / teeth * twoPi;\n      shape.lineTo(Math.cos(angle) * midRadius, Math.sin(angle) * midRadius);\n    }\n  }\n  shape.holes.push(\n    new Path().absellipse(0, 0, innerRadius, innerRadius, 0, twoPi, false)\n  );\n  return new ExtrudeGeometry(shape, {\n    curveSegments: teeth * 2,\n    depth: 0.005,\n    bevelEnabled: false\n  })\n});\n\nclass Cog extends MeshFacade {\n  get geometry() {\n    return getCogGeometry()\n  }\n}\n\nconst tempVec3$2 = new Vector3();\n\nconst cogActiveAnim = {\n  from: {rotateX: 0},\n  to: {rotateX: Math.PI * 2},\n  duration: 5000,\n  iterations: Infinity\n};\n\n\nconst gripOffsetDist = 0.08;\nconst gripOffsetAngle = Math.PI / 4;\nconst largeRadius = 0.035;\nconst smallRadius = largeRadius * 0.75;\nconst strapWidth = 0.025;\n\n\nclass Wristband extends Group3DFacade {\n  /**\n   * Sync to the current XRFrame's gripPose - all matrix syncing is localized here\n   * to avoid a full afterUpdate pass on every frame.\n   */\n  syncPose(gripPose) {\n    if (gripPose) {\n      this.visible = true;\n      copyXRPoseToFacadeProps(gripPose, this);\n      this.traverse(updateMatrices);\n      if (this.onCogMove && this._cogFacade) {\n        this.onCogMove(this._cogFacade.getWorldPosition(tempVec3$2));\n      }\n    } else {\n      this.visible = false;\n    }\n  }\n\n  describeChildren () {\n    let { active } = this;\n\n    let groupDef = this._childTpl || (this._childTpl = {\n      key: 'g',\n      facade: Group3DFacade,\n      rotateX: -gripOffsetAngle,\n      y: gripOffsetDist * Math.cos(gripOffsetAngle),\n      z: gripOffsetDist * Math.sin(gripOffsetAngle),\n      children: [\n        {\n          key: 'strap',\n          facade: Strap,\n          smallRadius,\n          largeRadius,\n          width: strapWidth\n        },\n        {\n          key: 'cog',\n          facade: Cog,\n          ref: f => {\n            this._cogFacade = f;\n          },\n          rotateY: Math.PI / 2,\n          x: smallRadius,\n          animation: null,\n          transition: {\n            scale: {\n              duration: 500,\n              easing: 'easeOutBack'\n            },\n            'material.color': {\n              interpolate: 'color'\n            }\n          }\n        }\n      ]\n    });\n\n    let [, cogDef] = groupDef.children;\n    cogDef.scale = active ? 1.75 : 1;\n    cogDef['material.color'] = active ? 0x3399ff : 0x999999;\n    cogDef.animation = active ? cogActiveAnim : null;\n\n    return groupDef\n  }\n}\n\n\nfunction updateMatrices(obj) {\n  if (obj.updateMatrices) {\n    obj.updateMatrices();\n  }\n}\n\nconst vertexShader = `\nvarying vec2 vUV;\nvoid main() {\n  vUV = uv;\n  if (uv.y == 0.0) { //src pos is worldspace\n    gl_Position = projectionMatrix * viewMatrix * vec4(position, 1.0);\n  } else {\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n}\n`;\n\nconst baseAlpha = 0.2;\nconst scanlines = [\n  // sep = separation between lines\n  // vel = movement speed, in scans per second\n  // size = width of line's gradient\n  // alpha = alpha to add at line's center\n  {sep: 0.4, vel: 0.15, size: 0.1, alpha: 0.1},\n  {sep: 0.7, vel: 0.2, size: 0.15, alpha: 0.1},\n  {sep: 0.3, vel: 0.3, size: 0.1, alpha: 0.1},\n  {sep: 0.2, vel: 0.6, size: 0.1, alpha: 0.04},\n  {sep: 0.1, vel: 0.4, size: 0.02, alpha: 0.04},\n];\n\nconst fragmentShader = `\nuniform float time;\nuniform vec4 fade;\nuniform vec3 color;\nvarying vec2 vUV;\n\nfloat distToScanline(float x, float separation, float velocity) {\n  x += time / 1000.0 * velocity;\n  float dist = abs(x - round(x / separation) * separation);\n  return dist;\n}\n\nvoid main() {\n  float alpha = ${baseAlpha};\n  ${scanlines.map(({sep, vel, size, alpha}) =>\n    `alpha += ${alpha} * smoothstep(${size / 2}, 0.0, distToScanline(vUV.y, ${sep}, ${vel}));`\n  ).join('\\n')}\n  alpha *= min(smoothstep(fade.x, fade.y, vUV.y), smoothstep(fade.w, fade.z, vUV.y));\n  gl_FragColor = vec4(color, alpha);\n}\n`;\n\nconst epoch = Date.now();\n\nconst defaultColor = 0x3399ff;\n\nlet createMaterial = function() {\n  return new ShaderMaterial({\n    uniforms: {\n      time: {get value() {return epoch - Date.now()}},\n      color: {value: new Color()},\n      fade: {value: new Vector4(0, 0.4, 0.7, 1)} //fade in+out gradient stops\n    },\n    vertexShader,\n    fragmentShader,\n    transparent: true,\n    // side: DoubleSide\n  })\n};\n\n/**\n * A holographic projection cone effect. Creates a translucent mesh in a cone shape from\n * a single world-space source vertex to an arbitrary target shape, with animated lines\n * traveling from source to target.\n *\n * @member {Vector3} sourceWorldPosition - The world-space position of the cone's source\n * @member {number[]} targetVertices - The local-space vertices describing the target shape,\n *         e.g. a rectangle or circle. This array is treated as immutable, so if you need to\n *         update the vertices then pass a new array instance.\n * @member {Color|number|string} color - The color of the\n */\nclass Projection extends MeshFacade {\n  constructor (parent) {\n    super(parent);\n    this.threeObject.frustumCulled = false;\n    this.renderOrder = 99999;\n\n    this.geometry = new BufferGeometry();\n    this.autoDisposeGeometry = true;\n    this.color = defaultColor;\n\n    this.material = createMaterial();\n  }\n\n  syncSourcePosition() {\n    // Sync the geometry from the current sourceWorldPosition value\n    let {sourceWorldPosition:srcPos} = this;\n    let posAttr = this.threeObject.geometry.getAttribute('position');\n    if (srcPos && posAttr && (\n      srcPos.x !== posAttr.getX(0) || srcPos.y !== posAttr.getY(0) || srcPos.z !== posAttr.getZ(0)\n    )) {\n      posAttr.setXYZ(0, srcPos.x, srcPos.y, srcPos.z);\n      posAttr.needsUpdate = true;\n    }\n  }\n\n  afterUpdate() {\n    let {targetVertices, geometry, color} = this;\n\n    // Update geometry vertices\n    let posAttr = this.geometry.getAttribute('position');\n    if (!posAttr || posAttr._data !== targetVertices) { //Note: targetVertices treated as immutable\n      // position attribute: [...source_vertices, ...targetVertices]\n      let posArr = new Float32Array(targetVertices.length + 3);\n      posArr.set(targetVertices, 3); //first pos reserved for source vertex\n      posAttr = new BufferAttribute(posArr, 3);\n      posAttr.usage = DynamicDrawUsage;\n      geometry.setAttribute('position', posAttr);\n\n      // uv attribute: [0, 0, 0, 1, 0, 1, 0, 1, etc.]\n      let uvAttr = new BufferAttribute(new Float32Array(posAttr.count * 2), 2);\n      for (let i = 1; i < uvAttr.count; i++) {\n        uvAttr.setY(i, 1);\n      }\n      geometry.setAttribute('uv', uvAttr);\n\n      // index: triangles from the source vertex to each consecutive pair of target vertices\n      let indexArr = [];\n      for (let i = 1, len = targetVertices.length / 3; i <= len; i++) {\n        indexArr.push(0, i === 1 ? len : i - 1, i);\n      }\n      geometry.setIndex(indexArr);\n    }\n\n    // Handle changing sourceWorldPosition\n    this.syncSourcePosition();\n\n    // Material\n    if (color == null) {\n      color = defaultColor;\n    }\n    if (color !== this._color) {\n      this.material.uniforms.color.value.set(this._color = color);\n    }\n\n    super.afterUpdate();\n  }\n}\n\nconst tempMat4$1 = new Matrix4();\nconst targetPos = new Vector3();\nconst camPos = new Vector3();\n\nclass ContentContainer extends Object3DFacade {\n  constructor (parent) {\n    super(parent, new Group());\n    this.distancePastGrip = 0.25; //distance past grip in camera-to-grip direction\n    this.minDistanceFromCamera = 0.5;\n    this.heightAboveGrip = 0.15;\n    this.platformRadius = 0.25;\n    this.projectionColor = null;\n    this.projectionSourcePosition = null; //worldspace vec3\n    this.gripPose = null;\n    this.active = false;\n    this.keepContentAlive = false;\n  }\n\n  /**\n   * Sync to the current XRFrame's gripPose - all matrix syncing is localized here\n   * to avoid a full afterUpdate pass on every frame.\n   */\n  syncPose(gripPose) {\n    let visible = false;\n    if (gripPose) {\n      // Get current posed camera position, relative to the parent\n      let cam = this.getCameraFacade().threeObject;\n      camPos.setFromMatrixPosition(cam.matrixWorld)\n        .applyMatrix4(invertMatrix4(this.threeObject.parent.matrixWorld, tempMat4$1));\n\n      // Find target position\n      let targetScale;\n      if (this.active) {\n        // Find direction vector and lengthen it to the target distance to find base position\n        targetPos.copy(gripPose.transform.position);\n        targetPos.y = camPos.y;\n        targetPos.sub(camPos);\n        targetPos.setLength(Math.max(this.minDistanceFromCamera, targetPos.length() + this.distancePastGrip));\n        targetPos.add(camPos);\n        targetPos.y = gripPose.transform.position.y + this.heightAboveGrip;\n        targetScale = 1;\n      } else {\n        targetPos.copy(gripPose.transform.position);\n        targetScale = 0.001;\n      }\n\n      // Pull partway toward target position and scale, like a spring\n      let pos = this.threeObject.position;\n      pos.lerp(targetPos, 0.05); //move by 5% of distance each frame)\n      this.scale += (targetScale - this.scale) * 0.3;\n      visible = this.scale > 0.01; //hide below a certain size\n\n      if (visible) {\n        // Rotate to face camera\n        this.rotateY = Math.atan2(camPos.x - pos.x, camPos.z - pos.z);\n\n        // Update projection cone's source position\n        let proj = this.getChildByKey('$projection');\n        if (proj) {\n          proj.syncSourcePosition();\n        }\n\n        // Sync all matrices\n        this.traverse(updateMatrices$1);\n      }\n    }\n    if (visible !== this.visible) {\n      this.update({visible});\n    }\n  }\n\n  describeChildren() {\n    if (!this.visible && !this.keepContentAlive) {\n      return null\n    }\n\n    let kids = this._kidsTpl || (this._kidsTpl = [\n      {\n        key: '$platform',\n        facade: CircleFacade,\n        radius: 1,\n        material: 'lambert',\n        castShadow: true,\n        receiveShadow: true,\n        'material.color': 0x333333\n      },\n      {\n        key: '$projection',\n        facade: Projection,\n        sourceWorldPosition: new Vector3(),\n        targetVertices: Object.freeze(function () {\n          // trace circular path\n          let verts = [];\n          for (let i = 0; i < 32; i++) {\n            let angle = Math.PI * 2 * (i / 32);\n            verts.push(Math.cos(angle), 0, Math.sin(angle));\n          }\n          return verts\n        }())\n      }\n    ]);\n\n    // Update platform size\n    kids[0].scale = kids[1].scale = this.platformRadius;\n\n    // Update projection source\n    kids[1].sourceWorldPosition = this.projectionSourcePosition;\n\n    // Colors\n    kids[0]['material.color'] = this.platformColor;\n    kids[1].color = this.projectionColor;\n\n    return kids.concat(this.children)\n  }\n}\n\nfunction updateMatrices$1(obj) {\n  if (obj.updateMatrices) {\n    obj.updateMatrices();\n    obj._checkBoundsChange(); //TODO ugh shouldn't have to call private method\n  }\n}\n\nconst tempMat4$2 = new Matrix4();\nconst tempQuat$2 = new Quaternion();\nconst tempVec3$3 = new Vector3();\nconst upVec3 = new Vector3(0, 1, 0);\n\n\n/**\n * This facade provides a container for arbitrary global UI, which is hidden by default\n * but is easily brought up by a simple gesture. A wristband is added to one of the hand\n * controllers, with an icon affordance on the inner wrist. When that icon is turned\n * upwards, the UI is projected from it.\n *\n * @property {('left'|'right')} preferredHand - which hand the wristband should appear on.\n */\nclass WristMountedUI extends Group3DFacade {\n  constructor (parent) {\n    super(parent);\n    // Config:\n    this.activeUpAngle = Math.PI / 7;\n    this.preferredHand = 'left';\n    this.platformRadius = 0.25;\n    this.platformColor = 0x333333;\n    this.projectionColor = 0x3399ff;\n    this.keepContentAlive = false;\n    this.onActiveChange = null;\n\n    // Internal state:\n    this.gripPose = null;\n    this.active = false;\n\n    this._cogPos = new Vector3();\n    this.addEventListener('xrframe', this.onXRFrame.bind(this));\n  }\n\n  describeChildren () {\n    // Only render children if we have a valid gripPose\n    if (!this.gripPose) {\n      return null\n    }\n\n    let children = this._childTpl || (this._childTpl = [\n      {\n        key: 'wristband',\n        facade: Wristband,\n        active: false,\n        gripPose: null,\n        onCogMove: (worldPos) => {\n          this._cogPos.copy(worldPos);\n        }\n      },\n      {\n        key: 'content',\n        facade: ContentContainer,\n        active: false,\n        gripPose: null,\n        children: null\n      }\n    ]);\n\n    let [wristbandDef, contentDef] = children;\n    wristbandDef.active = contentDef.active = this.active;\n    //wristbandDef.gripPose = contentDef.gripPose = this.gripPose\n    contentDef.platformRadius = this.platformRadius;\n    contentDef.platformColor = this.platformColor;\n    contentDef.projectionColor = this.projectionColor;\n    contentDef.projectionSourcePosition = this._cogPos;\n    contentDef.keepContentAlive = this.keepContentAlive;\n    contentDef.children = this.children;\n\n    return children\n  }\n\n  updateMatrices() {\n    // Force matrix to match that of the camera's pre-pose transform\n    this.threeObject.matrixWorld.copy(this.getCameraFacade().threeObject.matrix);\n    this.markWorldMatrixDirty();\n  }\n\n  onXRFrame (time, xrFrame) {\n    let gripPose = null;\n    let active = false;\n    let inputSources = xrFrame.session.inputSources;\n    if (inputSources) {\n      let gripSpace = null;\n      for (let i = 0, len = inputSources.length; i < len; i++) {\n        if (inputSources[i].handedness === this.preferredHand) {\n          gripSpace = inputSources[i].gripSpace;\n          break\n        }\n      }\n      if (gripSpace) {\n        // Calculate grip pose so we can pass it down to the Wristband\n        // Note: the gripPose will be relative to this object's matrix, which is synced to the\n        // camera's base position. This simplifies child transform calculations because you can\n        // treat them always as relative to default position/orientation.\n        let cam = this.getCameraFacade();\n        gripPose = xrFrame.getPose(gripSpace, cam.xrReferenceSpace);\n        if (gripPose) {\n          // If turned to upward angle, set to active\n          // TODO: needs debouncing!\n          tempVec3$3.set(1, 0, 0).applyQuaternion(\n            tempQuat$2.setFromRotationMatrix(tempMat4$2.fromArray(gripPose.transform.matrix))\n          );\n          active = tempVec3$3.angleTo(upVec3) < this.activeUpAngle;\n        }\n      }\n    }\n\n    if (active !== this.active) {\n      if (this.onActiveChange) {\n        this.onActiveChange(active);\n      }\n      this.update({active});\n    }\n\n    if (!!gripPose !== !!this.gripPose) {\n      this.update({gripPose});\n    }\n    else if (gripPose) {\n      // Skip full afterUpdate pass, just give the gripPose to children - they both have\n      // a syncPose method to handle syncing matrices without a full afterUpdate.\n      this.forEachChild(child => child.syncPose(gripPose));\n    }\n  }\n}\n\nconst degreeToRad = Math.PI / 180;\n\nlet getMarkerGeometry = function () {\n  const radius = 0.15;\n  const innerRadius = 0.1;\n  const depth = 0.05;\n  const shape = new Shape();\n  shape.moveTo(radius, -radius)\n    .lineTo(radius, 0)\n    .absellipse(0, 0, radius, radius, 0, 270 * degreeToRad, false, 0)\n    .lineTo(radius, -radius);\n  shape.holes = [\n    new Path().moveTo(innerRadius, -innerRadius)\n      .lineTo(0, -innerRadius)\n      .absellipse(0, 0, innerRadius, innerRadius, 270 * degreeToRad, 0, true, 0)\n      .lineTo(innerRadius, -innerRadius)\n  ];\n\n  const geom = new ExtrudeGeometry(shape, {\n    curveSegments: 64,\n    depth,\n    bevelEnabled: false\n    // bevelSize: 0.01,\n    // bevelThickness: 0.01,\n    // bevelSegments: 1\n  })\n    .rotateX(Math.PI / 2)\n    .rotateY(Math.PI / 4)\n    .translate(0, depth, 0);\n\n  getMarkerGeometry = () => geom;\n  return geom\n};\n\nclass GroundTarget extends MeshFacade {\n  constructor (parent) {\n    super(parent);\n    this.geometry = getMarkerGeometry();\n    this.material = new MeshLambertMaterial({\n      transparent: true,\n      opacity: 0.8\n    });\n    this.autoDisposeGeometry = true;\n  }\n}\n\nconst raycastPlane = new Plane().setComponents(0, 1, 0, 0);\nconst tempVec3$4 = new Vector3();\nconst tempQuat$3 = new Quaternion();\nconst infiniteSphere = new Sphere(undefined, Infinity);\n\n/**\n * Basic teleportation. Add an instance of this facade anywhere in the scene.\n * The user can point-drag an XR pointer ray at the ground plane and be\n * teleported to that location when releasing. They can use a thumbstick while\n * targeting a ground location to set the resulting orientation direction. Also,\n * using the thumbstick while not targeting the ground will snap-rotate the view\n * by 45 degrees.\n *\n * It must be given a `onTeleport` callback function, which will be called with\n * an object holding `{position: {xPos, zPos}, rotation: yRot}`. These can then\n * be applied to the scene's `camera` config as the new camera reference origin.\n *\n * Currently this implementation only supports teleporting along the x-z plane\n * at y=0.\n */\nclass TeleportControls extends Object3DFacade {\n  constructor (parent) {\n    super(parent, new Group());\n\n    this.maxDistance = 10;\n    this.targeting = false;\n    this.onTeleport = null;\n\n    let markerConfig = this.markerConfig = {\n      key: 'marker',\n      facade: GroundTarget,\n      'material.color': 0x003399,\n      visible: false\n    };\n    this.children = [\n      markerConfig\n    ];\n\n    let lastAxisAngle = 0;\n    this.addEventListener('dragstart', e => {\n      lastAxisAngle = 0;\n      this.targeting = true;\n      this.afterUpdate();\n    });\n    this.addEventListener('drag', e => {\n      if (this.targeting) {\n        let point = e.ray.intersectPlane(raycastPlane, tempVec3$4);\n        if (point && point.distanceTo(this.getCameraPosition()) < this.maxDistance) {\n          this.targeting = true;\n          markerConfig.x = tempVec3$4.x;\n          markerConfig.z = tempVec3$4.z;\n          this.requestRender();\n          // For rotation, start with the current direction of the camera. Then rotate\n          // relative to that by the last controller stick/axis position.\n          tempQuat$3.setFromRotationMatrix(this.getCameraFacade().threeObject.matrixWorld);\n          tempVec3$4.set(0, 0, -1).applyQuaternion(tempQuat$3);\n          markerConfig.rotateY = Math.atan2(-tempVec3$4.x, -tempVec3$4.z) + lastAxisAngle;\n        } else {\n          this.targeting = false;\n        }\n        this.afterUpdate();\n      }\n    });\n    this.addEventListener('dragend', e => {\n      if (this.targeting) {\n        this.targeting = false;\n        this.afterUpdate();\n        this.onTeleport({\n          position: { x: markerConfig.x, z: markerConfig.z },\n          rotation: markerConfig.rotateY\n        });\n      }\n    });\n\n    const rotateDebounce = 500;\n    const rotateBy = Math.PI / -4;\n    let lastRotateTime = 0;\n    this.addEventListener('wheel', e => {\n      if (this.targeting) {\n        lastAxisAngle = Math.atan2(-e.deltaX, -e.deltaY);\n      } else {\n        let now = Date.now();\n        if (now - lastRotateTime > rotateDebounce && Math.abs(e.deltaX) > Math.abs(e.deltaY)) {\n          lastRotateTime = now; //keep from rotating again until axis is reset\n          this.onTeleport({\n            rotation: Math.sign(e.deltaX) * rotateBy + this.getCameraFacade().rotateY\n          });\n        }\n      }\n    });\n  }\n\n  afterUpdate () {\n    this.markerConfig.visible = this.targeting;\n    super.afterUpdate();\n  }\n\n  getBoundingSphere () {\n    return infiniteSphere\n  }\n\n  // Raycast for dragging events will hit anywhere on ground plane if no other object\n  // is hit first.\n  raycast (raycaster) {\n    const intersection = raycaster.ray.intersectPlane(raycastPlane, tempVec3$4);\n    return intersection\n      ? [{\n        distance: raycaster.ray.origin.distanceTo(intersection),\n        point: intersection.clone()\n      }]\n      : null\n  }\n}\n\nexport { AXIS_THUMBSTICK_X, AXIS_THUMBSTICK_Y, AXIS_TOUCHPAD_X, AXIS_TOUCHPAD_Y, BUTTON_DEFAULT_BACK, BUTTON_SQUEEZE, BUTTON_THUMBSTICK, BUTTON_TOUCHPAD, BUTTON_TRIGGER, Basic as BasicGrip, CursorFacade, GripFacade, OculusTouchGrip, ReactXRAware, TARGET_RAY_RENDERORDER, TargetRayFacade, TeleportControls, WorldXRFacade, WristMountedUI, XRAwarePropTypes, XRInputSourceFacade, copyXRPoseToFacadeProps, extendAsXRCamera };\n", "import { Runner, Tween, MultiTween, SpringTween } from 'troika-animation';\nimport React from 'react';\nimport T from 'prop-types';\n\n///// Miscellaneous Utility Functions /////\n\n\n/**\n * Pseudo-polyfilled shortcut for `Object.assign`. Copies own properties from\n * second-and-after arguments onto the first object, overwriting any that already\n * exist, and returns the first argument.\n * @return {object}\n */\nconst assign = Object.assign || _assign;\n\n// Non-native impl; exported for access by tests\nfunction _assign(/*target, ...sources*/) {\n  let target = arguments[0];\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    let source = arguments[i];\n    if (source) {\n      for (let prop in source) {\n        if (source.hasOwnProperty(prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n  return target\n}\n\n\n/**\n * Like {@link assign}, but will ony copy properties that do _not_ already\n * exist on the target object.\n * @return {object}\n */\nfunction assignIf(/*target, ...sources*/) {\n  let target = arguments[0];\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    let source = arguments[i];\n    if (source) {\n      for (let prop in source) {\n        if (source.hasOwnProperty(prop) && !target.hasOwnProperty(prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n  return target\n}\n\n/**\n * Like {@link assign}, but for any property where the source and target are both\n * sub-objects, does a deep recursive copy.\n * @param {object} target\n * @param {object} source\n */\nfunction assignDeep(target, source) {\n  if (source) {\n    for (let prop in source) {\n      if (source.hasOwnProperty(prop)) {\n        if (target[prop] && typeof target[prop] === 'object' && typeof source[prop] === 'object') {\n          assignDeep(target[prop], source[prop]);\n        } else {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n}\n\n\n/**\n * Iterate over an object's own (non-prototype-inherited) properties\n * @param {object} object - The object to iterate over\n * @param {function} fn - A function that will be invoked for each iterated property. It\n *        will be passed three arguments:\n *        - value (the property value)\n *        - key (the property name)\n *        - object (the object being iterated over)\n * @param {*} [scope] - An optional object to be used as `this` when calling the `fn`\n */\nfunction forOwn(object, fn, scope) {\n  for (let prop in object) {\n    if (object.hasOwnProperty(prop)) {\n      fn.call(scope, object[prop], prop, object);\n    }\n  }\n}\n\n\n/**\n * Given an object instance, return a consistent unique id for it.\n * @type function\n * @param {Object} obj - The object instance\n * @return {string} id\n */\nconst getIdForObject = (() => {\n  let objIds = new WeakMap();\n  let lastId = 0;\n  return function getIdForObject(obj) {\n    let id = objIds.get(obj);\n    if (!id) {\n      objIds.set(obj, (id = `$id${++lastId}`));\n    }\n    return id\n  }\n})();\n\n\n/**\n * Create a function that memoizes the result of another function based on the most\n * recent call's arguments and `this`. The arguments are compared using strict shallow equality.\n * @param {function} fn\n * @return {function}\n */\nfunction memoize(fn) {\n  let prevArgs, prevThis, prevResult;\n  return function() {\n    let changed = !prevArgs || this !== prevThis || arguments.length !== prevArgs.length;\n    if (!changed) {\n      for (let i = 0, len = arguments.length; i < len; i++) {\n        if (arguments[i] !== prevArgs[i]) {\n          changed = true;\n          break\n        }\n      }\n    }\n    if (changed) {\n      prevArgs = Array.prototype.slice.call(arguments);\n      prevThis = this;\n      prevResult = fn.apply(this, arguments);\n    }\n    return prevResult\n  }\n}\n\n\n/**\n * Utility for the \"extend-as\" pattern used in several places to decorate facade\n * classes with extra capabilities.\n * @param {string} name - unique identifier for this class extension\n * @param {function} doExtend - the function that creates the actual class extension,\n *        this is passed the base class and will only be called once per base class.\n * @return {function(class): class}\n */\nfunction createClassExtender(name, doExtend) {\n  const cache = new WeakMap();\n  return function(classToExtend) {\n    let extended = cache.get(classToExtend);\n    if (!extended) { //bidir check due to inheritance of statics\n      extended = doExtend(classToExtend);\n      cache.set(classToExtend, extended);\n    }\n    return extended\n  }\n}\n\n\n/**\n * Determine whether a given object is a React element descriptor object, i.e. the\n * result of a JSX transpilation to React.createElement().\n * @param obj\n * @return {boolean}\n */\nfunction isReactElement(obj) {\n  const t = obj.$$typeof;\n  return (t && t.toString && t.toString() === 'Symbol(react.element)') || false\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  assign: assign,\n  _assign: _assign,\n  assignIf: assignIf,\n  assignDeep: assignDeep,\n  forOwn: forOwn,\n  getIdForObject: getIdForObject,\n  memoize: memoize,\n  createClassExtender: createClassExtender,\n  isReactElement: isReactElement\n});\n\n/**\n * The base class for all Facade classes.\n *\n * A Facade is basically just a class that receives property assignments from a scene descriptor\n * and manages forwarding the resulting state to more complex underlying implementation\n * objects, e.g. ThreeJS objects.\n *\n * The instantiated facade objects have a very simple lifecycle:\n *   - The `constructor` in which the initial state and the underyling implementation object(s)\n *     can be initialized. It will be passed a single argument: the `parent` facade object.\n *   - Updates to the object's properties, usually by direct assignment from the scene descriptor.\n *     These updates can be handled immediately by defining property setters that handle syncing\n *     new values to the underyling implementation object(s).\n *   - The `afterUpdate()` method which signals the end of all property updates; this can be\n *     implemented to handle syncing the full set of updated properties to the underlying\n *     implementation object(s). Useful if an aspect of the syncing relies on multiple properties\n *     or needs things to be synced in a specific order.\n *   - The `destructor` method which is always called when the object is removed from the scene.\n *     Implement this to remove and clean up the underlying implementation object(s) and other\n *     cleanup logic.\n *\n * Scene Descriptors:\n *\n * All facade instances are created, updated, and destroyed based on the current structure of\n * a scene descriptor object. The properties in the descriptor are generally just copied\n * directly to properties of the same names on the facade instance, which can handle them\n * either by custom setters or in `afterUpdate`. There are a few special properties in the\n * descriptor:\n *\n *   - `facade`: (required) a reference to the Facade class that will be instantiated.\n *   - `key`: (recommended) an identifier that is unique amongst the descriptor's siblings, which\n *     is used to associate the descriptor with its corresponding Facade instance. One will be\n *     assigned automatically if omitted, but it's recommended that you set one manually to ensure\n *     descriptors are predictably resolved to the same facade instances when siblings are being\n *     added or removed. Not doing so can lead to unnecessary facade destruction/creation and/or\n *     unpredictable facade states.\n *   - `children`: (optional) for `Parent` facade subclasses, defines the child object descriptors.\n *   - `ref`: (optional) a function that will be called with a reference to the instantiated Facade\n *     on creation, and with `null` on destruction, allowing external code to maintain references\n *     to individual facades.\n *   - `transition`: (optional) defines a set of properties that should be transitioned smoothly\n *     when their value changes. See `Animatable` for more details.\n *   - `animation`: (optional) defines one or more keyframe animations. See `Animatable` for more\n *     details.\n *   - `exitAnimation`: (optional) defines a keyframe animation to run when the facade is removed\n *     from its parent.\n *   - `pointerStates`: (optional) defines sets of property values that should be used in place\n *     of those defined on the main object, when the user's pointer (mouse, touch, vr controller,\n *     etc.) is in `hover` or `active` interaction state with the facade. See `PointerStates`\n *     for more details.\n *\n * It is also possible to define facade descriptors using JSX (https://reactjs.org/docs/introducing-jsx.html),\n * if it is precompiled to `React.createElement` calls. In this case, use the facade class as the JSX\n * element name instead of a `facade` property, and child descriptors are defined as nested JSX elements i\n * nstead of a `children` property. *NOTE:* While this is often a nicer looking syntax than the plain JS object\n * form, be aware that the creation of JSX elements does carry a slight performance cost from extra logic\n * and object allocations, so you should avoid it when defining large numbers of facades or when updating\n * descriptors on every frame.\n */\nclass Facade {\n  constructor(parent) {\n    this.$facadeId = `facade${ idCounter++ }`;\n    this.parent = parent;\n  }\n\n  /**\n   * Performs a manual update of this facade, invoking the afterUpdate lifecycle method and triggering a\n   * render. This can be called in event handlers, for example, to affect changes to this facade and its\n   * subtree. This process is synchronous. Never override this method as a way to react to updates, as it\n   * is not the only way a component is updated; instead override `afterUpdate` or use setters.\n   * @param {object} [props] - A set of properties to be copied to the facade\n   */\n  update(props) {\n    if (props && typeof props === 'object') {\n      // Always assign transition and animation first\n      this.transition = props.transition;\n      this.animation = props.animation;\n      for (let prop in props) {\n        if (props.hasOwnProperty(prop) && !Facade.isSpecialDescriptorProperty(prop)) {\n          this[prop] = props[prop];\n        }\n      }\n    }\n    this.afterUpdate();\n    this.requestRender();\n  }\n\n  /**\n   * Called at the end of an update batch, after all individual properties have been assigned.\n   */\n  afterUpdate() {\n    // Handle calling ref function\n    let ref = this.ref;\n    if (ref !== this._lastRef) {\n      if (typeof this._lastRef === 'function') {\n        this._lastRef.call(null, null);\n      }\n      if (typeof ref === 'function') {\n        ref.call(null, this);\n        this._lastRef = ref;\n      } else {\n        this._lastRef = null;\n      }\n    }\n  }\n\n  /**\n   * Dispatch a message with optional data up the facade parent tree.\n   */\n  notifyWorld(message, data) {\n    if (this.parent) {\n      this.parent.onNotifyWorld(this, message, data);\n    }\n  }\n\n  /**\n   * Default onNotifyWorld handler just bubbles it up the parent chain.\n   */\n  onNotifyWorld(source, message, data) {\n    let notifiableParent = this._notifiableParent;\n    if (notifiableParent) {\n      notifiableParent.onNotifyWorld.call(notifiableParent, source, message, data);\n    } else {\n      // Optimization: on first call, walk up the tree looking for the first ancestor with a\n      // non-default onNotifyWorld implementation, and save a pointer to that ancestor\n      // facade so we can just call it directly the next time without any tree walking.\n      notifiableParent = this.parent;\n      let defaultImpl = Facade.prototype.onNotifyWorld;\n      while (notifiableParent) {\n        if (notifiableParent.onNotifyWorld !== defaultImpl) {\n          this._notifiableParent = notifiableParent;\n          notifiableParent.onNotifyWorld(source, message, data);\n          break\n        }\n        notifiableParent = notifiableParent.parent;\n      }\n    }\n  }\n\n  /**\n   * Notifies the top-level world manager that this object has changed in some way that affects its\n   * visible rendering, so a rendering frame will be scheduled.\n   */\n  requestRender() {\n    this.notifyWorld('needsRender');\n  }\n\n  traverse(fn) {\n    fn(this);\n  }\n\n  forEachChild(fn) {\n  }\n\n  /**\n   * Add an event listener for the given event type.\n   * @param {String} type\n   * @param {Function} handler\n   */\n  addEventListener(type, handler) {\n    this.notifyWorld('addEventListener', {type, handler});\n  }\n\n  /**\n   * Remove an event listener for the given event type.\n   * @param {String} type\n   * @param {Function} handler\n   */\n  removeEventListener(type, handler) {\n    this.notifyWorld('removeEventListener', {type, handler});\n  }\n\n  /**\n   * Dispatch an Event object on this facade, with DOM events bubbling logic.\n   * @param {Event} event\n   */\n  dispatchEvent(event) {\n    this.notifyWorld('dispatchEvent', event);\n  }\n\n  /**\n   * Called when the instance is being removed from the scene. Override this to implement any\n   * custom cleanup logic.\n   */\n  destructor() {\n    // Unregister all event listeners from the world\n    if (this.parent) {\n      this.notifyWorld('removeAllEventListeners');\n    }\n\n    // Teardown refs\n    if (typeof this.ref === 'function') {\n      this.ref.call(null, null);\n    }\n    this.parent = this._notifiableParent = null;\n  }\n}\n\nassign(Facade.prototype, {\n  ref: null,\n  _lastRef: null,\n  _notifiableParent: null\n});\n\n\nlet idCounter = 0;\nconst DEF_SPECIAL_PROPS = {key:1, facade:1, transition:1, animation:1};\n\n/**\n * @static\n * Determine if a certain property name is one of the special descriptor properties\n */\nFacade.isSpecialDescriptorProperty = function(name) {\n  return DEF_SPECIAL_PROPS.hasOwnProperty(name)\n};\n\n/**\n * @static\n * Define a property name as an event handler for a given Facade class, so that it\n * automatically updates the global event registry when set.\n * @param {class} facadeClass - the class whose prototype the property should be defined on\n * @param {String} propName - the name of the event handler property, e.g. 'onMouseOver'\n * @param {String} eventType - the type of the event that will trigger the handler, e.g. 'mouseover'\n */\nFacade.defineEventProperty = function(facadeClass, propName, eventType) {\n  let privateProp = `${propName}handler`;\n  Object.defineProperty(facadeClass.prototype, propName, {\n    get() {\n      return this[privateProp]\n    },\n    set(handler) {\n      const oldHandler = this[privateProp];\n      if ((handler || null) !== (oldHandler || null)) {\n        // Remove old listener\n        if (typeof oldHandler === 'function') {\n          this.removeEventListener(eventType, oldHandler);\n        }\n        // Add new listener\n        if (typeof handler === 'function') {\n          this.addEventListener(eventType, handler);\n        }\n        this[privateProp] = handler;\n      }\n    }\n  });\n};\n\nconst DEFAULT_DURATION = 750;\nconst DEFAULT_EASING = 'easeOutCubic';\n\nconst TEMP_ARRAY = [null];\n\nfunction animationIdJsonReplacer(key, value) {\n  return key === 'paused' ? undefined : value === Infinity ? 'Infinity' : value\n}\n\nfunction compareByTime(a, b) {\n  return a.time - b.time\n}\n\nconst extendAsAnimatable = createClassExtender('animatable', function(BaseFacadeClass) {\n  class AnimatableFacade extends BaseFacadeClass {\n\n    constructor(...args) {\n      super(...args);\n\n      // Create root runner for all this object's animation and transition tweens\n      this.animation$runner = new Runner();\n      this.animation$runner.onTick = () => {\n        this.afterUpdate();\n        this.requestRender();\n      };\n    }\n\n    /**\n     * Handle the special \"transition\" property. The descriptor should be an object with\n     * transitionable property names as keys and transition parameters as values. The\n     * transition parameters can either be objects describing the transition parameters,\n     * or `true` for a default transition.\n     *\n     *   transition: {\n     *     x: true, // uses a default duration-based transition\n     *     y: 'spring', //uses a default spring-based transition\n     *     z: {\n     *       // ...custom transition config\n     *     }\n     *   }\n     *\n     * The custom transition config object can take one of two forms for duration- vs.\n     * spring-based animations:\n     *\n     * Duration-based:\n     *\n     *   {\n     *     duration: n, //in ms, defaults to 750\n     *     easing: e, //easing function, defaults to 'easeOutCubic'\n     *     delay: n, //in ms, defaults to 0\n     *     interpolate: 'number' //one of the builtin named interpolators ('number', 'color', etc.) or a custom Function\n     *   }\n     *\n     * Spring-based:\n     *\n     *   {\n     *     spring: s, //either `true`, a named preset string e.g. \"wobbly\", or an object with {mass, tension, friction}\n     *     delay: n //in ms, defaults to 0\n     *   }\n     *\n     * Note that spring-based transitions do not currently support custom interpolations so they should only be used\n     * for numeric values.\n     */\n    set transition(descriptor) {\n      if (descriptor) {\n        // Ensure setter/getter has been created for all props in transition\n        for (let propName in descriptor) {\n          if (descriptor.hasOwnProperty(propName)) {\n            defineTransitionPropInterceptor(propName, this);\n          }\n        }\n      }\n      this.transition$descriptor = descriptor;\n    }\n    get transition() {\n      return this.transition$descriptor\n    }\n\n\n    /**\n     * Handle the special \"animation\" property. The descriptor should be an object or array\n     * of objects defining a set of keyframes and their playback parameters. Keyframes are\n     * defined by numeric keys from 0 to 100, each defining an object with the target\n     * property values for that keyframe.\n     *\n     *   animation: [{\n     *     0: {rotateZ: 0, color: 0x000000}, //can also use key \"from\"\n     *     100: {rotateZ: Math.PI * 2, color: 0xffffff}, //can also use key \"to\"\n     *     delay: 0, //starting delay in ms\n     *     duration: 2000, //total anim duration in ms, defaults to 750\n     *     easing: 'linear', //easing for the whole animation, defaults to 'linear'\n     *     iterations: 5, //number of times to loop the animation, defaults to 1. Set to Infinity for endless loop.\n     *     direction: 'forward', //either 'forward', 'backward', or 'alternate'\n     *     interpolate: {color: 'color'}, //mapping of property names to Interpolators.js names or custom functions\n     *     paused: false //if true the animation will be paused at its current position until set back to false\n     *   }, ...]\n     *\n     * Internally the animations will be built into a set of nested tweens:\n     *\n     * |--------------------------- Main MultiTween ------------------------------------|\n     *\n     * |------------- Anim 1 MultiTween w/ easing+repeat ----------------|\n     * |--- prop1 tween 1 ---|--- prop1 tween 2 ---|--- prop1 tween 3 ---|\n     * |--------- prop2 tween 1 --------|--------- prop2 tween 2 --------|\n     *\n     *                    delay -->|-------- Anim 2 MultiTween w/ easing+repeat --------|\n     *                             |----- prop3 tween 1 -----|----- prop3 tween 2 ------|\n     *                             |------------------- prop4 tween --------------------|\n     *                                            |----------- prop5 tween -------------|\n     */\n    set animation(descriptor) {\n      if (this.animation$descriptor === descriptor) return\n      this.animation$descriptor = descriptor;\n      let oldAnimTweens = this.animation$tweens || null;\n      let newAnimTweens = this.animation$tweens = descriptor ? Object.create(null) : null;\n      let runner = this.animation$runner;\n      let hasChanged = false;\n\n      // Handle single object not wrapped in array\n      if (descriptor && !Array.isArray(descriptor)) {\n        TEMP_ARRAY[0] = descriptor;\n        descriptor = TEMP_ARRAY;\n      }\n\n      if (descriptor) {\n        for (let i = 0, len = descriptor.length; i < len; i++) {\n          let animDesc = descriptor[i];\n          if (!animDesc) continue\n\n          // Calculate an identifier for this animation based on properties whose modification requires a new tween\n          let animId = JSON.stringify(animDesc, animationIdJsonReplacer);\n          //console.log(`${animId} - is ${oldAnimTweens && oldAnimTweens[animId] ? '' : 'not'} in old tweens`)\n\n          // If a matching tween already exists, update it\n          if (oldAnimTweens && (animId in oldAnimTweens)) {\n            let tween = oldAnimTweens[animId];\n            if (animDesc.paused) {\n              runner.pause(tween);\n            } else {\n              runner.start(tween);\n            }\n            newAnimTweens[animId] = tween;\n          }\n          // Otherwise create a new tween\n          else {\n            let delay = 0;\n            let duration = DEFAULT_DURATION;\n            let easing = 'linear';\n            let iterations = 1;\n            let keyframes = [];\n            let direction = 'forward';\n\n            for (let key in animDesc) {\n              if (animDesc.hasOwnProperty(key)) {\n                switch(key) {\n                  case 'duration':\n                    duration = animDesc[key]; break\n                  case 'delay':\n                    delay = animDesc[key]; break\n                  case 'easing':\n                    easing = animDesc[key]; break\n                  case 'iterations':\n                    iterations = animDesc[key]; break\n                  case 'direction':\n                    direction = animDesc[key]; break\n                  default: {\n                    let percent = key === 'from' ? 0 : key === 'to' ? 100 : parseFloat(key);\n                    if (!isNaN(percent) && percent >= 0 && percent <= 100) {\n                      keyframes.push({time: percent / 100, props: animDesc[key]});\n                      for (let animProp in animDesc[key]) {\n                        if (animDesc[key].hasOwnProperty(animProp)) {\n                          // Ensure setter is in place\n                          defineTransitionPropInterceptor(animProp, this);\n                          // Stop any active transition tweens for this property\n                          let tweenKey = animProp + 'anim:tween';\n                          if (this[tweenKey]) {\n                            runner.stop(this[tweenKey]);\n                            this[tweenKey] = null;\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n\n            if (keyframes.length) {\n              // Sort the keyframes by time\n              keyframes.sort(compareByTime);\n              if (keyframes[0].time > 0) {\n                keyframes.unshift(assignIf({time: 0}, keyframes[0]));\n              }\n\n              // Build a MultiTween with tweens for each keyframe+property\n              let keyframePropTweens = [];\n              for (let j = 1, len = keyframes.length; j < len; j++) {\n                let keyframe = keyframes[j];\n                let props = keyframe.props;\n                for (let prop in props) {\n                  if (props.hasOwnProperty(prop)) {\n                    let prevKeyframe = null;\n                    for (let k = j; k--;) {\n                      if (prop in keyframes[k].props) {\n                        prevKeyframe = keyframes[k];\n                        break\n                      }\n                    }\n                    if (prevKeyframe) {\n                      let propTween = new Tween(\n                        this[prop + 'anim:actuallySet'].bind(this), //callback\n                        prevKeyframe.props[prop], //fromValue\n                        props[prop], //toValue\n                        (keyframe.time - prevKeyframe.time) * duration, //duration\n                        prevKeyframe.time * duration, //delay\n                        'linear', //easing\n                        1, //iterations\n                        'forward', //direction\n                        animDesc.interpolate && animDesc.interpolate[prop] || 'number'\n                      );\n                      propTween.$$property = prop;\n                      keyframePropTweens.push(propTween);\n                    }\n                  }\n                }\n              }\n              let tween = newAnimTweens[animId] = new MultiTween(keyframePropTweens, duration, delay, easing, iterations, direction);\n              if (!animDesc.paused) {\n                runner.start(tween);\n              }\n\n              // The tween runner won't do anything until next tick, so immediately sync to the first frame's\n              // properties if the animation has no delay to avoid a flash of bad initial state\n              if (delay === 0) {\n                let firstKeyframeProps = keyframes[0].props;\n                for (let prop in firstKeyframeProps) {\n                  if (firstKeyframeProps.hasOwnProperty(prop)) {\n                    this[prop + 'anim:actuallySet'](firstKeyframeProps[prop]);\n                  }\n                }\n              }\n            }\n\n            hasChanged = true;\n          }\n        }\n      }\n\n      // Stop any obsolete tweens\n      if (oldAnimTweens) {\n        for (let animId in oldAnimTweens) {\n          if (!newAnimTweens || !newAnimTweens[animId]) {\n            let tween = oldAnimTweens[animId];\n            tween.gotoEnd(); //force to end value so it doesn't stick partway through\n            runner.stop(tween);\n            hasChanged = true;\n          }\n        }\n      }\n\n      // If the total set of animations has changed, recalc the set of animating properties\n      if (hasChanged) {\n        if (newAnimTweens) {\n          let animatingProps = this.animation$animatingProps = Object.create(null);\n          for (let animId in newAnimTweens) {\n            let propTweens = newAnimTweens[animId].tweens;\n            for (let i = propTweens.length; i--;) {\n              animatingProps[propTweens[i].$$property] = true;\n            }\n          }\n        } else {\n          this.animation$animatingProps = null;\n        }\n      }\n    }\n    get animation() {\n      return this.animation$descriptor\n    }\n\n    destructor() {\n      const runner = this.animation$runner;\n      if (this.exitAnimation && !this.parent.isDestroying) {\n        runner.stopAll();\n        this.animation = this.exitAnimation;\n        this.exitAnimation = this.transition = null;\n        const onTick = runner.onTick;\n        runner.onTick = () => {\n          if (this.parent && !this.parent.isDestroying) {\n            onTick();\n          } else {\n            // An ancestor may have been destroyed during our exit animation, orphaning this object;\n            // catch this case and short-circuit the animation to prevent errors in subsequent ticks\n            runner.onDone = null;\n            this.destructor();\n          }\n        };\n        runner.onDone = () => {\n          this.requestRender();\n          this.destructor();\n        };\n      } else {\n        runner.destructor();\n        super.destructor();\n      }\n    }\n  }\n\n  // Add get/set interceptor to the wrapper's prototype if this is the first time seeing this prop. Putting it\n  // on the wrapper prototype allows us to avoid per-instance overhead as well as avoid collisions with\n  // other custom setters anywhere else in the prototype chain.\n  function defineTransitionPropInterceptor(propName, currentInstance) {\n    if (!AnimatableFacade.prototype.hasOwnProperty(propName)) {\n      let actualValueKey = `${ propName }anim:actualValue`;\n      let actuallySetKey = `${ propName }anim:actuallySet`;\n      let hasBeenSetKey = `${ propName }anim:hasBeenSet`;\n      let activeTweenKey = `${ propName }anim:tween`;\n\n      // Find the nearest getter/setter up the prototype chain, if one exists. Assuming the prototype won't change after the fact.\n      let superGetter, superSetter;\n      let proto = BaseFacadeClass.prototype;\n      while (proto) {\n        let desc = Object.getOwnPropertyDescriptor(proto, propName);\n        if (desc) {\n          superSetter = desc.set;\n          superGetter = desc.get;\n          if (superSetter && !superGetter || superGetter && !superSetter) {\n            throw new Error(`Animatable: property ${propName} has a custom ${superSetter ? 'setter' : 'getter'} but no ${superSetter ? 'getter' : 'setter'}. Animatable properties must have both.`)\n          }\n          break\n        }\n        proto = Object.getPrototypeOf(proto);\n      }\n\n      // Function to set the value, bypassing the interceptor setter.\n      // Use the super setter if available, otherwise store in a private-ish key\n      let actuallySet = superSetter ? function actuallySet(value) {\n        superSetter.call(this, value);\n        if (!this[hasBeenSetKey]) {\n          this[hasBeenSetKey] = true;\n        }\n      } : function actuallySet(value) {\n        this[actualValueKey] = value;\n        if (!this[hasBeenSetKey]) {\n          this[hasBeenSetKey] = true;\n        }\n      };\n      Object.defineProperty(AnimatableFacade.prototype, actuallySetKey, { value: actuallySet });\n\n\n      // Add the custom getter/setter for this property\n      Object.defineProperty(AnimatableFacade.prototype, propName, {\n        get() {\n          // Always return the current actual value\n          return superGetter ? superGetter.call(this) : this[hasBeenSetKey] ? this[actualValueKey] : BaseFacadeClass.prototype[propName]\n        },\n\n        set(value) {\n          // Will this value be controlled by an animation? Ignore it since animations take precedence.\n          if (this.animation$animatingProps && this.animation$animatingProps[propName]) {\n            return\n          }\n\n          // Does this value have a transition defined, and are the old/new values transitionable?\n          let runner = this.animation$runner;\n          let transition = this.transition;\n          if (transition && transition[propName] && this[hasBeenSetKey] && transition.hasOwnProperty(propName)) {\n            transition = transition[propName];\n            let springConfig = transition === 'spring' ? 'default' : transition.spring;\n            // If there's no active transition tween, or the new value is different than the active tween's\n            // target value, initiate a new transition tween. Otherwise ignore it.\n            let tween = this[activeTweenKey];\n            let needsNewTween = false;\n            if (tween) {\n              // Active tween - start new one if new value is different than the old tween's target\n              // value, unless they're both springs in which case update the original\n              if (value !== tween.toValue) {\n                if (springConfig && tween.isSpring) {\n                  // TODO allow mid-simulation modification of spring config?\n                  tween.toValue = value;\n                } else {\n                  runner.stop(tween);\n                  needsNewTween = true;\n                }\n              }\n            } else if (value !== this[propName]) {\n              // No active tween - only start one if the value is changing\n              needsNewTween = true;\n            }\n            if (needsNewTween) {\n              tween = this[activeTweenKey] = springConfig\n                ? new SpringTween(\n                  actuallySet.bind(this), //callback\n                  this[propName], //fromValue\n                  value, //toValue\n                  springConfig, //springConfig (mass, friction, tension)\n                  0, //initialVelocity\n                  transition.delay || 0 //delay\n                )\n                : new Tween(\n                  actuallySet.bind(this), //callback\n                  this[propName], //fromValue\n                  value, //toValue\n                  transition.duration || DEFAULT_DURATION, //duration\n                  transition.delay || 0, //delay\n                  transition.easing || DEFAULT_EASING, //easing\n                  1, //iterations\n                  'forward', //direction\n                  transition.interpolate || 'number' //interpolate\n                );\n              tween.onDone = () => {\n                tween = this[activeTweenKey] = null;\n              };\n              runner.start(tween);\n            }\n            return\n          }\n\n          // No animation or transition will be started; set the value.\n          actuallySet.call(this, value);\n\n          // Clean up obsolete stuff\n          let tween = this[activeTweenKey];\n          if (tween) runner.stop(tween);\n          this[activeTweenKey] = null;\n        }\n      });\n    }\n\n\n    // If the instance had this property set before the intercepting setter was added to the\n    // prototype, that would continue to take precedence, so move its value to the private property.\n    if (currentInstance.hasOwnProperty(propName)) {\n      currentInstance[`${ propName }anim:actualValue`] = currentInstance[propName];\n      currentInstance[`${ propName }anim:hasBeenSet`] = true;\n      delete currentInstance[propName];\n    }\n\n  }\n\n  return AnimatableFacade\n});\n\n/**\n * Allows a facade to be configured with an optional `pointerStates` property, which defines\n * sets of property values that should be used in place of the object's actual values when\n * the user interacts with the facade using their pointer device (mouse, touch, vr controller, etc.)\n * This is not used directly, but is automatically wrapped by `ParentFacade` and `ListFacade` when\n * setting up their children if the `pointerStates` property is present.\n *\n * The `pointerStates` property should point to an object with `hover` and/or `active` properties,\n * each of which is an object holding the individual properties to be used in those states. Any\n * properties defined in `active` will take precedence over those defined in `hover`.\n *\n * The properties will honor any `transition`s defined for them, but the `transition` must be\n * defined on the facade's main configuration object, not within the pointerStates themselves.\n */\nconst extendAsPointerStatesAware = createClassExtender('pointerStates', function(BaseFacadeClass) {\n  const isHoveringProp = 'pntr:isHovering';\n  const isActiveProp = 'pntr:isActive';\n  const propsWithInterceptors = Object.create(null);\n\n  class PointerStatesAware extends BaseFacadeClass {\n    constructor(parent) {\n      super(parent);\n      this.addEventListener('mouseover', hoverOverHandler);\n      this.addEventListener('mouseout', hoverOutHandler);\n      this.addEventListener('mousedown', activeDownHandler);\n      this.addEventListener('mouseup', activeUpHandler);\n    }\n\n    afterUpdate() {\n      this._applyPointerStates();\n      super.afterUpdate();\n    }\n\n    _applyPointerStates() {\n      const pointerStates = this.pointerStates;\n      const hoverValuesToUse = (pointerStates && this[isHoveringProp] && pointerStates.hover) || null;\n      const activeValuesToUse = (pointerStates && this[isActiveProp] && pointerStates.active) || null;\n\n      const lastAppliedValues = this['pntr:lastAppliedValues'] || propsWithInterceptors;\n      const appliedValues = this['pntr:lastAppliedValues'] =\n        (hoverValuesToUse || activeValuesToUse) ? assign(Object.create(null), hoverValuesToUse, activeValuesToUse) : null;\n\n      if (appliedValues) {\n        for (let prop in appliedValues) {\n          definePropInterceptor(prop, this);\n          actuallySet(this, prop, appliedValues[prop]);\n        }\n      }\n\n      if (lastAppliedValues) {\n        for (let prop in lastAppliedValues) {\n          if (!appliedValues || !(prop in appliedValues)) {\n            actuallySet(this, prop, this[`${prop}pntr:baseValue`]);\n          }\n        }\n      }\n    }\n  }\n\n  // Flag for identification\n  Object.defineProperty(PointerStatesAware.prototype, 'isPointerStateAware', {value: true});\n\n  // Add get/set interceptor to the wrapper's prototype if this is the first time seeing this prop. Putting it\n  // on the wrapper prototype allows us to avoid per-instance overhead as well as avoid collisions with\n  // other custom setters anywhere else in the prototype chain.\n  function definePropInterceptor(propName, currentInstance) {\n    // On first set for this instance, move the prop's previous value, if any, to the private property\n    const hasBeenSetProp = `${propName}pntr:hasBeenSet`;\n    if (!currentInstance[hasBeenSetProp]) {\n      currentInstance[`${ propName }pntr:baseValue`] = currentInstance[propName];\n      delete currentInstance[propName]; //remove own prop so it doesn't override the prototype getter/setter\n      currentInstance[hasBeenSetProp] = true;\n    }\n\n    if (!PointerStatesAware.prototype.hasOwnProperty(propName)) {\n      propsWithInterceptors[propName] = 1;\n      const baseValueProp = `${ propName }pntr:baseValue`;\n      const appliedValueProp = `${propName}pntr:appliedValue`;\n\n      Object.defineProperty(PointerStatesAware.prototype, propName, {\n        get() {\n          const superGetter = getSuperGetter(propName);\n          return superGetter ? superGetter.call(this) :\n            (appliedValueProp in this) ? this[appliedValueProp] :\n            this[baseValueProp]\n        },\n\n        set(value) {\n          this[baseValueProp] = value;\n        }\n      });\n    }\n  }\n\n  function actuallySet(instance, propName, value) {\n    const superSetter = getSuperSetter(propName);\n    if (superSetter) {\n      superSetter.call(instance, value);\n    } else {\n      instance[`${propName}pntr:appliedValue`] = value;\n    }\n  }\n\n  function getSuperGetter(propName) {\n    let proto = BaseFacadeClass.prototype;\n    if (propName in proto) { //prefilter across entire proto chain\n      while (proto) {\n        let desc = Object.getOwnPropertyDescriptor(proto, propName);\n        if (desc && desc.get) {\n          return desc.get\n        }\n        proto = Object.getPrototypeOf(proto);\n      }\n    }\n    return null\n  }\n\n  function getSuperSetter(propName) {\n    let proto = BaseFacadeClass.prototype;\n    if (propName in proto) { //prefilter across entire proto chain\n      while (proto) {\n        let desc = Object.getOwnPropertyDescriptor(proto, propName);\n        if (desc && desc.set) {\n          return desc.set\n        }\n        proto = Object.getPrototypeOf(proto);\n      }\n    }\n    return null\n  }\n\n  function hoverOverHandler(e) {\n    e.currentTarget[isHoveringProp] = true;\n    afterPointerStateChange(e);\n  }\n  function hoverOutHandler(e) {\n    e.currentTarget[isHoveringProp] = e.currentTarget[isActiveProp] = false;\n    afterPointerStateChange(e);\n  }\n  function activeDownHandler(e) {\n    e.currentTarget[isActiveProp] = true;\n    afterPointerStateChange(e);\n  }\n  function activeUpHandler(e) {\n    e.currentTarget[isActiveProp] = false;\n    afterPointerStateChange(e);\n  }\n\n  function afterPointerStateChange(e) {\n    let highestFacade = e.currentTarget;\n    let parent = highestFacade.parent;\n    while (parent && parent.shouldUpdateChildren()) {\n      if (parent.isPointerStateAware) {\n        highestFacade = parent;\n      }\n      parent = parent.parent;\n    }\n    highestFacade.afterUpdate();\n    highestFacade.requestRender();\n  }\n\n  return PointerStatesAware\n});\n\n/**\n * ListFacade is an optimized way to define a large number of scene objects based on an array of data.\n * Unlike mapping a data array to `children` objects in the scene descriptor, ListFacade allows you to\n * define only a single \"template\" descriptor object whose properties are either constant values\n * or accessor functions that get invoked for each data item. The resulting property values are\n * then applied directly to the implementation objects, without creating any intermediary objects.\n *\n * Example:\n *\n *     {\n *       key: 'balls',\n *       facade: ListFacade,\n *       data: itemsData,\n *       template: {\n *         key: (item, i, all) => `ball_${ item.id }`,\n *         facade: Ball,\n *         x: (item, i, all) => item.time,\n *         y: (item, i, all) => item.count,\n *         radius: 10,\n *         color: (item, i, all) => item.important ? 0xff0000 : 0xcccccc\n *       }\n *     }\n */\nclass List extends Facade {\n  constructor(parent) {\n    super(parent);\n    this._orderedItemKeys = [];\n  }\n\n  afterUpdate() {\n    let {data, template} = this;\n    let hasData = data && data.length && Array.isArray(data);\n\n    // Allow the `template` to be defined as a JSX element, i.e. the result of React.createElement()\n    // TODO almost works, except that React stringifies the `key` function\n    // if (isReactElement(template)) {\n    //   template.props.key = template.key\n    //   template.props.facade = template.type\n    //   template = template.props\n    // }\n\n    // Some basic validation in dev mode\n    if (process.env.NODE_ENV !== 'production') {\n      if (data && !Array.isArray(data)) {\n        throw new Error('ListFacade \"data\" must be an array.')\n      }\n      if (!template || typeof template !== 'object') {\n        throw new Error('ListFacade \"template\" must be an object.')\n      }\n      if (!template || typeof template.key !== 'function') {\n        throw new Error('ListFacade template must define a \"key\" function.')\n      }\n      if (!template || typeof template.facade !== 'function') {\n        throw new Error('ListFacade template must define a \"facade\".')\n      }\n    }\n\n    if (this.shouldUpdateChildren()) {\n      let oldDict = this._itemsDict || null;\n      let newDict = this._itemsDict = hasData ? Object.create(null) : null;\n      let orderedItemKeys = this._orderedItemKeys;\n\n      if (hasData) {\n        orderedItemKeys.length = data.length;\n\n        for (let i = 0, len = data.length; i < len; i++) {\n          let childData = data[i];\n          let key = template.key(childData, i, data);\n          let facadeClass = template.facade;\n\n          // Some basic validation in dev mode\n          if (process.env.NODE_ENV !== 'production') {\n            if (key == null) {\n              throw new Error('ListFacade template \"key\" function must return a key.')\n            }\n            if (newDict[key]) {\n              console.warn(`Duplicate key in list: ${key}`);\n            }\n          }\n          while(newDict[key]) {\n            key += '|dupe';\n          }\n\n          // If a transition/animation is present, upgrade the class to a Animatable class on demand.\n          // NOTE: changing between animatable/non-animatable results in a full teardown/recreation\n          // of this instance *and its entire subtree*, so try to avoid that by always including the `transition`\n          // definition if the object is expected to ever need transitions, even if it's temporarily empty.\n          let transition = typeof template.transition === 'function' ? template.transition(childData, i, data) : template.transition;\n          let animation = typeof template.animation === 'function' ? template.animation(childData, i, data) : template.animation;\n          let exitAnimation = typeof template.exitAnimation === 'function' ? template.exitAnimation(childData, i, data) : template.exitAnimation;\n          if (transition || animation || exitAnimation) {\n            facadeClass = extendAsAnimatable(facadeClass);\n          }\n\n          // Same for pointer states\n          let pointerStates = template.pointerStates;\n          if (pointerStates === 'function' ? pointerStates(childData, i, data) : pointerStates) {\n            facadeClass = extendAsPointerStatesAware(facadeClass);\n          }\n\n          // If we have an old instance with the same key and class, reuse it; otherwise instantiate a new one\n          let oldImpl = oldDict && oldDict[key];\n          let newImpl;\n          if (oldImpl && oldImpl.constructor === facadeClass) {\n            newImpl = oldImpl;\n          } else {\n            // If swapping instance need to destroy the old before creating the new, e.g. for `ref` call ordering\n            if (oldImpl) oldImpl.destructor();\n            newImpl = new facadeClass(this);\n          }\n          //always set transition/animation before any other props\n          newImpl.transition = transition;\n          newImpl.animation = animation;\n          for (let prop in template) {\n            if (template.hasOwnProperty(prop) && !Facade.isSpecialDescriptorProperty(prop)) {\n              newImpl[prop] = typeof template[prop] === 'function' ? template[prop](childData, i, data) : template[prop];\n            }\n          }\n          newImpl.afterUpdate();\n          newDict[key] = newImpl;\n          orderedItemKeys[i] = key;\n        }\n      }\n\n      // Destroy all old child instances that were not reused or replaced\n      if (oldDict) {\n        for (let key in oldDict) {\n          if (!newDict || !newDict[key]) {\n            oldDict[key].destructor();\n          }\n        }\n      }\n    }\n\n    super.afterUpdate();\n  }\n\n  /**\n   * Override to selectively prevent updating the ListFacade's items on `afterUpdate`, for\n   * potential performance gain.\n   * @returns {boolean}\n   */\n  shouldUpdateChildren() {\n    return true\n  }\n\n  /**\n   * Walk this facade's descendant tree, invoking a function for it and each descendant.\n   * The iteration order will match the order in which the `data` items were declared. It may\n   * also include items that have been queued for removal but not yet removed, e.g. facades\n   * in the process of an `exitAnimation`.\n   * @param {Function} fn\n   * @param {Object} [thisArg]\n   */\n  traverse(fn, thisArg) {\n    fn.call(thisArg, this);\n    let keys = this._orderedItemKeys;\n    let dict = this._itemsDict;\n    for (let i = 0, len = keys.length; i < len; i++) {\n      dict[keys[i]].traverse(fn, thisArg);\n    }\n  }\n\n  /**\n   * Iterate over this facade's direct child facades, invoking a function for each.\n   * The iteration order will match the order in which the `data` items were declared. It may\n   * also include items that have been queued for removal but not yet removed, e.g. facades\n   * in the process of an `exitAnimation`.\n   * @param {Function} fn\n   * @param {Object} [thisArg]\n   */\n  forEachChild(fn, thisArg) {\n    let keys = this._orderedItemKeys;\n    let dict = this._itemsDict;\n    for (let i = 0, len = keys.length; i < len; i++) {\n      fn.call(thisArg, dict[keys[i]], keys[i]);\n    }\n  }\n\n  destructor() {\n    this.isDestroying = true;\n    // Destroy all child instances\n    let dict = this._itemsDict;\n    if (dict) {\n      for (let key in dict) {\n        dict[key].destructor();\n      }\n    }\n    super.destructor();\n  }\n}\n\nconst TEMP_ARRAY$1 = [null];\n\n/**\n * @typedef {object} FacadeDescriptor\n * An object describing the type and properties of a child facade to be created and managed by\n * its parent. See the detailed description in the docs for {@link Facade.js}.\n * @property {class} facade\n * @property {string|number} [key]\n */\n\n\n/**\n * Base facade class for objects that have `children`. Manages creating and destroying child\n * facade instances as needed as its `children` array changes.\n *\n * If you need to create a large number of child objects based on an array of incoming data,\n * consider using a `ListFacade` instead of a parent object with a large `children` array, since\n * that requires only a single template descriptor object instead of one for every child.\n */\nclass ParentFacade extends Facade {\n  constructor(parent) {\n    super(parent);\n\n    /**\n     * @member {FacadeDescriptor | Array<FacadeDescriptor>} children\n     * Descriptors for one or more child facades.\n     */\n    this.children = null;\n\n    this._orderedChildKeys = [];\n  }\n\n  afterUpdate() {\n    if (this.shouldUpdateChildren()) {\n      this.updateChildren(this.describeChildren());\n    }\n    super.afterUpdate();\n  }\n\n  /**\n   * Return the descriptor(s) for the actual children to be created and managed. By default\n   * this simply returns the value of the `children` property set by the parent, but you can\n   * override it to customize how the child content should be structured, for instance to wrap\n   * the `children` within a deeper structure, add in anonymous child siblings, or modify the\n   * `children` configurations.\n   * @protected\n   * @return {FacadeDescriptor | Array<FacadeDescriptor>}\n   */\n  describeChildren() {\n    return this.children\n  }\n\n  /**\n   * Override to selectively prevent traversing to child nodes on `afterUpdate`, for\n   * potential performance gain.\n   * @returns {boolean}\n   */\n  shouldUpdateChildren() {\n    return true\n  }\n\n  updateChildren(children) {\n    const oldDict = this._childrenDict || null;\n    let newDict = this._childrenDict = null;\n    const orderedChildKeys = this._orderedChildKeys;\n    orderedChildKeys.length = 0;\n\n    if (children) {\n      // Allow single child without wrapper array\n      if (!Array.isArray(children)) {\n        TEMP_ARRAY$1[0] = children;\n        children = TEMP_ARRAY$1;\n      }\n\n      for (let i = 0, len = children.length; i < len; i++) {\n        let childDesc = children[i];\n        if (!childDesc) continue //child members can be null\n        if (!newDict) {\n          newDict = this._childrenDict = Object.create(null);\n        }\n\n        // Handle child descriptors defined via a JSX->React.createElement() transforms (ReactElement objects)\n        const isJSX = isReactElement(childDesc);\n        let propsObj = isJSX ? childDesc.props : childDesc;\n        let facadeClass = isJSX ? childDesc.type : childDesc.facade;\n\n        // Find this child's key; if not specified by the author, build one from the facade class name\n        let key = childDesc.key;\n        if (!key) {\n          let j = 0;\n          do {\n            key = `auto:${facadeClass.name}:${j++}`;\n          } while (newDict[key])\n        }\n\n        // Some basic validation in dev mode\n        if (process.env.NODE_ENV !== 'production') {\n          if (typeof facadeClass !== 'function') {\n            throw new Error('All scene objects must have a \"facade\" property pointing to a class/constructor')\n          }\n        }\n        if (newDict[key]) {\n          console.warn(`Duplicate key in children: ${key}`);\n          while(newDict[key]) {\n            key += '|dupe';\n          }\n        }\n\n        // If a transition/animation is present, upgrade the class to a Animatable class on demand.\n        // NOTE: changing between animatable/non-animatable results in a full teardown/recreation\n        // of this instance *and its entire subtree*, so try to avoid that by always including the `transition`\n        // definition if the object is expected to ever need transitions, even if it's temporarily empty.\n        let transition = propsObj.transition;\n        let animation = propsObj.animation;\n        if (transition || animation || propsObj.exitAnimation) {\n          facadeClass = extendAsAnimatable(facadeClass);\n        }\n\n        // Same for pointer states\n        if (propsObj.pointerStates) {\n          facadeClass = extendAsPointerStatesAware(facadeClass);\n        }\n\n        // If we have an old instance with the same key and class, update it, otherwise instantiate a new one\n        let oldImpl = oldDict && oldDict[key];\n        let newImpl;\n        if (oldImpl && oldImpl.constructor === facadeClass) {\n          newImpl = oldImpl;\n        } else {\n          // If swapping instance need to destroy the old before creating the new, e.g. for `ref` call ordering\n          if (oldImpl) oldImpl.destructor();\n          newImpl = new facadeClass(this);\n        }\n        //always set transition/animation before any other props\n        newImpl.transition = transition;\n        newImpl.animation = animation;\n        for (let prop in propsObj) {\n          if (propsObj.hasOwnProperty(prop) && !Facade.isSpecialDescriptorProperty(prop)) {\n            newImpl[prop] = propsObj[prop];\n          }\n        }\n        newDict[key] = newImpl;\n        orderedChildKeys.push(key);\n        newImpl.afterUpdate();\n      }\n    }\n\n    // Destroy all old child instances that were not reused or replaced\n    if (oldDict) {\n      for (let key in oldDict) {\n        if (!newDict || !newDict[key]) {\n          oldDict[key].destructor();\n        }\n      }\n    }\n  }\n\n  getChildByKey(key) {\n    let dict = this._childrenDict;\n    return dict && dict[key] || null\n  }\n\n  /**\n   * Walk this facade's descendant tree, invoking a function for it and each descendant.\n   * The iteration order will match the order in which the `children` were declared. It may\n   * also include items that have been queued for removal but not yet removed, e.g. facades\n   * in the process of an `exitAnimation`.\n   * @param {Function} fn\n   * @param {Object} [thisArg]\n   */\n  traverse(fn, thisArg) {\n    fn.call(thisArg, this);\n    const keys = this._orderedChildKeys;\n    const dict = this._childrenDict;\n    for (let i = 0, len = keys.length; i < len; i++) {\n      dict[keys[i]].traverse(fn, thisArg);\n    }\n  }\n\n  /**\n   * Iterate over this facade's direct child facades, invoking a function for each.\n   * The iteration order will match the order in which the `children` were declared. It may\n   * also include items that have been queued for removal but not yet removed, e.g. facades\n   * in the process of an `exitAnimation`.\n   * @param {Function} fn\n   * @param {Object} [thisArg]\n   */\n  forEachChild(fn, thisArg) {\n    const keys = this._orderedChildKeys;\n    const dict = this._childrenDict;\n    for (let i = 0, len = keys.length; i < len; i++) {\n      fn.call(thisArg, dict[keys[i]], keys[i]);\n    }\n  }\n\n  destructor() {\n    this.isDestroying = true;\n    // Destroy all child instances\n    let dict = this._childrenDict;\n    if (dict) {\n      for (let key in dict) {\n        dict[key].destructor();\n      }\n    }\n    super.destructor();\n  }\n}\n\nconst pointerMotionEventProps = [\n  'onMouseOver',\n  'onMouseOut',\n  'onMouseMove',\n  'onDragStart',\n  'onDrag',\n  'onDragEnter',\n  'onDragOver',\n  'onDragLeave'\n];\n\nconst pointerActionEventProps = [\n  'onMouseDown',\n  'onMouseUp',\n  'onClick',\n  'onDoubleClick',\n  'onDrop',\n  'onDragEnd',\n  'onWheel'\n];\n\nconst pointerActionEventTypes = pointerActionEventProps.map(eventPropToType);\nconst pointerMotionEventTypes = pointerMotionEventProps.map(eventPropToType);\n\nconst pointerEventProps = pointerMotionEventProps.concat(pointerActionEventProps);\nconst pointerEventTypes = pointerMotionEventTypes.concat(pointerActionEventTypes);\n\nfunction eventPropToType(prop) {\n  return prop === 'onDoubleClick' ? 'dblclick' : prop.replace(/^on/, '').toLowerCase()\n}\n\n\nclass PointerEventTarget extends ParentFacade {\n  /**\n   * Determine if this PointerEventTarget should intercept pointer events:\n   * - By default only facades with a pointer event listener assigned will be counted, to prevent being blocked by unwanted objects\n   * - If an object should definitely block events from objects behind it, set `pointerEvents:true`\n   * - If an object has one of the pointer event properties but should be ignored in picking, set `pointerEvents:false`\n   */\n  interceptsPointerEvents(eventRegistry) {\n    if (this.pointerEvents === false) {\n      return false\n    }\n    if (this.pointerEvents) {\n      return true\n    }\n    for (let i = 0, len = pointerEventTypes.length; i < len; i++) {\n      if (eventRegistry.hasFacadeListenersOfType(this, pointerEventTypes[i])) {\n        return true\n      }\n    }\n  }\n}\n\n\nObject.defineProperty(PointerEventTarget.prototype, 'isPointerEventTarget', {value: true});\n\n\n// Add handlers for pointer event properties\npointerEventProps.forEach(propName => {\n  Facade.defineEventProperty(PointerEventTarget, propName, eventPropToType(propName));\n});\n\n/**\n * @class EventRegistry\n * Utility for tracking event listeners by type and target facade\n */\nfunction EventRegistry() {\n  const byEventType = Object.create(null);\n\n  this.addListenerForFacade = (facade, type, handler) => {\n    const listenersOfType = byEventType[type] || (byEventType[type] = {\n      count: 0,\n      byFacadeId: Object.create(null)\n    });\n    const facadeId = facade.$facadeId;\n    const oldHandlers = listenersOfType.byFacadeId[facadeId];\n    // No listeners for this facade yet; set handler function as single value to avoid\n    // unnecessary array creation in the common single-listener case.\n    if (!oldHandlers) {\n      listenersOfType.count++;\n      listenersOfType.byFacadeId[facadeId] = handler;\n    }\n    // Already multiple listeners; add to array if not already present\n    else if (Array.isArray(oldHandlers)) {\n      if (oldHandlers.indexOf(handler) === -1) {\n        listenersOfType.count++;\n        oldHandlers.push(handler);\n      }\n    }\n    // Second unique listener; promote to array\n    else if (oldHandlers !== handler) {\n      listenersOfType.count++;\n      listenersOfType.byFacadeId[facadeId] = [oldHandlers, handler];\n    }\n  };\n\n  this.removeListenerForFacade = (facade, type, handler) => {\n    const listenersOfType = byEventType[type];\n    const facadeId = facade.$facadeId;\n    const oldHandlers = listenersOfType && listenersOfType.byFacadeId[facadeId];\n    // Single listener; delete from map\n    if (oldHandlers === handler) {\n      listenersOfType.count--;\n      delete listenersOfType.byFacadeId[facadeId];\n    }\n    // Multiple listeners; remove from array\n    else if (Array.isArray(oldHandlers)) {\n      const idx = oldHandlers.indexOf(handler);\n      if (idx > -1) {\n        listenersOfType.count--;\n        // Delete from map if the array will be empty; we don't demote from array to single\n        // item because it can result in unneeded churn in the likely case of a different\n        // listener being added immediately after\n        if (oldHandlers.length === 1) {\n          delete listenersOfType.byFacadeId[facadeId];\n        } else {\n          oldHandlers.splice(idx, 1);\n        }\n      }\n    }\n  };\n\n  this.removeAllListenersForFacade = (facade) => {\n    const facadeId = facade.$facadeId;\n    for (let type in byEventType) {\n      let facadeListeners = byEventType[type].byFacadeId[facadeId];\n      if (facadeListeners) {\n        byEventType[type].count -= (Array.isArray(facadeListeners) ? facadeListeners.length : 1);\n        delete byEventType[type].byFacadeId[facadeId];\n      }\n    }\n  };\n\n  this.hasFacadeListenersOfType = (facade, type) => {\n    return byEventType[type] ? !!byEventType[type].byFacadeId[facade.$facadeId] : false\n  };\n\n  this.hasAnyListenersOfType = (type) => {\n    return byEventType[type] ? byEventType[type].count > 0 : false\n  };\n\n  this.findBubblingEventTarget = (targetFacade, eventType) => {\n    while (targetFacade) {\n      if (this.hasFacadeListenersOfType(targetFacade, eventType)) {\n        return targetFacade\n      }\n      targetFacade = targetFacade.parent;\n    }\n    return null\n  };\n\n  function tryCall(func, scope, arg1, arg2) {\n    try {\n      func.call(scope, arg1, arg2);\n    } catch(err) {\n      console.error(err);\n    }\n  }\n\n  this.forEachFacadeListenerOfType = (facade, type, callback, scope) => {\n    const listenersOfType = byEventType[type];\n    const facadeId = facade.$facadeId;\n    const handlers = listenersOfType && listenersOfType.byFacadeId[facadeId];\n    if (handlers) {\n      if (Array.isArray(handlers)) {\n        for (let i = 0; i < handlers.length; i++) {\n          tryCall(callback, scope, handlers[i], facadeId);\n        }\n      } else {\n        tryCall(callback, scope, handlers, facadeId);\n      }\n    }\n  };\n\n  this.forEachListenerOfType = (type, callback, scope) => {\n    const listenersOfType = byEventType[type];\n    if (listenersOfType && listenersOfType.count > 0) {\n      for (let facadeId in listenersOfType.byFacadeId) {\n        const facadeListeners = listenersOfType.byFacadeId[facadeId];\n        if (Array.isArray(facadeListeners)) {\n          for (let i = 0; i < facadeListeners.length; i++) {\n            tryCall(callback, scope, facadeListeners[i], facadeId);\n          }\n        } else {\n          tryCall(callback, scope, facadeListeners, facadeId);\n        }\n      }\n    }\n  };\n\n  this.dispatchEventOnFacade = (facade, event) => {\n    let currentTarget = facade;\n    function callHandler(handler) {\n      handler.call(currentTarget, event);\n    }\n    event.target = facade;\n    while (currentTarget && !event.propagationStopped) { //TODO should defaultPrevented mean anything here?\n      event.currentTarget = currentTarget;\n      this.forEachFacadeListenerOfType(currentTarget, event.type, callHandler, null);\n      if (event.bubbles) {\n        currentTarget = currentTarget.parent;\n      } else {\n        break\n      }\n    }\n  };\n}\n\nconst TAP_DISTANCE_THRESHOLD = 10;\nconst TAP_GESTURE_MAX_DUR = 300;\nconst TAP_DBLCLICK_MAX_DUR = 300;\nconst DEFAULT_EVENT_SOURCE = {};\n\nconst domPointerMotionEventTypes = [\n  'mousemove',\n  'mouseout',\n  'touchmove'\n];\nconst domPointerActionEventTypes = [\n  'mousedown',\n  'mouseup',\n  'click',\n  'dblclick',\n  'wheel',\n  'touchstart',\n  'touchend',\n  'touchcancel'\n];\nconst dropEventTypes = [\n  'mouseup',\n  'touchend',\n  'touchcancel'\n];\nconst pointerActionEventTypeMappings = {\n  'touchstart': 'mousedown',\n  'touchend': 'mouseup',\n  'touchcancel': 'mouseup'\n};\n\nconst touchDragPropsToNormalize = ['clientX', 'clientY', 'screenX', 'screenY', 'pageX', 'pageY'];\n\nclass SyntheticEvent {\n  constructor(nativeEvent, type, target, relatedTarget, extraProps) {\n    // Copy native event properties - TODO investigate using a Proxy\n    for (let prop in nativeEvent) {\n      // NOTE: we don't check hasOwnProperty in this loop because properties that will return\n      // false for properties that are defined by getters on inherited prototypes\n      if (typeof nativeEvent[prop] !== 'function') {\n        this[prop] = nativeEvent[prop];\n      }\n    }\n\n    // Adjust to custom params\n    this.target = target;\n    this.relatedTarget = relatedTarget;\n    this.type = type;\n    this.nativeEvent = nativeEvent;\n    assign(this, extraProps);\n\n    // normalize position properties on touch events with a single touch, to facilitate\n    // downstream handlers that expect them to look like mouse events\n    // NOTE: can't do this in _normalizePointerEvent() as these props are unwritable on native Event objects\n    if (nativeEvent.touches) {\n      let touches = isTouchEndOrCancel(nativeEvent) ? nativeEvent.changedTouches : nativeEvent.touches;\n      if (touches.length === 1) {\n        touchDragPropsToNormalize.forEach(prop => {\n          this[prop] = touches[0][prop];\n        });\n      }\n    }\n  }\n\n  preventDefault() {\n    this.defaultPrevented = true;\n    this.nativeEvent.preventDefault();\n  }\n\n  stopPropagation() {\n    this.propagationStopped = true;\n    this.nativeEvent.stopPropagation();\n  }\n}\n\nfunction isTouchEndOrCancel(e) {\n  return e.type === 'touchend' || e.type === 'touchcancel'\n}\n\nfunction killEvent(e) {\n  e.stopPropagation();\n  e.preventDefault();\n}\n\n\nclass WorldBaseFacade extends ParentFacade {\n  constructor(element) {\n    super(null);\n\n    this.width = this.height = 1;\n    this._element = element;\n    this._htmlOverlays = Object.create(null);\n\n    // Bind events\n    this.eventRegistry = new EventRegistry();\n    this._onPointerMotionEvent = this._onPointerMotionEvent.bind(this);\n    this._onPointerActionEvent = this._onPointerActionEvent.bind(this);\n    this._onDropEvent = this._onDropEvent.bind(this);\n    this._togglePointerListeners(true);\n  }\n\n  afterUpdate() {\n    this._queueRender();\n    super.afterUpdate();\n  }\n\n  onNotifyWorld(source, message, data) {\n    let handler = this._notifyWorldHandlers[message];\n    if (handler) {\n      handler.call(this, source, data);\n    }\n  }\n\n  _isContinuousRender() {\n    return this.continuousRender\n  }\n\n  /**\n   * @property {{requestAnimationFrame, cancelAnimationFrame}} renderingScheduler\n   * The object holding `requestAnimationFrame` and `cancelAnimationFrame` scheduling\n   * functions. Defaults to `window` but can be switched to another implementation, e.g.\n   * to use an XRSession's custom scheduler.\n   */\n  set renderingScheduler(scheduler) {\n    scheduler = scheduler || window;\n    if (scheduler !== this.renderingScheduler) {\n      const activeHandle = this._nextFrameTimer;\n      if (activeHandle) {\n        this.renderingScheduler.cancelAnimationFrame(activeHandle);\n        this._nextFrameTimer = null;\n      }\n      this._renderingScheduler = scheduler;\n    }\n  }\n  get renderingScheduler() {\n    return this._renderingScheduler || window\n  }\n\n  // Schedule a render pass on the next frame\n  _queueRender() {\n    if (!this._nextFrameTimer) {\n      const handler = this._nextFrameHandler || (this._nextFrameHandler = (...args) => {\n        let {onStatsUpdate, onBeforeRender, onAfterRender} = this;\n        let start = onStatsUpdate && Date.now();\n\n        if (onBeforeRender) onBeforeRender(this);\n\n        this.doRender(...args);\n\n        if (onStatsUpdate) {\n          let now = Date.now();\n          onStatsUpdate({\n            'Render CPU Time (ms)': now - start,\n            'Time Between Frames (ms)': this._lastFrameTime ? now - this._lastFrameTime : '?',\n            'FPS': this._lastFrameTime ? Math.round(1000 / (now - this._lastFrameTime)) : '?'\n          });\n          this._lastFrameTime = now;\n        }\n\n        this._doRenderHtmlItems();\n\n        if (onAfterRender) onAfterRender(this);\n\n        this._nextFrameTimer = null;\n\n        if (this._isContinuousRender()) {\n          this._queueRender();\n        }\n      });\n      this._nextFrameTimer = this.renderingScheduler.requestAnimationFrame(handler);\n    }\n  }\n\n  /**\n   * @abstract\n   */\n  doRender(/*...frameArgs*/) {\n  }\n\n  /**\n   * @abstract\n   */\n  getFacadeUserSpaceXYZ(/*facade*/) {\n  }\n\n  _doRenderHtmlItems() {\n    if (this.renderHtmlItems) {\n      let htmlItemsData = [];\n      let overlayFacades = this._htmlOverlays;\n      for (let key in overlayFacades) {\n        let facade = overlayFacades[key];\n        let data = this.getFacadeUserSpaceXYZ(facade);\n        if (data.z >= 0) { //Ignore objects with negative z (behind the camera)\n          data.key = facade.$facadeId;\n          data.html = facade.html;\n          data.exact = facade.exact;\n          htmlItemsData.push(data);\n        }\n      }\n      this.renderHtmlItems(htmlItemsData);\n    }\n  }\n\n  /**\n   * Hook allowing world implementations to pre-normalize native pointer events, for instance\n   * computing derived worldspace properties that are simpler for downstream code to use.\n   * @param {Event} e\n   * @protected\n   */\n  _normalizePointerEvent(e) {\n  }\n\n  /**\n   * Entry point for handling events related to pointer motion (e.g. mouse or touch movement).\n   * This will be called by the code that wraps this World facade to bridge native DOM events\n   * into the Troika world.\n   * @param {Event} e\n   */\n  _onPointerMotionEvent(e) {\n    this._normalizePointerEvent(e);\n    const eventState = this._getPointerEventState(e);\n\n    if (pointerMotionEventTypes.some(this.eventRegistry.hasAnyListenersOfType)) {\n      const hoverInfo = (e.type === 'mouseout' || isTouchEndOrCancel(e)) ? null : this._findHoverTarget(e);\n      let lastHovered = eventState.hoveredFacade;\n      let hovered = eventState.hoveredFacade = hoverInfo && hoverInfo.facade;\n\n      let dragInfo = eventState.dragInfo;\n      if (dragInfo) {\n        if (!dragInfo.dragStartFired) {\n          this._firePointerEvent('dragstart', dragInfo.dragStartEvent, dragInfo.draggedFacade, null, hoverInfo);\n          dragInfo.dragStartFired = true;\n        }\n        this._firePointerEvent('drag', e, dragInfo.draggedFacade, null, hoverInfo);\n      }\n\n      if (hovered !== lastHovered) {\n        if (lastHovered) {\n          this._firePointerEvent('mouseout', e, lastHovered, hovered, hoverInfo);\n          if (dragInfo) {\n            this._firePointerEvent('dragleave', e, lastHovered, hovered, hoverInfo);\n          }\n        }\n        if (hovered) {\n          this._firePointerEvent('mouseover', e, hovered, lastHovered, hoverInfo);\n          if (dragInfo) {\n            this._firePointerEvent('dragenter', e, hovered, lastHovered, hoverInfo);\n          }\n        }\n      }\n      if (hovered) {\n        this._firePointerEvent('mousemove', e, hovered, null, hoverInfo);\n        if (dragInfo) {\n          this._firePointerEvent('dragover', e, hovered, null, hoverInfo);\n        }\n      }\n    }\n\n    // Cancel tap gesture if moving past threshold\n    let tapInfo = eventState.tapInfo;\n    if (tapInfo && e.type === 'touchmove') {\n      let touch = e.changedTouches[0];\n      if (touch && Math.sqrt(Math.pow(touch.clientX - tapInfo.x, 2) + Math.pow(touch.clientY - tapInfo.y, 2)) > TAP_DISTANCE_THRESHOLD) {\n        eventState.tapInfo = null;\n      }\n    }\n  }\n\n  /**\n   * Entry point for handling events related to pointer motion (e.g. mouse clicks or touch taps).\n   * This will be called by the code that wraps this World facade to bridge native DOM events\n   * into the Troika world.\n   * @param {Event} e\n   */\n  _onPointerActionEvent(e) {\n    this._normalizePointerEvent(e);\n\n    // Handle drop events, in the case they weren't captured by the listeners on `document`\n    // e.g. synthetic events dispatched internally\n    if (dropEventTypes.indexOf(e.type) > -1) {\n      this._onDropEvent(e);\n    }\n\n    // Map touch start to mouseover, and disable touch-hold context menu\n    if (e.type === 'touchstart') {\n      if (e.touches.length === 1) {\n        this._onPointerMotionEvent(e);\n      }\n      this._enableContextMenu(false);\n    }\n\n    const eventRegistry = this.eventRegistry;\n    if (eventRegistry.hasAnyListenersOfType('dragstart') || pointerActionEventTypes.some(eventRegistry.hasAnyListenersOfType)) {\n      let hoverInfo = this._findHoverTarget(e);\n      let facade = hoverInfo && hoverInfo.facade;\n      if (facade) {\n        const eventState = this._getPointerEventState(e);\n        this._firePointerEvent(pointerActionEventTypeMappings[e.type] || e.type, e, facade, null, hoverInfo);\n\n        // touchstart/touchend could be start/end of a tap - map to click\n        if (eventRegistry.findBubblingEventTarget(facade, 'click') || eventRegistry.findBubblingEventTarget(facade, 'dblclick')) {\n          let tapInfo = eventState.tapInfo;\n          if (e.type === 'touchstart' && e.touches.length === 1) {\n            eventState.tapInfo = {\n              facade: facade,\n              x: e.touches[0].clientX,\n              y: e.touches[0].clientY,\n              startTime: Date.now(),\n              isDblClick: tapInfo && Date.now() - tapInfo.startTime < TAP_DBLCLICK_MAX_DUR\n            };\n          } else {\n            if (\n              tapInfo && tapInfo.facade === facade && e.type === 'touchend' &&\n              e.touches.length === 0 && e.changedTouches.length === 1 &&\n              Date.now() - tapInfo.startTime < TAP_GESTURE_MAX_DUR\n            ) {\n              this._firePointerEvent('click', e, facade, null, hoverInfo);\n              if (tapInfo.isDblClick) {\n                this._firePointerEvent('dblclick', e, facade, null, hoverInfo);\n              }\n            }\n          }\n        }\n\n        // mousedown/touchstart could be prepping for drag gesture\n        if (e.type === 'mousedown' || e.type === 'touchstart') {\n          const dragger = eventRegistry.findBubblingEventTarget(facade, 'dragstart');\n          if (dragger) {\n            let dragStartEvent = new SyntheticEvent(e, 'dragstart', dragger, null, {intersection: hoverInfo});\n            eventState.dragInfo = {\n              draggedFacade: dragger,\n              dragStartFired: false,\n              dragStartEvent: dragStartEvent\n            };\n            // handle release outside canvas\n            this._toggleDropListeners(true);\n          }\n        }\n      }\n      e.preventDefault(); //prevent e.g. touch scroll\n    }\n\n    // Map touch end to mouseout\n    if (isTouchEndOrCancel(e)) {\n      if (e.changedTouches.length === 1) {\n        this._onPointerMotionEvent(e);\n      }\n      this._enableContextMenu(true);\n    }\n  }\n\n  _onDropEvent(e) {\n    const eventState = this._getPointerEventState(e);\n    let dragInfo = eventState.dragInfo;\n    if (dragInfo) {\n      this._normalizePointerEvent(e);\n      let hoverInfo = this._findHoverTarget(e);\n      let targetFacade = hoverInfo && hoverInfo.facade;\n      if (targetFacade) {\n        this._firePointerEvent('drop', e, targetFacade, null, hoverInfo);\n      }\n      this._firePointerEvent('dragend', e, dragInfo.draggedFacade, null, hoverInfo);\n      this._toggleDropListeners(false);\n      eventState.dragInfo = null;\n    }\n  }\n\n  _firePointerEvent(eventType, originalEvent, targetFacade, relatedTargetFacade, intersection) {\n    let newEvent = (originalEvent instanceof SyntheticEvent) ?\n      originalEvent :\n      new SyntheticEvent(\n        originalEvent,\n        eventType,\n        targetFacade,\n        relatedTargetFacade,\n        {\n          bubbles: true,\n          intersection\n        }\n      );\n    // Dispatch with bubbling\n    this.eventRegistry.dispatchEventOnFacade(targetFacade, newEvent);\n  }\n\n  _getPointerEventState(e) {\n    const states = this._pointerEventStates || (this._pointerEventStates = new WeakMap());\n    const eventSource = e.eventSource || DEFAULT_EVENT_SOURCE;\n    let eventState = states.get(eventSource);\n    if (!eventState) {\n      states.set(eventSource, eventState = {});\n    }\n    return eventState\n  }\n\n  _toggleDropListeners(on) {\n    dropEventTypes.forEach(type => {\n      document[(on ? 'add' : 'remove') + 'EventListener'](type, this._onDropEvent, true);\n    });\n  }\n\n  _togglePointerListeners(on) {\n    let canvas = this._element;\n    if (canvas && on !== this._pointerListenersAttached) {\n      let method = (on ? 'add' : 'remove') + 'EventListener';\n      domPointerMotionEventTypes.forEach(type => {\n        canvas[method](type, this._onPointerMotionEvent, false);\n      });\n      domPointerActionEventTypes.forEach(type => {\n        canvas[method](type, this._onPointerActionEvent, false);\n      });\n      this._pointerListenersAttached = on;\n    }\n  }\n\n  _enableContextMenu(enable) {\n    let canvas = this._element;\n    if (canvas) {\n      canvas[(enable ? 'remove' : 'add') + 'EventListener']('contextmenu', killEvent, true);\n    }\n  }\n\n  /**\n   * @abstract\n   * Given a pointer-related Event, find and return all facade objects that are intersected\n   * by that event. If any hits are found, this should return an array of objects that contain\n   * at least `facade` and `distance` properties. Any additional properties will be exposed to\n   * event listeners on the synthetic event object as an `intersection` property.\n   * @param {Event} e\n   * @param {Function} [filterFn]\n   * @return {Array<{facade, distance, ?distanceBias, ...}>|null}\n   */\n  getFacadesAtEvent(e, filterFn) {\n    throw new Error('getFacadesAtEvent: no impl')\n  }\n\n  _findHoverTarget(e) {\n    //only handle single touches for now\n    if (e.touches && e.touches.length > 1) {\n      return null\n    }\n\n    let allHits = this.getFacadesAtEvent(e, facade =>\n      facade.isPointerEventTarget && facade.interceptsPointerEvents(this.eventRegistry)\n    );\n    if (allHits) {\n      // Find the closest by comparing distance, or distanceBias if distance is the same\n      let closestHit = allHits[0];\n      for (let i = 1; i < allHits.length; i++) {\n        if (allHits[i].distance < closestHit.distance ||\n          (allHits[i].distance === closestHit.distance && (allHits[i].distanceBias || 0) < (closestHit.distanceBias || 0))\n        ) {\n          closestHit = allHits[i];\n        }\n      }\n      return closestHit\n    }\n\n    return null\n  }\n\n  destructor() {\n    if (this._nextFrameTimer) {\n      this.renderingScheduler.cancelAnimationFrame(this._nextFrameTimer);\n    }\n    this._togglePointerListeners(false);\n    this._toggleDropListeners(false);\n    super.destructor();\n  }\n\n}\n\nObject.defineProperty(WorldBaseFacade.prototype, 'isWorld', {value: true});\n\nWorldBaseFacade.prototype._notifyWorldHandlers = {\n  needsRender() {\n    this._queueRender();\n  },\n  addEventListener(source, data) {\n    this.eventRegistry.addListenerForFacade(source, data.type, data.handler);\n  },\n  removeEventListener(source, data) {\n    this.eventRegistry.removeListenerForFacade(source, data.type, data.handler);\n  },\n  removeAllEventListeners(source) {\n    this.eventRegistry.removeAllListenersForFacade(source);\n  },\n  dispatchEvent(source, event) {\n    if (!(event instanceof SyntheticEvent)) {\n      event = new SyntheticEvent(event, event.type, event.target, event.relatedTarget);\n    }\n    this.eventRegistry.dispatchEventOnFacade(source, event);\n  },\n  addHtmlOverlay(source) {\n    this._htmlOverlays[source.$facadeId] = source;\n  },\n  removeHtmlOverlay(source) {\n    delete this._htmlOverlays[source.$facadeId];\n  },\n  statsUpdate(source, data) {\n    let onStatsUpdate = this.onStatsUpdate;\n    if (onStatsUpdate) onStatsUpdate(data);\n  }\n};\n\nconst CT_STYLES = {\n  position: 'absolute',\n  top: 0,\n  right: 0,\n  bottom: 0,\n  left: 0,\n  pointerEvents: 'none',\n  transformStyle: 'preserve-3d'\n};\n\nclass HtmlOverlayContent extends React.Component {\n  shouldComponentUpdate (newProps) {\n    return (\n      newProps.html !== this.props.html ||\n      (newProps.html.props && newProps.html.props.shouldUpdateOnMove) === true\n    )\n  }\n\n  render () {\n    let html = this.props.html;\n    return typeof html === 'string'\n      ? React.createElement('span', null, html)\n      : React.cloneElement(html)\n  }\n}\n\nHtmlOverlayContent.displayName = 'Canvas3D.HtmlOverlayContent';\nHtmlOverlayContent.propTypes = {\n  html: T.node\n};\n\nclass HtmlOverlay extends React.Component {\n  constructor (props) {\n    super(props);\n    this.setItems = this.setItems.bind(this);\n    this.state = {\n      items: null\n    };\n  }\n\n  shouldComponentUpdate (newProps, newState) {\n    let oldState = this.state;\n    return (\n      (newState.items && newState.items.length) ||\n      (oldState.items && oldState.items.length)\n    )\n  }\n\n  setItems (items) {\n    let lastItems = this.state.items;\n    if ((items && items.length) || (lastItems && lastItems.length)) {\n      this.setState({ items: items || null });\n    }\n  }\n\n  render () {\n    let items = this.state.items;\n    let round = Math.round;\n    return items && items.length\n      ? React.createElement(\n        'div',\n        {\n          className: 'troika_html_overlay',\n          style: CT_STYLES\n        },\n        items.map(({ key, html, x, y, z, exact }) => {\n          if (!exact) {\n            x = round(x);\n            y = round(y);\n          }\n          return React.createElement(\n            'div',\n            {\n              key,\n              style: {\n                position: 'absolute',\n                transform: `translate3d(${x}px, ${y}px, ${-z}px)`\n              }\n            },\n            React.createElement(HtmlOverlayContent, {html})\n          )\n        })\n      )\n      : null\n  }\n}\n\nHtmlOverlay.displayName = 'Canvas3D.HtmlOverlay';\n\nconst style = {\n  position: 'absolute',\n  top: 0,\n  right: 0,\n  background: 'rgba(0,0,0,.5)',\n  font: '11px sans-serif',\n  padding: 10\n};\n\nclass Stats extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {stats: {}};\n  }\n\n  setStats(stats) {\n    this.setState({stats});\n  }\n\n  render() {\n    let stats = this.state.stats;\n    return (\n      React.createElement(\n        'div',\n        {style},\n        Object.keys(stats).sort().map(key =>\n          React.createElement('div', {key}, `${ key }: ${ stats[key] }`)\n        )\n      )\n    )\n  }\n}\n\nconst defaultCanvasStyle = {width: '100%', height: '100%'};\n\n\nclass CanvasBase extends React.Component {\n  constructor(props) {\n    super(props);\n    this._stats = {};\n    this.updateStats = this.updateStats.bind(this);\n    this.renderHtmlItems = this.renderHtmlItems.bind(this);\n    this._bindHtmlOverlayRef = this._bindHtmlOverlayRef.bind(this);\n    this._bindCanvasRef = this._bindCanvasRef.bind(this);\n    this._bindStatsRef = this._bindStatsRef.bind(this);\n  }\n\n  componentDidUpdate() {\n    this.updateWorld();\n  }\n\n  initWorld(canvas) {\n    const world = new this.props.worldFacade(canvas);\n    world.renderHtmlItems = this.renderHtmlItems;\n    return world\n  }\n\n  updateWorld() {\n    const world = this._world;\n    if (world) {\n      const {props} = this;\n      let useStats = props.stats;\n      let start = useStats && Date.now();\n\n      world.width = props.width;\n      world.height = props.height;\n      world.pixelRatio = props.pixelRatio;\n      world.continuousRender = props.continuousRender;\n      world.onStatsUpdate = useStats ? this.updateStats : null;\n      assign(world, props.worldProps);\n      world.afterUpdate();\n\n      if (useStats) {\n        this.updateStats({'Last World Update (ms)': Date.now() - start});\n      }\n    }\n  }\n\n  destroyWorld() {\n    //just to see it burn\n    if (this._world) {\n      this._world.destructor();\n      delete this._world;\n    }\n    clearTimeout(this._statsDelay);\n  }\n\n  renderHtmlItems(items) {\n    if (this._htmlOverlayRef) {\n      this._htmlOverlayRef.setItems(items);\n    }\n  }\n\n  updateStats(stats) {\n    this._stats = assign({}, this._stats, stats);\n\n    if (!this._statsDelay) {\n      this._statsDelay = setTimeout(() => {\n        this._statsDelay = null;\n        let ref = this._statsRef;\n        if (ref) {\n          ref.setStats(this._stats);\n        }\n      }, 250);\n    }\n  }\n\n  _bindHtmlOverlayRef(cmp) {\n    this._htmlOverlayRef = cmp;\n  }\n\n  _bindCanvasRef(canvas) {\n    if (canvas) {\n      try {\n        this._world = this.initWorld(canvas);\n        this.updateWorld();\n      } catch (e) {\n        console.warn(`Troika.${this.constructor.displayName}: world init failed, using fallback content.`, e);\n        this._failedWorldInit = true;\n        this._world = null;\n        this.forceUpdate();\n      }\n    } else {\n      this.destroyWorld();\n    }\n\n    // Call external ref callback\n    const cb = this.props.onCanvasRef;\n    if (cb) cb(canvas);\n  }\n\n  _bindStatsRef(ref) {\n    this._statsRef = ref;\n  }\n\n  render() {\n    let { props } = this;\n    return (\n      React.createElement(\n        'div',\n        {\n          className: `troika ${props.className || ''}`,\n          style: {\n            position: 'relative',\n            overflow: 'hidden',\n            width: props.width,\n            height: props.height,\n            cursor: props.cursor,\n            userSelect: 'none'\n          }\n        },\n        this._failedWorldInit ? this.props.children : React.createElement(\n          'canvas',\n          {\n            className: \"troika_canvas\",\n            ref: this._bindCanvasRef,\n            style: props.canvasStyle || defaultCanvasStyle\n          }\n        ),\n        React.createElement(HtmlOverlay, {ref: this._bindHtmlOverlayRef}),\n        props.stats ? React.createElement(Stats, {ref: this._bindStatsRef}) : null\n      )\n    )\n  }\n}\n\nCanvasBase.commonPropTypes = {\n  width: T.number.isRequired,\n  height: T.number.isRequired,\n  pixelRatio: T.number,\n  worldFacade: T.func,\n  worldProps: T.object,\n  canvasStyle: T.object,\n  className: T.string,\n  continuousRender: T.bool,\n  onCanvasRef: T.func,\n  stats: T.bool,\n  cursor: T.string\n};\n\nexport { Facade, List as ListFacade, ParentFacade, PointerEventTarget, CanvasBase as ReactCanvasBase, WorldBaseFacade, utils };\n", "import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInstancedBufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3,\n} from 'three';\n\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\n\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\n\n\t}\n\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\n\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\n\n\t}\n\n\tfunction getAttributeArray( attribute ) {\n\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\n\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\n\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\n\n\t\t\t\tif ( attribute.itemSize > 2 ) {\n\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn dstArray;\n\n\t\t}\n\n\t\tif ( attribute.array instanceof Float32Array ) {\n\n\t\t\treturn attribute.array;\n\n\t\t}\n\n\t\treturn new Float32Array( attribute.array );\n\n\t}\n\n\t// MikkTSpace algorithm requires non-indexed input.\n\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\n\t// Compute vertex tangents.\n\n\tconst tangents = MikkTSpace.generateTangents(\n\n\t\tgetAttributeArray( _geometry.attributes.position ),\n\t\tgetAttributeArray( _geometry.attributes.normal ),\n\t\tgetAttributeArray( _geometry.attributes.uv )\n\n\t);\n\n\t// Texture coordinate convention of glTF differs from the apparent\n\t// default of the MikkTSpace library; .w component must be flipped.\n\n\tif ( negateSign ) {\n\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\n\n\t\t\ttangents[ i ] *= - 1;\n\n\t\t}\n\n\t}\n\n\t//\n\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\n\n\tif ( geometry !== _geometry ) {\n\n\t\tgeometry.copy( _geometry );\n\n\t}\n\n\treturn geometry;\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet gpuType = - 1;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\n\t\tif ( gpuType !== attribute.gpuType ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.count * itemSize;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tconst result = new BufferAttribute( array, itemSize, normalized );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconst tupleOffset = offset / itemSize;\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\n\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\n\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tarray.set( attribute.array, offset );\n\n\t\t}\n\n\t\toffset += attribute.count * itemSize;\n\n\t}\n\n\tif ( gpuType !== undefined ) {\n\n\t\tresult.gpuType = gpuType;\n\n\t}\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferAttribute}\n * @return {BufferAttribute}\n */\nexport function deepCloneAttribute( attribute ) {\n\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\n\n\t\treturn deinterleaveAttribute( attribute );\n\n\t}\n\n\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\treturn new InstancedBufferAttribute().copy( attribute );\n\n\t}\n\n\treturn new BufferAttribute().copy( attribute );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n// returns a new, non-interleaved version of the provided attribute\nexport function deinterleaveAttribute( attribute ) {\n\n\tconst cons = attribute.data.array.constructor;\n\tconst count = attribute.count;\n\tconst itemSize = attribute.itemSize;\n\tconst normalized = attribute.normalized;\n\n\tconst array = new cons( count * itemSize );\n\tlet newAttribute;\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\n\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\n\n\t} else {\n\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t}\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\n\n\t\tif ( itemSize >= 2 ) {\n\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 3 ) {\n\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\n\n\t\t}\n\n\t\tif ( itemSize >= 4 ) {\n\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\n\n\t\t}\n\n\t}\n\n\treturn newAttribute;\n\n}\n\n// deinterleaves all attributes on the geometry\nexport function deinterleaveGeometry( geometry ) {\n\n\tconst attributes = geometry.attributes;\n\tconst morphTargets = geometry.morphTargets;\n\tconst attrMap = new Map();\n\n\tfor ( const key in attributes ) {\n\n\t\tconst attr = attributes[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tattributes[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in morphTargets ) {\n\n\t\tconst attr = morphTargets[ key ];\n\t\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\t\tif ( ! attrMap.has( attr ) ) {\n\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\n\n\t\t\t}\n\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst tmpAttributes = {};\n\tconst tmpMorphAttributes = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\t// Initialize the arrays, allocating space conservatively. Extra\n\t// space will be trimmed in the last step.\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst attr = geometry.attributes[ name ];\n\n\t\ttmpAttributes[ name ] = new BufferAttribute(\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\n\t\t\tattr.itemSize,\n\t\t\tattr.normalized\n\t\t);\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\ttmpMorphAttributes[ name ] = new BufferAttribute(\n\t\t\t\tnew morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize ),\n\t\t\t\tmorphAttr.itemSize,\n\t\t\t\tmorphAttr.normalized\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst halfTolerance = tolerance * 0.5;\n\tconst exponent = Math.log10( 1 / tolerance );\n\tconst hashMultiplier = Math.pow( 10, exponent );\n\tconst hashAdditive = halfTolerance * hashMultiplier;\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the temporary attributes\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = tmpAttributes[ name ];\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tconst setterFunc = setters[ k ];\n\t\t\t\t\tnewarray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// generate result BufferGeometry\n\tconst result = geometry.clone();\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst tmpAttribute = tmpAttributes[ name ];\n\n\t\tresult.setAttribute( name, new BufferAttribute(\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\n\t\t\ttmpAttribute.itemSize,\n\t\t\ttmpAttribute.normalized,\n\t\t) );\n\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\n\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\n\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\n\n\t\t\tresult.morphAttributes[ name ][ j ] = new BufferAttribute(\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\n\t\t\t\ttmpMorphAttribute.itemSize,\n\t\t\t\ttmpMorphAttribute.normalized,\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.applyBoneTransform( a, _vA );\n\t\t\tobject.applyBoneTransform( b, _vB );\n\t\t\tobject.applyBoneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\nfunction mergeGroups( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\n\t\treturn geometry;\n\n\t}\n\n\tlet groups = geometry.groups;\n\n\t// sort groups by material index\n\n\tgroups = groups.sort( ( a, b ) => {\n\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\n\n\t\treturn a.start - b.start;\n\n\t} );\n\n\t// create index for non-indexed geometries\n\n\tif ( geometry.getIndex() === null ) {\n\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\n\t\tconst indices = [];\n\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\n\n\t\t\tindices.push( i, i + 1, i + 2 );\n\n\t\t}\n\n\t\tgeometry.setIndex( indices );\n\n\t}\n\n\t// sort index\n\n\tconst index = geometry.getIndex();\n\n\tconst newIndices = [];\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst groupStart = group.start;\n\t\tconst groupLength = groupStart + group.count;\n\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\n\n\t\t\tnewIndices.push( index.getX( j ) );\n\n\t\t}\n\n\t}\n\n\tgeometry.dispose(); // Required to force buffer recreation\n\tgeometry.setIndex( newIndices );\n\n\t// update groups indices\n\n\tlet start = 0;\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tgroup.start = start;\n\t\tstart += group.count;\n\n\t}\n\n\t// merge groups\n\n\tlet currentGroup = groups[ 0 ];\n\n\tgeometry.groups = [ currentGroup ];\n\n\tfor ( let i = 1; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\n\n\t\t\tcurrentGroup.count += group.count;\n\n\t\t} else {\n\n\t\t\tcurrentGroup = group;\n\t\t\tgeometry.groups.push( currentGroup );\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n}\n\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * @param {BufferGeometry} geometry\n * @param {number} [creaseAngle]\n * @return {BufferGeometry}\n */\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\n\n\tconst creaseDot = Math.cos( creaseAngle );\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\n\t// reusable vectors\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\n\tconst tempVec1 = new Vector3();\n\tconst tempVec2 = new Vector3();\n\tconst tempNorm = new Vector3();\n\tconst tempNorm2 = new Vector3();\n\n\t// hashes a vector\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\t\treturn `${x},${y},${z}`;\n\n\t}\n\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\n\t// and returns the original geometry\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n\tconst posAttr = resultGeometry.attributes.position;\n\tconst vertexMap = {};\n\n\t// find all the normals shared by commonly located vertices\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\t// add the normal to the map for all vertices\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tif ( ! ( hash in vertexMap ) ) {\n\n\t\t\t\tvertexMap[ hash ] = [];\n\n\t\t\t}\n\n\t\t\tvertexMap[ hash ].push( normal );\n\n\t\t}\n\n\t}\n\n\t// average normals from all vertices that share a common location if they are within the\n\t// provided crease threshold\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\n\n\t\t// get the face normal for this vertex\n\t\tconst i3 = 3 * i;\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\n\n\t\ttempVec1.subVectors( c, b );\n\t\ttempVec2.subVectors( a, b );\n\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\n\n\t\t// average all normals that meet the threshold and set the normal value\n\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\tconst vert = verts[ n ];\n\t\t\tconst hash = hashVertex( vert );\n\t\t\tconst otherNormals = vertexMap[ hash ];\n\t\t\ttempNorm2.set( 0, 0, 0 );\n\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\n\n\t\t\t\tconst otherNorm = otherNormals[ k ];\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\n\n\t\t\t\t\ttempNorm2.add( otherNorm );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttempNorm2.normalize();\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\n\n\t\t}\n\n\t}\n\n\tresultGeometry.setAttribute( 'normal', normAttr );\n\treturn resultGeometry;\n\n}\n\nexport {\n\tcomputeMikkTSpaceTangents,\n\tmergeGeometries,\n\tmergeAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n\tmergeGroups,\n\ttoCreasedNormals\n};\n", "import {\n\tAnimationClip,\n\tBone,\n\tBox3,\n\tBufferAttribute,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tColorManagement,\n\tDirectionalLight,\n\tDoubleSide,\n\tFileLoader,\n\tFrontSide,\n\tGroup,\n\tImageBitmapLoader,\n\tInstancedMesh,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tInterpolant,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tLine,\n\tLineBasicMaterial,\n\tLineLoop,\n\tLineSegments,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tLinearSRGBColorSpace,\n\tLoader,\n\tLoaderUtils,\n\tMaterial,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshPhysicalMaterial,\n\tMeshStandardMaterial,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tNumberKeyframeTrack,\n\tObject3D,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tPoints,\n\tPointsMaterial,\n\tPropertyBinding,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tSkeleton,\n\tSkinnedMesh,\n\tSphere,\n\tSpotLight,\n\tTexture,\n\tTextureLoader,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack,\n\tSRGBColorSpace,\n\tInstancedBufferAttribute\n} from 'three';\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils.js';\n\nclass GLTFLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\tthis.dracoLoader = null;\n\t\tthis.ktx2Loader = null;\n\t\tthis.meshoptDecoder = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsDispersionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureWebPExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFTextureAVIFExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMaterialsBumpExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFLightsExtension( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshoptCompression( parser );\n\n\t\t} );\n\n\t\tthis.register( function ( parser ) {\n\n\t\t\treturn new GLTFMeshGpuInstancing( parser );\n\n\t\t} );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tlet resourcePath;\n\n\t\tif ( this.resourcePath !== '' ) {\n\n\t\t\tresourcePath = this.resourcePath;\n\n\t\t} else if ( this.path !== '' ) {\n\n\t\t\t// If a base path is set, resources will be relative paths from that plus the relative path of the gltf file\n\t\t\t// Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'\n\t\t\t// resourcePath = 'https://my-cnd-server.com/assets/models/'\n\t\t\t// referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'\n\t\t\t// referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'\n\t\t\tconst relativeUrl = LoaderUtils.extractUrlBase( url );\n\t\t\tresourcePath = LoaderUtils.resolveURL( relativeUrl, this.path );\n\n\t\t} else {\n\n\t\t\tresourcePath = LoaderUtils.extractUrlBase( url );\n\n\t\t}\n\n\t\t// Tells the LoadingManager to track an extra item, which resolves after\n\t\t// the model is fully loaded. This means the count of items loaded will\n\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\n\t\tthis.manager.itemStart( url );\n\n\t\tconst _onError = function ( e ) {\n\n\t\t\tif ( onError ) {\n\n\t\t\t\tonError( e );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( e );\n\n\t\t\t}\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t};\n\n\t\tconst loader = new FileLoader( this.manager );\n\n\t\tloader.setPath( this.path );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\n\t\tloader.load( url, function ( data ) {\n\n\t\t\ttry {\n\n\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\n\n\t\t\t\t\tonLoad( gltf );\n\n\t\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t\t}, _onError );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\t_onError( e );\n\n\t\t\t}\n\n\t\t}, onProgress, _onError );\n\n\t}\n\n\tsetDRACOLoader( dracoLoader ) {\n\n\t\tthis.dracoLoader = dracoLoader;\n\t\treturn this;\n\n\t}\n\n\tsetDDSLoader() {\n\n\t\tthrow new Error(\n\n\t\t\t'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\n\n\t\t);\n\n\t}\n\n\tsetKTX2Loader( ktx2Loader ) {\n\n\t\tthis.ktx2Loader = ktx2Loader;\n\t\treturn this;\n\n\t}\n\n\tsetMeshoptDecoder( meshoptDecoder ) {\n\n\t\tthis.meshoptDecoder = meshoptDecoder;\n\t\treturn this;\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tparse( data, path, onLoad, onError ) {\n\n\t\tlet json;\n\t\tconst extensions = {};\n\t\tconst plugins = {};\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tif ( typeof data === 'string' ) {\n\n\t\t\tjson = JSON.parse( data );\n\n\t\t} else if ( data instanceof ArrayBuffer ) {\n\n\t\t\tconst magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );\n\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tjson = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );\n\n\t\t\t} else {\n\n\t\t\t\tjson = JSON.parse( textDecoder.decode( data ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tjson = data;\n\n\t\t}\n\n\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst parser = new GLTFParser( json, {\n\n\t\t\tpath: path || this.resourcePath || '',\n\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\trequestHeader: this.requestHeader,\n\t\t\tmanager: this.manager,\n\t\t\tktx2Loader: this.ktx2Loader,\n\t\t\tmeshoptDecoder: this.meshoptDecoder\n\n\t\t} );\n\n\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\n\n\t\tfor ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {\n\n\t\t\tconst plugin = this.pluginCallbacks[ i ]( parser );\n\n\t\t\tif ( ! plugin.name ) console.error( 'THREE.GLTFLoader: Invalid plugin found: missing name' );\n\n\t\t\tplugins[ plugin.name ] = plugin;\n\n\t\t\t// Workaround to avoid determining as unknown extension\n\t\t\t// in addUnknownExtensionsToUserData().\n\t\t\t// Remove this workaround if we move all the existing\n\t\t\t// extension handlers to plugin system\n\t\t\textensions[ plugin.name ] = true;\n\n\t\t}\n\n\t\tif ( json.extensionsUsed ) {\n\n\t\t\tfor ( let i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\tconst extensionName = json.extensionsUsed[ i ];\n\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tparser.setExtensions( extensions );\n\t\tparser.setPlugins( plugins );\n\t\tparser.parse( onLoad, onError );\n\n\t}\n\n\tparseAsync( data, path ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( data, path, resolve, reject );\n\n\t\t} );\n\n\t}\n\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n\n\tlet objects = {};\n\n\treturn\t{\n\n\t\tget: function ( key ) {\n\n\t\t\treturn objects[ key ];\n\n\t\t},\n\n\t\tadd: function ( key, object ) {\n\n\t\t\tobjects[ key ] = object;\n\n\t\t},\n\n\t\tremove: function ( key ) {\n\n\t\t\tdelete objects[ key ];\n\n\t\t},\n\n\t\tremoveAll: function () {\n\n\t\t\tobjects = {};\n\n\t\t}\n\n\t};\n\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n\tKHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',\n\tKHR_MATERIALS_IOR: 'KHR_materials_ior',\n\tKHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n\tKHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n\tKHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n\tKHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\tKHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n\tKHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n\tEXT_MATERIALS_BUMP: 'EXT_materials_bump',\n\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\n\tEXT_TEXTURE_AVIF: 'EXT_texture_avif',\n\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n\tEXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'\n};\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\t// Object3D instance caches\n\t\tthis.cache = { refs: {}, uses: {} };\n\n\t}\n\n\t_markDefs() {\n\n\t\tconst parser = this.parser;\n\t\tconst nodeDefs = this.parser.json.nodes || [];\n\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.extensions\n\t\t\t\t\t&& nodeDef.extensions[ this.name ]\n\t\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\n\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t_loadLight( lightIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst cacheKey = 'light:' + lightIndex;\n\t\tlet dependency = parser.cache.get( cacheKey );\n\n\t\tif ( dependency ) return dependency;\n\n\t\tconst json = parser.json;\n\t\tconst extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\n\t\tconst lightDefs = extensions.lights || [];\n\t\tconst lightDef = lightDefs[ lightIndex ];\n\t\tlet lightNode;\n\n\t\tconst color = new Color( 0xffffff );\n\n\t\tif ( lightDef.color !== undefined ) color.setRGB( lightDef.color[ 0 ], lightDef.color[ 1 ], lightDef.color[ 2 ], LinearSRGBColorSpace );\n\n\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\tswitch ( lightDef.type ) {\n\n\t\t\tcase 'directional':\n\t\t\t\tlightNode = new DirectionalLight( color );\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tcase 'point':\n\t\t\t\tlightNode = new PointLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\tbreak;\n\n\t\t\tcase 'spot':\n\t\t\t\tlightNode = new SpotLight( color );\n\t\t\t\tlightNode.distance = range;\n\t\t\t\t// Handle spotlight properties.\n\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\n\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\n\n\t\t}\n\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\n\t\t// here, because node-level parsing will only override position if explicitly specified.\n\t\tlightNode.position.set( 0, 0, 0 );\n\n\t\tlightNode.decay = 2;\n\n\t\tassignExtrasToUserData( lightNode, lightDef );\n\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\n\n\t\tdependency = Promise.resolve( lightNode );\n\n\t\tparser.cache.add( cacheKey, dependency );\n\n\t\treturn dependency;\n\n\t}\n\n\tgetDependency( type, index ) {\n\n\t\tif ( type !== 'light' ) return;\n\n\t\treturn this._loadLight( index );\n\n\t}\n\n\tcreateNodeAttachment( nodeIndex ) {\n\n\t\tconst self = this;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\t\tconst lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\n\t\tconst lightIndex = lightDef.light;\n\n\t\tif ( lightIndex === undefined ) return null;\n\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\n\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tgetMaterialType() {\n\n\t\treturn MeshBasicMaterial;\n\n\t}\n\n\textendParams( materialParams, materialDef, parser ) {\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;\n\n\t\tif ( emissiveStrength !== undefined ) {\n\n\t\t\tmaterialParams.emissiveIntensity = emissiveStrength;\n\n\t\t}\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.clearcoatFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\n\n\t\t}\n\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\n\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale;\n\n\t\t\t\tmaterialParams.clearcoatNormalScale = new Vector2( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion\n */\nclass GLTFMaterialsDispersionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.iridescenceFactor !== undefined ) {\n\n\t\t\tmaterialParams.iridescence = extension.iridescenceFactor;\n\n\t\t}\n\n\t\tif ( extension.iridescenceTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );\n\n\t\t}\n\n\t\tif ( extension.iridescenceIor !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceIOR = extension.iridescenceIor;\n\n\t\t}\n\n\t\tif ( materialParams.iridescenceThicknessRange === undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange = [ 100, 400 ];\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMinimum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessMaximum !== undefined ) {\n\n\t\t\tmaterialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;\n\n\t\t}\n\n\t\tif ( extension.iridescenceThicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tmaterialParams.sheenColor = new Color( 0, 0, 0 );\n\t\tmaterialParams.sheenRoughness = 0;\n\t\tmaterialParams.sheen = 1;\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.sheenColorFactor !== undefined ) {\n\n\t\t\tconst colorFactor = extension.sheenColorFactor;\n\t\t\tmaterialParams.sheenColor.setRGB( colorFactor[ 0 ], colorFactor[ 1 ], colorFactor[ 2 ], LinearSRGBColorSpace );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessFactor !== undefined ) {\n\n\t\t\tmaterialParams.sheenRoughness = extension.sheenRoughnessFactor;\n\n\t\t}\n\n\t\tif ( extension.sheenColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\tif ( extension.sheenRoughnessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.transmissionFactor !== undefined ) {\n\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\n\n\t\t}\n\n\t\tif ( extension.transmissionTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\n\n\t\tif ( extension.thicknessTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );\n\n\t\t}\n\n\t\tmaterialParams.attenuationDistance = extension.attenuationDistance || Infinity;\n\n\t\tconst colorArray = extension.attenuationColor || [ 1, 1, 1 ];\n\t\tmaterialParams.attenuationColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IOR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\n\n\t\treturn Promise.resolve();\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\n\n\t\tif ( extension.specularTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );\n\n\t\t}\n\n\t\tconst colorArray = extension.specularColorFactor || [ 1, 1, 1 ];\n\t\tmaterialParams.specularColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );\n\n\t\tif ( extension.specularColorTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n */\nclass GLTFMaterialsBumpExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_MATERIALS_BUMP;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tmaterialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0;\n\n\t\tif ( extension.bumpTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'bumpMap', extension.bumpTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\n\n\t}\n\n\tgetMaterialType( materialIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\n\n\t\treturn MeshPhysicalMaterial;\n\n\t}\n\n\textendMaterialParams( materialIndex, materialParams ) {\n\n\t\tconst parser = this.parser;\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\n\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\n\n\t\t\treturn Promise.resolve();\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tconst extension = materialDef.extensions[ this.name ];\n\n\t\tif ( extension.anisotropyStrength !== undefined ) {\n\n\t\t\tmaterialParams.anisotropy = extension.anisotropyStrength;\n\n\t\t}\n\n\t\tif ( extension.anisotropyRotation !== undefined ) {\n\n\t\t\tmaterialParams.anisotropyRotation = extension.anisotropyRotation;\n\n\t\t}\n\n\t\tif ( extension.anisotropyTexture !== undefined ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ this.name ];\n\t\tconst loader = parser.options.ktx2Loader;\n\n\t\tif ( ! loader ) {\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\n\n\t\t\t} else {\n\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t}\n\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image. Support for lossy images doesn't guarantee support for all\n\t\t\t\t// WebP images, unfortunately.\n\t\t\t\timage.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';\n\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n\n\tconstructor( parser ) {\n\n\t\tthis.parser = parser;\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_AVIF;\n\t\tthis.isSupported = null;\n\n\t}\n\n\tloadTexture( textureIndex ) {\n\n\t\tconst name = this.name;\n\t\tconst parser = this.parser;\n\t\tconst json = parser.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst extension = textureDef.extensions[ name ];\n\t\tconst source = json.images[ extension.source ];\n\n\t\tlet loader = parser.textureLoader;\n\t\tif ( source.uri ) {\n\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.detectSupport().then( function ( isSupported ) {\n\n\t\t\tif ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );\n\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: AVIF required by asset but unsupported.' );\n\n\t\t\t}\n\n\t\t\t// Fall back to PNG or JPEG.\n\t\t\treturn parser.loadTexture( textureIndex );\n\n\t\t} );\n\n\t}\n\n\tdetectSupport() {\n\n\t\tif ( ! this.isSupported ) {\n\n\t\t\tthis.isSupported = new Promise( function ( resolve ) {\n\n\t\t\t\tconst image = new Image();\n\n\t\t\t\t// Lossy test image.\n\t\t\t\timage.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';\n\t\t\t\timage.onload = image.onerror = function () {\n\n\t\t\t\t\tresolve( image.height === 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn this.isSupported;\n\n\t}\n\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n\t\tthis.parser = parser;\n\n\t}\n\n\tloadBufferView( index ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst bufferView = json.bufferViews[ index ];\n\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\n\n\t\t\tconst extensionDef = bufferView.extensions[ this.name ];\n\n\t\t\tconst buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\n\t\t\tconst decoder = this.parser.options.meshoptDecoder;\n\n\t\t\tif ( ! decoder || ! decoder.supported ) {\n\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn buffer.then( function ( res ) {\n\n\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\n\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\n\n\t\t\t\tconst count = extensionDef.count;\n\t\t\t\tconst stride = extensionDef.byteStride;\n\n\t\t\t\tconst source = new Uint8Array( res, byteOffset, byteLength );\n\n\t\t\t\tif ( decoder.decodeGltfBufferAsync ) {\n\n\t\t\t\t\treturn decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {\n\n\t\t\t\t\t\treturn res.buffer;\n\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n\t\t\t\t\treturn decoder.ready.then( function () {\n\n\t\t\t\t\t\tconst result = new ArrayBuffer( count * stride );\n\t\t\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\n\t\t\t\t\t\treturn result;\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n\n\tconstructor( parser ) {\n\n\t\tthis.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\n\t\tthis.parser = parser;\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.parser.json;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||\n\t\t\tnodeDef.mesh === undefined ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst meshDef = json.meshes[ nodeDef.mesh ];\n\n\t\t// No Points or Lines + Instancing support yet\n\n\t\tfor ( const primitive of meshDef.primitives ) {\n\n\t\t\tif ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n\t\t\t\t primitive.mode !== undefined ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst extensionDef = nodeDef.extensions[ this.name ];\n\t\tconst attributesDef = extensionDef.attributes;\n\n\t\t// @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n\t\tconst pending = [];\n\t\tconst attributes = {};\n\n\t\tfor ( const key in attributesDef ) {\n\n\t\t\tpending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {\n\n\t\t\t\tattributes[ key ] = accessor;\n\t\t\t\treturn attributes[ key ];\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tif ( pending.length < 1 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tpending.push( this.parser.createNodeMesh( nodeIndex ) );\n\n\t\treturn Promise.all( pending ).then( results => {\n\n\t\t\tconst nodeObject = results.pop();\n\t\t\tconst meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];\n\t\t\tconst count = results[ 0 ].count; // All attribute counts should be same\n\t\t\tconst instancedMeshes = [];\n\n\t\t\tfor ( const mesh of meshes ) {\n\n\t\t\t\t// Temporal variables\n\t\t\t\tconst m = new Matrix4();\n\t\t\t\tconst p = new Vector3();\n\t\t\t\tconst q = new Quaternion();\n\t\t\t\tconst s = new Vector3( 1, 1, 1 );\n\n\t\t\t\tconst instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );\n\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\tif ( attributes.TRANSLATION ) {\n\n\t\t\t\t\t\tp.fromBufferAttribute( attributes.TRANSLATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.ROTATION ) {\n\n\t\t\t\t\t\tq.fromBufferAttribute( attributes.ROTATION, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes.SCALE ) {\n\n\t\t\t\t\t\ts.fromBufferAttribute( attributes.SCALE, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinstancedMesh.setMatrixAt( i, m.compose( p, q, s ) );\n\n\t\t\t\t}\n\n\t\t\t\t// Add instance attributes to the geometry, excluding TRS.\n\t\t\t\tfor ( const attributeName in attributes ) {\n\n\t\t\t\t\tif ( attributeName === '_COLOR_0' ) {\n\n\t\t\t\t\t\tconst attr = attributes[ attributeName ];\n\t\t\t\t\t\tinstancedMesh.instanceColor = new InstancedBufferAttribute( attr.array, attr.itemSize, attr.normalized );\n\n\t\t\t\t\t} else if ( attributeName !== 'TRANSLATION' &&\n\t\t\t\t\t\t attributeName !== 'ROTATION' &&\n\t\t\t\t\t\t attributeName !== 'SCALE' ) {\n\n\t\t\t\t\t\tmesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Just in case\n\t\t\t\tObject3D.prototype.copy.call( instancedMesh, mesh );\n\n\t\t\t\tthis.parser.assignFinalMaterial( instancedMesh );\n\n\t\t\t\tinstancedMeshes.push( instancedMesh );\n\n\t\t\t}\n\n\t\t\tif ( nodeObject.isGroup ) {\n\n\t\t\t\tnodeObject.clear();\n\n\t\t\t\tnodeObject.add( ... instancedMeshes );\n\n\t\t\t\treturn nodeObject;\n\n\t\t\t}\n\n\t\t\treturn instancedMeshes[ 0 ];\n\n\t\t} );\n\n\t}\n\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\nclass GLTFBinaryExtension {\n\n\tconstructor( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tconst headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tconst textDecoder = new TextDecoder();\n\n\t\tthis.header = {\n\t\t\tmagic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\n\n\t\t}\n\n\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n\t\tconst chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tlet chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkContentsLength ) {\n\n\t\t\tconst chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tconst chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tconst contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = textDecoder.decode( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n\n\tconstructor( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\t\tthis.dracoLoader.preload();\n\n\t}\n\n\tdecodePrimitive( primitive, parser ) {\n\n\t\tconst json = this.json;\n\t\tconst dracoLoader = this.dracoLoader;\n\t\tconst bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tconst gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tconst threeAttributeMap = {};\n\t\tconst attributeNormalizedMap = {};\n\t\tconst attributeTypeMap = {};\n\n\t\tfor ( const attributeName in gltfAttributeMap ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( const attributeName in primitive.attributes ) {\n\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\n\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tconst accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType.name;\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( const attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tconst normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n\n\t}\n\n\textendTexture( texture, transform ) {\n\n\t\tif ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )\n\t\t\t&& transform.offset === undefined\n\t\t\t&& transform.rotation === undefined\n\t\t\t&& transform.scale === undefined ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21819.\n\t\t\treturn texture;\n\n\t\t}\n\n\t\ttexture = texture.clone();\n\n\t\tif ( transform.texCoord !== undefined ) {\n\n\t\t\ttexture.channel = transform.texCoord;\n\n\t\t}\n\n\t\tif ( transform.offset !== undefined ) {\n\n\t\t\ttexture.offset.fromArray( transform.offset );\n\n\t\t}\n\n\t\tif ( transform.rotation !== undefined ) {\n\n\t\t\ttexture.rotation = transform.rotation;\n\n\t\t}\n\n\t\tif ( transform.scale !== undefined ) {\n\n\t\t\ttexture.repeat.fromArray( transform.scale );\n\n\t\t}\n\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n\n\tconstructor() {\n\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n\n\t}\n\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tcopySampleValue_( index ) {\n\n\t\t// Copies a sample value to the result buffer. See description of glTF\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\n\n\t\tconst result = this.resultBuffer,\n\t\t\tvalues = this.sampleValues,\n\t\t\tvalueSize = this.valueSize,\n\t\t\toffset = index * valueSize * 3 + valueSize;\n\n\t\tfor ( let i = 0; i !== valueSize; i ++ ) {\n\n\t\t\tresult[ i ] = values[ offset + i ];\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = this.resultBuffer;\n\t\tconst values = this.sampleValues;\n\t\tconst stride = this.valueSize;\n\n\t\tconst stride2 = stride * 2;\n\t\tconst stride3 = stride * 3;\n\n\t\tconst td = t1 - t0;\n\n\t\tconst p = ( t - t0 ) / td;\n\t\tconst pp = p * p;\n\t\tconst ppp = pp * p;\n\n\t\tconst offset1 = i1 * stride3;\n\t\tconst offset0 = offset1 - stride3;\n\n\t\tconst s2 = - 2 * ppp + 3 * pp;\n\t\tconst s3 = ppp - pp;\n\t\tconst s0 = 1 - s2;\n\t\tconst s1 = s3 - pp + p;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( let i = 0; i !== stride; i ++ ) {\n\n\t\t\tconst p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\tconst m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tconst p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\tconst m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n}\n\nconst _q = new Quaternion();\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n\n\tinterpolate_( i1, t0, t, t1 ) {\n\n\t\tconst result = super.interpolate_( i1, t0, t, t1 );\n\n\t\t_q.fromArray( result ).normalize().toArray( result );\n\n\t\treturn result;\n\n\t}\n\n}\n\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n\tFLOAT: 5126,\n\t//FLOAT_MAT2: 35674,\n\tFLOAT_MAT3: 35675,\n\tFLOAT_MAT4: 35676,\n\tFLOAT_VEC2: 35664,\n\tFLOAT_VEC3: 35665,\n\tFLOAT_VEC4: 35666,\n\tLINEAR: 9729,\n\tREPEAT: 10497,\n\tSAMPLER_2D: 35678,\n\tPOINTS: 0,\n\tLINES: 1,\n\tLINE_LOOP: 2,\n\tLINE_STRIP: 3,\n\tTRIANGLES: 4,\n\tTRIANGLE_STRIP: 5,\n\tTRIANGLE_FAN: 6,\n\tUNSIGNED_BYTE: 5121,\n\tUNSIGNED_SHORT: 5123\n};\n\nconst WEBGL_COMPONENT_TYPES = {\n\t5120: Int8Array,\n\t5121: Uint8Array,\n\t5122: Int16Array,\n\t5123: Uint16Array,\n\t5125: Uint32Array,\n\t5126: Float32Array\n};\n\nconst WEBGL_FILTERS = {\n\t9728: NearestFilter,\n\t9729: LinearFilter,\n\t9984: NearestMipmapNearestFilter,\n\t9985: LinearMipmapNearestFilter,\n\t9986: NearestMipmapLinearFilter,\n\t9987: LinearMipmapLinearFilter\n};\n\nconst WEBGL_WRAPPINGS = {\n\t33071: ClampToEdgeWrapping,\n\t33648: MirroredRepeatWrapping,\n\t10497: RepeatWrapping\n};\n\nconst WEBGL_TYPE_SIZES = {\n\t'SCALAR': 1,\n\t'VEC2': 2,\n\t'VEC3': 3,\n\t'VEC4': 4,\n\t'MAT2': 4,\n\t'MAT3': 9,\n\t'MAT4': 16\n};\n\nconst ATTRIBUTES = {\n\tPOSITION: 'position',\n\tNORMAL: 'normal',\n\tTANGENT: 'tangent',\n\tTEXCOORD_0: 'uv',\n\tTEXCOORD_1: 'uv1',\n\tTEXCOORD_2: 'uv2',\n\tTEXCOORD_3: 'uv3',\n\tCOLOR_0: 'color',\n\tWEIGHTS_0: 'skinWeight',\n\tJOINTS_0: 'skinIndex',\n};\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\ttranslation: 'position',\n\trotation: 'quaternion',\n\tweights: 'morphTargetInfluences'\n};\n\nconst INTERPOLATION = {\n\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\n\tLINEAR: InterpolateLinear,\n\tSTEP: InterpolateDiscrete\n};\n\nconst ALPHA_MODES = {\n\tOPAQUE: 'OPAQUE',\n\tMASK: 'MASK',\n\tBLEND: 'BLEND'\n};\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial( cache ) {\n\n\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\n\n\t\tcache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: FrontSide\n\t\t} );\n\n\t}\n\n\treturn cache[ 'DefaultMaterial' ];\n\n}\n\nfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t// Add unknown glTF extensions to an object's userData.\n\n\tfor ( const name in objectDef.extensions ) {\n\n\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData( object, gltfDef ) {\n\n\tif ( gltfDef.extras !== undefined ) {\n\n\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\tObject.assign( object.userData, gltfDef.extras );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets( geometry, targets, parser ) {\n\n\tlet hasMorphPosition = false;\n\tlet hasMorphNormal = false;\n\tlet hasMorphColor = false;\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\t\tif ( target.COLOR_0 !== undefined ) hasMorphColor = true;\n\n\t\tif ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;\n\n\t}\n\n\tif ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );\n\n\tconst pendingPositionAccessors = [];\n\tconst pendingNormalAccessors = [];\n\tconst pendingColorAccessors = [];\n\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\tconst target = targets[ i ];\n\n\t\tif ( hasMorphPosition ) {\n\n\t\t\tconst pendingAccessor = target.POSITION !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\n\t\t\t\t: geometry.attributes.position;\n\n\t\t\tpendingPositionAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphNormal ) {\n\n\t\t\tconst pendingAccessor = target.NORMAL !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\n\t\t\t\t: geometry.attributes.normal;\n\n\t\t\tpendingNormalAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t\tif ( hasMorphColor ) {\n\n\t\t\tconst pendingAccessor = target.COLOR_0 !== undefined\n\t\t\t\t? parser.getDependency( 'accessor', target.COLOR_0 )\n\t\t\t\t: geometry.attributes.color;\n\n\t\t\tpendingColorAccessors.push( pendingAccessor );\n\n\t\t}\n\n\t}\n\n\treturn Promise.all( [\n\t\tPromise.all( pendingPositionAccessors ),\n\t\tPromise.all( pendingNormalAccessors ),\n\t\tPromise.all( pendingColorAccessors )\n\t] ).then( function ( accessors ) {\n\n\t\tconst morphPositions = accessors[ 0 ];\n\t\tconst morphNormals = accessors[ 1 ];\n\t\tconst morphColors = accessors[ 2 ];\n\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\t\tif ( hasMorphColor ) geometry.morphAttributes.color = morphColors;\n\t\tgeometry.morphTargetsRelative = true;\n\n\t\treturn geometry;\n\n\t} );\n\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets( mesh, meshDef ) {\n\n\tmesh.updateMorphTargets();\n\n\tif ( meshDef.weights !== undefined ) {\n\n\t\tfor ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t}\n\n\t}\n\n\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\tconst targetNames = meshDef.extras.targetNames;\n\n\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t}\n\n\t}\n\n}\n\nfunction createPrimitiveKey( primitiveDef ) {\n\n\tlet geometryKey;\n\n\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\n\n\tif ( dracoExtension ) {\n\n\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\n\t\t\t\t+ ':' + dracoExtension.indices\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\n\n\t} else {\n\n\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\n\n\t}\n\n\tif ( primitiveDef.targets !== undefined ) {\n\n\t\tfor ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {\n\n\t\t\tgeometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );\n\n\t\t}\n\n\t}\n\n\treturn geometryKey;\n\n}\n\nfunction createAttributesKey( attributes ) {\n\n\tlet attributesKey = '';\n\n\tconst keys = Object.keys( attributes ).sort();\n\n\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\n\n\t}\n\n\treturn attributesKey;\n\n}\n\nfunction getNormalizedComponentScale( constructor ) {\n\n\t// Reference:\n\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n\tswitch ( constructor ) {\n\n\t\tcase Int8Array:\n\t\t\treturn 1 / 127;\n\n\t\tcase Uint8Array:\n\t\t\treturn 1 / 255;\n\n\t\tcase Int16Array:\n\t\t\treturn 1 / 32767;\n\n\t\tcase Uint16Array:\n\t\t\treturn 1 / 65535;\n\n\t\tdefault:\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );\n\n\t}\n\n}\n\nfunction getImageURIMimeType( uri ) {\n\n\tif ( uri.search( /\\.jpe?g($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/jpeg/ ) === 0 ) return 'image/jpeg';\n\tif ( uri.search( /\\.webp($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/webp/ ) === 0 ) return 'image/webp';\n\n\treturn 'image/png';\n\n}\n\nconst _identityMatrix = new Matrix4();\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n\n\tconstructor( json = {}, options = {} ) {\n\n\t\tthis.json = json;\n\t\tthis.extensions = {};\n\t\tthis.plugins = {};\n\t\tthis.options = options;\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// associations between Three.js objects and glTF elements\n\t\tthis.associations = new Map();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = {};\n\n\t\t// Node cache\n\t\tthis.nodeCache = {};\n\n\t\t// Object3D instance caches\n\t\tthis.meshCache = { refs: {}, uses: {} };\n\t\tthis.cameraCache = { refs: {}, uses: {} };\n\t\tthis.lightCache = { refs: {}, uses: {} };\n\n\t\tthis.sourceCache = {};\n\t\tthis.textureCache = {};\n\n\t\t// Track node names, to ensure no duplicates\n\t\tthis.nodeNamesUsed = {};\n\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\n\n\t\tlet isSafari = false;\n\t\tlet isFirefox = false;\n\t\tlet firefoxVersion = - 1;\n\n\t\tif ( typeof navigator !== 'undefined' ) {\n\n\t\t\tisSafari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === true;\n\t\t\tisFirefox = navigator.userAgent.indexOf( 'Firefox' ) > - 1;\n\t\t\tfirefoxVersion = isFirefox ? navigator.userAgent.match( /Firefox\\/([0-9]+)\\./ )[ 1 ] : - 1;\n\n\t\t}\n\n\t\tif ( typeof createImageBitmap === 'undefined' || isSafari || ( isFirefox && firefoxVersion < 98 ) ) {\n\n\t\t\tthis.textureLoader = new TextureLoader( this.options.manager );\n\n\t\t} else {\n\n\t\t\tthis.textureLoader = new ImageBitmapLoader( this.options.manager );\n\n\t\t}\n\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\n\n\t\tthis.fileLoader = new FileLoader( this.options.manager );\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\n\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\n\n\t\t\tthis.fileLoader.setWithCredentials( true );\n\n\t\t}\n\n\t}\n\n\tsetExtensions( extensions ) {\n\n\t\tthis.extensions = extensions;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tparse( onLoad, onError ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\t\tthis.nodeCache = {};\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\treturn ext._markDefs && ext._markDefs();\n\n\t\t} );\n\n\t\tPromise.all( this._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\n\n\t\t} ) ).then( function () {\n\n\t\t\treturn Promise.all( [\n\n\t\t\t\tparser.getDependencies( 'scene' ),\n\t\t\t\tparser.getDependencies( 'animation' ),\n\t\t\t\tparser.getDependencies( 'camera' ),\n\n\t\t\t] );\n\n\t\t} ).then( function ( dependencies ) {\n\n\t\t\tconst result = {\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\n\t\t\t\tscenes: dependencies[ 0 ],\n\t\t\t\tanimations: dependencies[ 1 ],\n\t\t\t\tcameras: dependencies[ 2 ],\n\t\t\t\tasset: json.asset,\n\t\t\t\tparser: parser,\n\t\t\t\tuserData: {}\n\t\t\t};\n\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\n\n\t\t\tassignExtrasToUserData( result, json );\n\n\t\t\treturn Promise.all( parser._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\n\n\t\t\t} ) ).then( function () {\n\n\t\t\t\tfor ( const scene of result.scenes ) {\n\n\t\t\t\t\tscene.updateMatrixWorld();\n\n\t\t\t\t}\n\n\t\t\t\tonLoad( result );\n\n\t\t\t} );\n\n\t\t} ).catch( onError );\n\n\t}\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\t_markDefs() {\n\n\t\tconst nodeDefs = this.json.nodes || [];\n\t\tconst skinDefs = this.json.skins || [];\n\t\tconst meshDefs = this.json.meshes || [];\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tconst joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( let i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Iterate over all nodes, marking references to shared resources,\n\t\t// as well as skeleton joints.\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Counts references to shared node / Object3D resources. These resources\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\n\t * Textures) can be reused directly and are not marked here.\n\t *\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t */\n\t_addNodeRef( cache, index ) {\n\n\t\tif ( index === undefined ) return;\n\n\t\tif ( cache.refs[ index ] === undefined ) {\n\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\n\n\t\t}\n\n\t\tcache.refs[ index ] ++;\n\n\t}\n\n\t/** Returns a reference to a shared resource, cloning it if necessary. */\n\t_getNodeRef( cache, index, object ) {\n\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\n\n\t\tconst ref = object.clone();\n\n\t\t// Propagates mappings to the cloned object, prevents mappings on the\n\t\t// original object from being lost.\n\t\tconst updateMappings = ( original, clone ) => {\n\n\t\t\tconst mappings = this.associations.get( original );\n\t\t\tif ( mappings != null ) {\n\n\t\t\t\tthis.associations.set( clone, mappings );\n\n\t\t\t}\n\n\t\t\tfor ( const [ i, child ] of original.children.entries() ) {\n\n\t\t\t\tupdateMappings( child, clone.children[ i ] );\n\n\t\t\t}\n\n\t\t};\n\n\t\tupdateMappings( object, ref );\n\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\n\n\t\treturn ref;\n\n\t}\n\n\t_invokeOne( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.push( this );\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) return result;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tconst extensions = Object.values( this.plugins );\n\t\textensions.unshift( this );\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\n\n\t\t\tconst result = func( extensions[ i ] );\n\n\t\t\tif ( result ) pending.push( result );\n\n\t\t}\n\n\t\treturn pending;\n\n\t}\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n\t */\n\tgetDependency( type, index ) {\n\n\t\tconst cacheKey = type + ':' + index;\n\t\tlet dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadNode && ext.loadNode( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext.loadAnimation && ext.loadAnimation( index );\n\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\n\n\t\t\t\t\t\treturn ext != this && ext.getDependency && ext.getDependency( type, index );\n\n\t\t\t\t\t} );\n\n\t\t\t\t\tif ( ! dependency ) {\n\n\t\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t}\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tgetDependencies( type ) {\n\n\t\tlet dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tconst parser = this;\n\t\t\tconst defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBuffer( bufferIndex ) {\n\n\t\tconst bufferDef = this.json.buffers[ bufferIndex ];\n\t\tconst loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\n\t\t}\n\n\t\tconst options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tloadBufferView( bufferViewIndex ) {\n\n\t\tconst bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\n\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n\t */\n\tloadAccessor( accessorIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\t\t\tconst normalized = accessorDef.normalized === true;\n\n\t\t\tconst array = new TypedArray( accessorDef.count * itemSize );\n\t\t\treturn Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );\n\n\t\t}\n\n\t\tconst pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tconst bufferView = bufferViews[ 0 ];\n\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tconst itemBytes = elementBytes * itemSize;\n\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\n\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\n\t\t\tconst normalized = accessorDef.normalized === true;\n\t\t\tlet array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\n\t\t\t\tconst ibSlice = Math.floor( byteOffset / byteStride );\n\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n\t\t\t\tlet ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tconst sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tconst sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture|null>}\n\t */\n\tloadTexture( textureIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceIndex = textureDef.source;\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tlet loader = this.textureLoader;\n\n\t\tif ( sourceDef.uri ) {\n\n\t\t\tconst handler = options.manager.getHandler( sourceDef.uri );\n\t\t\tif ( handler !== null ) loader = handler;\n\n\t\t}\n\n\t\treturn this.loadTextureImage( textureIndex, sourceIndex, loader );\n\n\t}\n\n\tloadTextureImage( textureIndex, sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\n\t\tconst textureDef = json.textures[ textureIndex ];\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;\n\n\t\tif ( this.textureCache[ cacheKey ] ) {\n\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21559.\n\t\t\treturn this.textureCache[ cacheKey ];\n\n\t\t}\n\n\t\tconst promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {\n\n\t\t\ttexture.flipY = false;\n\n\t\t\ttexture.name = textureDef.name || sourceDef.name || '';\n\n\t\t\tif ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {\n\n\t\t\t\ttexture.name = sourceDef.uri;\n\n\t\t\t}\n\n\t\t\tconst samplers = json.samplers || {};\n\t\t\tconst sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;\n\n\t\t\tparser.associations.set( texture, { textures: textureIndex } );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function () {\n\n\t\t\treturn null;\n\n\t\t} );\n\n\t\tthis.textureCache[ cacheKey ] = promise;\n\n\t\treturn promise;\n\n\t}\n\n\tloadImageSource( sourceIndex, loader ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( this.sourceCache[ sourceIndex ] !== undefined ) {\n\n\t\t\treturn this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );\n\n\t\t}\n\n\t\tconst sourceDef = json.images[ sourceIndex ];\n\n\t\tconst URL = self.URL || self.webkitURL;\n\n\t\tlet sourceURI = sourceDef.uri || '';\n\t\tlet isObjectURL = false;\n\n\t\tif ( sourceDef.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tconst blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t} else if ( sourceDef.uri === undefined ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );\n\n\t\t}\n\n\t\tconst promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tlet onLoad = resolve;\n\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\n\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\n\n\t\t\t\t\t\tconst texture = new Texture( imageBitmap );\n\t\t\t\t\t\ttexture.needsUpdate = true;\n\n\t\t\t\t\t\tresolve( texture );\n\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t\tloader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\ttexture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );\n\n\t\t\treturn texture;\n\n\t\t} ).catch( function ( error ) {\n\n\t\t\tconsole.error( 'THREE.GLTFLoader: Couldn\\'t load texture', sourceURI );\n\t\t\tthrow error;\n\n\t\t} );\n\n\t\tthis.sourceCache[ sourceIndex ] = promise;\n\t\treturn promise;\n\n\t}\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} mapName\n\t * @param {Object} mapDef\n\t * @return {Promise<Texture>}\n\t */\n\tassignTexture( materialParams, mapName, mapDef, colorSpace ) {\n\n\t\tconst parser = this;\n\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\n\n\t\t\tif ( ! texture ) return null;\n\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {\n\n\t\t\t\ttexture = texture.clone();\n\t\t\t\ttexture.channel = mapDef.texCoord;\n\n\t\t\t}\n\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\n\n\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tconst gltfReference = parser.associations.get( texture );\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( colorSpace !== undefined ) {\n\n\t\t\t\ttexture.colorSpace = colorSpace;\n\n\t\t\t}\n\n\t\t\tmaterialParams[ mapName ] = texture;\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\n\t * already has a material (generated from the glTF material options alone)\n\t * but reuse of the same glTF material may require multiple threejs materials\n\t * to accommodate different primitive types, defines, etc. New materials will\n\t * be created if necessary, and reused from a cache.\n\t * @param  {Object3D} mesh Mesh, Line, or Points instance.\n\t */\n\tassignFinalMaterial( mesh ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tlet material = mesh.material;\n\n\t\tconst useDerivativeTangents = geometry.attributes.tangent === undefined;\n\t\tconst useVertexColors = geometry.attributes.color !== undefined;\n\t\tconst useFlatShading = geometry.attributes.normal === undefined;\n\n\t\tif ( mesh.isPoints ) {\n\n\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\tlet pointsMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\tpointsMaterial = new PointsMaterial();\n\t\t\t\tMaterial.prototype.copy.call( pointsMaterial, material );\n\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = pointsMaterial;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\tlet lineMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\tlineMaterial = new LineBasicMaterial();\n\t\t\t\tMaterial.prototype.copy.call( lineMaterial, material );\n\t\t\t\tlineMaterial.color.copy( material.color );\n\t\t\t\tlineMaterial.map = material.map;\n\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\n\n\t\t\t}\n\n\t\t\tmaterial = lineMaterial;\n\n\t\t}\n\n\t\t// Clone the material if it will be modified\n\t\tif ( useDerivativeTangents || useVertexColors || useFlatShading ) {\n\n\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\tif ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\n\t\t\tlet cachedMaterial = this.cache.get( cacheKey );\n\n\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\tcachedMaterial = material.clone();\n\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\n\t\t\t\tif ( useDerivativeTangents ) {\n\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\n\n\t\t\t\t}\n\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\n\n\t\t\t}\n\n\t\t\tmaterial = cachedMaterial;\n\n\t\t}\n\n\t\tmesh.material = material;\n\n\t}\n\n\tgetMaterialType( /* materialIndex */ ) {\n\n\t\treturn MeshStandardMaterial;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<Material>}\n\t */\n\tloadMaterial( materialIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst materialDef = json.materials[ materialIndex ];\n\n\t\tlet materialType;\n\t\tconst materialParams = {};\n\t\tconst materialExtensions = materialDef.extensions || {};\n\n\t\tconst pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tconst kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType();\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\n\n\t\t\t}\n\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\n\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\n\n\t\t\t} );\n\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\n\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\n\n\t\t\t} ) ) );\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = DoubleSide;\n\n\t\t}\n\n\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\n\t\t\tmaterialParams.depthWrite = false;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\n\n\t\t\tmaterialParams.normalScale = new Vector2( 1, 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tconst scale = materialDef.normalTexture.scale;\n\n\t\t\t\tmaterialParams.normalScale.set( scale, scale );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tconst emissiveFactor = materialDef.emissiveFactor;\n\t\t\tmaterialParams.emissive = new Color().setRGB( emissiveFactor[ 0 ], emissiveFactor[ 1 ], emissiveFactor[ 2 ], LinearSRGBColorSpace );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tconst material = new materialType( materialParams );\n\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tparser.associations.set( material, { materials: materialIndex } );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t}\n\n\t/** When Object3D instances are targeted by animation, they need unique names. */\n\tcreateUniqueName( originalName ) {\n\n\t\tconst sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );\n\n\t\tif ( sanitizedName in this.nodeNamesUsed ) {\n\n\t\t\treturn sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );\n\n\t\t} else {\n\n\t\t\tthis.nodeNamesUsed[ sanitizedName ] = 0;\n\n\t\t\treturn sanitizedName;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Promise<Array<BufferGeometry>>}\n\t */\n\tloadGeometries( primitives ) {\n\n\t\tconst parser = this;\n\t\tconst extensions = this.extensions;\n\t\tconst cache = this.primitiveCache;\n\n\t\tfunction createDracoPrimitive( primitive ) {\n\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\n\n\t\t\t\t} );\n\n\t\t}\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = primitives[ i ];\n\t\t\tconst cacheKey = createPrimitiveKey( primitive );\n\n\t\t\t// See if we've already created this geometry\n\t\t\tconst cached = cache[ cacheKey ];\n\n\t\t\tif ( cached ) {\n\n\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\tpending.push( cached.promise );\n\n\t\t\t} else {\n\n\t\t\t\tlet geometryPromise;\n\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );\n\n\t\t\t\t}\n\n\t\t\t\t// Cache this geometry\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\n\n\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<Group|Mesh|SkinnedMesh>}\n\t */\n\tloadMesh( meshIndex ) {\n\n\t\tconst parser = this;\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\n\t\tconst meshDef = json.meshes[ meshIndex ];\n\t\tconst primitives = meshDef.primitives;\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tconst material = primitives[ i ].material === undefined\n\t\t\t\t? createDefaultMaterial( this.cache )\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\n\n\t\t\tpending.push( material );\n\n\t\t}\n\n\t\tpending.push( parser.loadGeometries( primitives ) );\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst materials = results.slice( 0, results.length - 1 );\n\t\t\tconst geometries = results[ results.length - 1 ];\n\n\t\t\tconst meshes = [];\n\n\t\t\tfor ( let i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\t// 1. create Mesh\n\n\t\t\t\tlet mesh;\n\n\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t? new SkinnedMesh( geometry, material )\n\t\t\t\t\t\t: new Mesh( geometry, material );\n\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true ) {\n\n\t\t\t\t\t\t// normalize skin weights to fix malformed assets (see #15319)\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\tmesh = new LineSegments( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\tmesh = new Line( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\tmesh = new LineLoop( geometry, material );\n\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\tmesh = new Points( geometry, material );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t}\n\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\n\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\n\n\t\t\t\tparser.assignFinalMaterial( mesh );\n\n\t\t\t\tmeshes.push( mesh );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tparser.associations.set( meshes[ i ], {\n\t\t\t\t\tmeshes: meshIndex,\n\t\t\t\t\tprimitives: i\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );\n\n\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\n\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );\n\n\t\t\tparser.associations.set( group, { meshes: meshIndex } );\n\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tloadCamera( cameraIndex ) {\n\n\t\tlet camera;\n\t\tconst cameraDef = this.json.cameras[ cameraIndex ];\n\t\tconst params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Skeleton>}\n\t */\n\tloadSkin( skinIndex ) {\n\n\t\tconst skinDef = this.json.skins[ skinIndex ];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {\n\n\t\t\tpending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );\n\n\t\t}\n\n\t\tif ( skinDef.inverseBindMatrices !== undefined ) {\n\n\t\t\tpending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );\n\n\t\t} else {\n\n\t\t\tpending.push( null );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( results ) {\n\n\t\t\tconst inverseBindMatrices = results.pop();\n\t\t\tconst jointNodes = results;\n\n\t\t\t// Note that bones (joint nodes) may or may not be in the\n\t\t\t// scene graph at this time.\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( let i = 0, il = jointNodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst jointNode = jointNodes[ i ];\n\n\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\tconst mat = new Matrix4();\n\n\t\t\t\t\tif ( inverseBindMatrices !== null ) {\n\n\t\t\t\t\t\tmat.fromArray( inverseBindMatrices.array, i * 16 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new Skeleton( bones, boneInverses );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tloadAnimation( animationIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst animationDef = json.animations[ animationIndex ];\n\t\tconst animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\tconst pendingNodes = [];\n\t\tconst pendingInputAccessors = [];\n\t\tconst pendingOutputAccessors = [];\n\t\tconst pendingSamplers = [];\n\t\tconst pendingTargets = [];\n\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tconst channel = animationDef.channels[ i ];\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tconst target = channel.target;\n\t\t\tconst name = target.node;\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tif ( target.node === undefined ) continue;\n\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tconst nodes = dependencies[ 0 ];\n\t\t\tconst inputAccessors = dependencies[ 1 ];\n\t\t\tconst outputAccessors = dependencies[ 2 ];\n\t\t\tconst samplers = dependencies[ 3 ];\n\t\t\tconst targets = dependencies[ 4 ];\n\n\t\t\tconst tracks = [];\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\n\t\t\t\tconst sampler = samplers[ i ];\n\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tif ( node.updateMatrix ) {\n\n\t\t\t\t\tnode.updateMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tconst createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );\n\n\t\t\t\tif ( createdTracks ) {\n\n\t\t\t\t\tfor ( let k = 0; k < createdTracks.length; k ++ ) {\n\n\t\t\t\t\t\ttracks.push( createdTracks[ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( animationName, undefined, tracks );\n\n\t\t} );\n\n\t}\n\n\tcreateNodeMesh( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tif ( nodeDef.mesh === undefined ) return null;\n\n\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\n\n\t\t\tconst node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\n\n\t\t\t// if weights are provided on the node, override weights on the mesh.\n\t\t\tif ( nodeDef.weights !== undefined ) {\n\n\t\t\t\tnode.traverse( function ( o ) {\n\n\t\t\t\t\tif ( ! o.isMesh ) return;\n\n\t\t\t\t\tfor ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<Object3D>}\n\t */\n\tloadNode( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst parser = this;\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\tconst nodePending = parser._loadNodeShallow( nodeIndex );\n\n\t\tconst childPending = [];\n\t\tconst childrenDef = nodeDef.children || [];\n\n\t\tfor ( let i = 0, il = childrenDef.length; i < il; i ++ ) {\n\n\t\t\tchildPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );\n\n\t\t}\n\n\t\tconst skeletonPending = nodeDef.skin === undefined\n\t\t\t? Promise.resolve( null )\n\t\t\t: parser.getDependency( 'skin', nodeDef.skin );\n\n\t\treturn Promise.all( [\n\t\t\tnodePending,\n\t\t\tPromise.all( childPending ),\n\t\t\tskeletonPending\n\t\t] ).then( function ( results ) {\n\n\t\t\tconst node = results[ 0 ];\n\t\t\tconst children = results[ 1 ];\n\t\t\tconst skeleton = results[ 2 ];\n\n\t\t\tif ( skeleton !== null ) {\n\n\t\t\t\t// This full traverse should be fine because\n\t\t\t\t// child glTF nodes have not been added to this node yet.\n\t\t\t\tnode.traverse( function ( mesh ) {\n\n\t\t\t\t\tif ( ! mesh.isSkinnedMesh ) return;\n\n\t\t\t\t\tmesh.bind( skeleton, _identityMatrix );\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\tnode.add( children[ i ] );\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t}\n\n\t// ._loadNodeShallow() parses a single node.\n\t// skin and child nodes are created and added in .loadNode() (no '_' prefix).\n\t_loadNodeShallow( nodeIndex ) {\n\n\t\tconst json = this.json;\n\t\tconst extensions = this.extensions;\n\t\tconst parser = this;\n\n\t\t// This method is called from .loadNode() and .loadSkin().\n\t\t// Cache a node to avoid duplication.\n\n\t\tif ( this.nodeCache[ nodeIndex ] !== undefined ) {\n\n\t\t\treturn this.nodeCache[ nodeIndex ];\n\n\t\t}\n\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\n\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\n\t\tconst nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\n\n\t\tconst pending = [];\n\n\t\tconst meshPromise = parser._invokeOne( function ( ext ) {\n\n\t\t\treturn ext.createNodeMesh && ext.createNodeMesh( nodeIndex );\n\n\t\t} );\n\n\t\tif ( meshPromise ) {\n\n\t\t\tpending.push( meshPromise );\n\n\t\t}\n\n\t\tif ( nodeDef.camera !== undefined ) {\n\n\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\n\n\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\n\n\t\t\t} ) );\n\n\t\t}\n\n\t\tparser._invokeAll( function ( ext ) {\n\n\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\n\n\t\t} ).forEach( function ( promise ) {\n\n\t\t\tpending.push( promise );\n\n\t\t} );\n\n\t\tthis.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {\n\n\t\t\tlet node;\n\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new Bone();\n\n\t\t\t} else if ( objects.length > 1 ) {\n\n\t\t\t\tnode = new Group();\n\n\t\t\t} else if ( objects.length === 1 ) {\n\n\t\t\t\tnode = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new Object3D();\n\n\t\t\t}\n\n\t\t\tif ( node !== objects[ 0 ] ) {\n\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\t\t\tnode.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name ) {\n\n\t\t\t\tnode.userData.name = nodeDef.name;\n\t\t\t\tnode.name = nodeName;\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tconst matrix = new Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix4( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! parser.associations.has( node ) ) {\n\n\t\t\t\tparser.associations.set( node, {} );\n\n\t\t\t}\n\n\t\t\tparser.associations.get( node ).nodes = nodeIndex;\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t\treturn this.nodeCache[ nodeIndex ];\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<Group>}\n\t */\n\tloadScene( sceneIndex ) {\n\n\t\tconst extensions = this.extensions;\n\t\tconst sceneDef = this.json.scenes[ sceneIndex ];\n\t\tconst parser = this;\n\n\t\t// Loader returns Group, not Scene.\n\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n\t\tconst scene = new Group();\n\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\n\n\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\tconst nodeIds = sceneDef.nodes || [];\n\n\t\tconst pending = [];\n\n\t\tfor ( let i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\tpending.push( parser.getDependency( 'node', nodeIds[ i ] ) );\n\n\t\t}\n\n\t\treturn Promise.all( pending ).then( function ( nodes ) {\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tscene.add( nodes[ i ] );\n\n\t\t\t}\n\n\t\t\t// Removes dangling associations, associations that reference a node that\n\t\t\t// didn't make it into the scene.\n\t\t\tconst reduceAssociations = ( node ) => {\n\n\t\t\t\tconst reducedAssociations = new Map();\n\n\t\t\t\tfor ( const [ key, value ] of parser.associations ) {\n\n\t\t\t\t\tif ( key instanceof Material || key instanceof Texture ) {\n\n\t\t\t\t\t\treducedAssociations.set( key, value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tnode.traverse( ( node ) => {\n\n\t\t\t\t\tconst mappings = parser.associations.get( node );\n\n\t\t\t\t\tif ( mappings != null ) {\n\n\t\t\t\t\t\treducedAssociations.set( node, mappings );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\treturn reducedAssociations;\n\n\t\t\t};\n\n\t\t\tparser.associations = reduceAssociations( scene );\n\n\t\t\treturn scene;\n\n\t\t} );\n\n\t}\n\n\t_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {\n\n\t\tconst tracks = [];\n\n\t\tconst targetName = node.name ? node.name : node.uuid;\n\t\tconst targetNames = [];\n\n\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\tif ( object.morphTargetInfluences ) {\n\n\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\ttargetNames.push( targetName );\n\n\t\t}\n\n\t\tlet TypedKeyframeTrack;\n\n\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tcase PATH_PROPERTIES.position:\n\t\t\tcase PATH_PROPERTIES.scale:\n\n\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tswitch ( outputAccessor.itemSize ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\tcase 3:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\n\n\n\t\tconst outputArray = this._getArrayFromAccessor( outputAccessor );\n\n\t\tfor ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\tconst track = new TypedKeyframeTrack(\n\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\tinputAccessor.array,\n\t\t\t\toutputArray,\n\t\t\t\tinterpolation\n\t\t\t);\n\n\t\t\t// Override interpolation with custom factory method.\n\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\tthis._createCubicSplineTrackInterpolant( track );\n\n\t\t\t}\n\n\t\t\ttracks.push( track );\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\t_getArrayFromAccessor( accessor ) {\n\n\t\tlet outputArray = accessor.array;\n\n\t\tif ( accessor.normalized ) {\n\n\t\t\tconst scale = getNormalizedComponentScale( outputArray.constructor );\n\t\t\tconst scaled = new Float32Array( outputArray.length );\n\n\t\t\tfor ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {\n\n\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\n\n\t\t\t}\n\n\t\t\toutputArray = scaled;\n\n\t\t}\n\n\t\treturn outputArray;\n\n\t}\n\n\t_createCubicSplineTrackInterpolant( track ) {\n\n\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\tconst interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\n\n\t\t\treturn new interpolantType( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t};\n\n\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t}\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst box = new Box3();\n\n\tif ( attributes.POSITION !== undefined ) {\n\n\t\tconst accessor = parser.json.accessors[ attributes.POSITION ];\n\n\t\tconst min = accessor.min;\n\t\tconst max = accessor.max;\n\n\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\tbox.set(\n\t\t\t\tnew Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\n\t\t\t\tnew Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )\n\t\t\t);\n\n\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\tbox.min.multiplyScalar( boxScale );\n\t\t\t\tbox.max.multiplyScalar( boxScale );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\treturn;\n\n\t\t}\n\n\t} else {\n\n\t\treturn;\n\n\t}\n\n\tconst targets = primitiveDef.targets;\n\n\tif ( targets !== undefined ) {\n\n\t\tconst maxDisplacement = new Vector3();\n\t\tconst vector = new Vector3();\n\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tconst target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\tconst accessor = parser.json.accessors[ target.POSITION ];\n\t\t\t\tconst min = accessor.min;\n\t\t\t\tconst max = accessor.max;\n\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\n\n\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\n\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\n\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\n\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\n\n\n\t\t\t\t\tif ( accessor.normalized ) {\n\n\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\n\t\t\t\t\t\tvector.multiplyScalar( boxScale );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\n\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n\t\t\t\t\tmaxDisplacement.max( vector );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n\t\tbox.expandByVector( maxDisplacement );\n\n\t}\n\n\tgeometry.boundingBox = box;\n\n\tconst sphere = new Sphere();\n\n\tbox.getCenter( sphere.center );\n\tsphere.radius = box.min.distanceTo( box.max ) / 2;\n\n\tgeometry.boundingSphere = sphere;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\n\n\tconst attributes = primitiveDef.attributes;\n\n\tconst pending = [];\n\n\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\n\n\t\treturn parser.getDependency( 'accessor', accessorIndex )\n\t\t\t.then( function ( accessor ) {\n\n\t\t\t\tgeometry.setAttribute( attributeName, accessor );\n\n\t\t\t} );\n\n\t}\n\n\tfor ( const gltfAttributeName in attributes ) {\n\n\t\tconst threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\n\n\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\n\n\t}\n\n\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\tconst accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\n\n\t\t\tgeometry.setIndex( accessor );\n\n\t\t} );\n\n\t\tpending.push( accessor );\n\n\t}\n\n\tif ( ColorManagement.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in attributes ) {\n\n\t\tconsole.warn( `THREE.GLTFLoader: Converting vertex colors from \"srgb-linear\" to \"${ColorManagement.workingColorSpace}\" not supported.` );\n\n\t}\n\n\tassignExtrasToUserData( geometry, primitiveDef );\n\n\tcomputeBounds( geometry, primitiveDef, parser );\n\n\treturn Promise.all( pending ).then( function () {\n\n\t\treturn primitiveDef.targets !== undefined\n\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\n\t\t\t: geometry;\n\n\t} );\n\n}\n\nexport { GLTFLoader };\n"],
  "mappings": "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",
  "names": ["_assign", "ReactDebugCurrentFrame", "self", "import_react", "import_prop_types", "getIdForObject", "len", "actuallySet", "tween", "React", "T", "self", "res", "sourceURI", "node", "accessor", "React", "T", "xrSession"]
}
