import {
  Canvas3D,
  CircleFacade,
  Group3DFacade,
  MeshFacade,
  MultiTween,
  Object3DFacade,
  PerspectiveCamera3DFacade,
  Runner,
  SpringTween,
  Tween,
  World3DFacade,
  setAnimationScheduler
} from "./chunk-G2LT4ZHJ.js";
import {
  require_checkPropTypes,
  require_object_assign,
  require_prop_types
} from "./chunk-IEZNACBM.js";
import {
  createDerivedMaterial,
  invertMatrix4
} from "./chunk-WHW3KZEO.js";
import {
  AnimationClip,
  Bone,
  Box3,
  BufferAttribute,
  BufferGeometry,
  ClampToEdgeWrapping,
  Color,
  ColorManagement,
  CylinderGeometry,
  DirectionalLight,
  DoubleSide,
  DynamicDrawUsage,
  Euler,
  ExtrudeGeometry,
  FileLoader,
  FrontSide,
  Group,
  ImageBitmapLoader,
  InstancedBufferAttribute,
  InstancedMesh,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  Interpolant,
  InterpolateDiscrete,
  InterpolateLinear,
  Line,
  LineBasicMaterial,
  LineLoop,
  LineSegments,
  LinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearSRGBColorSpace,
  Loader,
  LoaderUtils,
  Material,
  MathUtils,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MirroredRepeatWrapping,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NumberKeyframeTrack,
  Object3D,
  OrthographicCamera,
  Path,
  PerspectiveCamera,
  Plane,
  PointLight,
  Points,
  PointsMaterial,
  PropertyBinding,
  Quaternion,
  QuaternionKeyframeTrack,
  Ray,
  RepeatWrapping,
  SRGBColorSpace,
  ShaderMaterial,
  Shape,
  Skeleton,
  SkinnedMesh,
  Sphere,
  SphereGeometry,
  SpotLight,
  Texture,
  TextureLoader,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  Vector2,
  Vector3,
  Vector4,
  VectorKeyframeTrack
} from "./chunk-67OUPF4S.js";
import {
  __commonJS,
  __toESM
} from "./chunk-LQ2VYIYD.js";

// node_modules/troika-xr/node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/troika-xr/node_modules/react/cjs/react.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var _assign2 = require_object_assign();
        var checkPropTypes = require_checkPropTypes();
        var ReactVersion = "16.14.0";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          suspense: null
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
        function describeComponentFrame(name, source, ownerName) {
          var sourceInfo = "";
          if (source) {
            var path = source.fileName;
            var fileName = path.replace(BEFORE_SLASH_RE, "");
            {
              if (/^index\./.test(fileName)) {
                var match = path.match(BEFORE_SLASH_RE);
                if (match) {
                  var pathBeforeSlash = match[1];
                  if (pathBeforeSlash) {
                    var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
                    fileName = folderName + "/" + fileName;
                  }
                }
              }
            }
            sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
          } else if (ownerName) {
            sourceInfo = " (created by " + ownerName + ")";
          }
          return "\n    in " + (name || "Unknown") + sourceInfo;
        }
        var Resolved = 1;
        function refineResolvedLazyComponent(lazyComponent) {
          return lazyComponent._status === Resolved ? lazyComponent._result : null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                return "Context.Consumer";
              case REACT_PROVIDER_TYPE:
                return "Context.Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type.render);
              case REACT_LAZY_TYPE: {
                var thenable = type;
                var resolvedThenable = refineResolvedLazyComponent(thenable);
                if (resolvedThenable) {
                  return getComponentName(resolvedThenable);
                }
                break;
              }
            }
          }
          return null;
        }
        var ReactDebugCurrentFrame = {};
        var currentlyValidatingElement = null;
        function setCurrentlyValidatingElement(element) {
          {
            currentlyValidatingElement = element;
          }
        }
        {
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentlyValidatingElement) {
              var name = getComponentName(currentlyValidatingElement.type);
              var owner = currentlyValidatingElement._owner;
              stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var IsSomeRendererActing = {
          current: false
        };
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
          IsSomeRendererActing,
          // Used by renderers to avoid bundling object-assign twice in UMD bundles:
          assign: _assign2
        };
        {
          _assign2(ReactSharedInternals, {
            // These should not be included in production.
            ReactDebugCurrentFrame,
            // Shim for React DOM 16.0.0 which still destructured (but not used) this.
            // TODO: remove in React 17.0.
            ReactComponentTreeHook: {}
          });
        }
        function warn(format) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
        function error(format) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
        function printWarning(level, format, args) {
          {
            var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === "string" && args[args.length - 1].indexOf("\n    in") === 0;
            if (!hasExistingStack) {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
            try {
              var argIndex = 0;
              var message = "Warning: " + format.replace(/%s/g, function() {
                return args[argIndex++];
              });
              throw new Error(message);
            } catch (x) {
            }
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
            {
              throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        _assign2(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://fb.me/react-strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (!!(element === null || element === void 0)) {
            {
              throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
          }
          var propName;
          var props = _assign2({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = ("" + key).replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return ("" + text).replace(userProvidedKeyEscapeRegex, "$&/");
        }
        var POOL_SIZE = 10;
        var traverseContextPool = [];
        function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
          if (traverseContextPool.length) {
            var traverseContext = traverseContextPool.pop();
            traverseContext.result = mapResult;
            traverseContext.keyPrefix = keyPrefix;
            traverseContext.func = mapFunction;
            traverseContext.context = mapContext;
            traverseContext.count = 0;
            return traverseContext;
          } else {
            return {
              result: mapResult,
              keyPrefix,
              func: mapFunction,
              context: mapContext,
              count: 0
            };
          }
        }
        function releaseTraverseContext(traverseContext) {
          traverseContext.result = null;
          traverseContext.keyPrefix = null;
          traverseContext.func = null;
          traverseContext.context = null;
          traverseContext.count = 0;
          if (traverseContextPool.length < POOL_SIZE) {
            traverseContextPool.push(traverseContext);
          }
        }
        function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            callback(
              traverseContext,
              children,
              // If it's the only child, treat the name as if it was wrapped in an array
              // so that it's consistent if the number of children grows.
              nameSoFar === "" ? SEPARATOR + getComponentKey(children, 0) : nameSoFar
            );
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getComponentKey(child, i);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              {
                if (iteratorFn === children.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is deprecated and will be removed in a future major release. Consider converting children to an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(children);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getComponentKey(child, ii++);
                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
              }
            } else if (type === "object") {
              var addendum = "";
              {
                addendum = " If you meant to render a collection of children, use an array instead." + ReactDebugCurrentFrame.getStackAddendum();
              }
              var childrenString = "" + children;
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + ")." + addendum);
                }
              }
            }
          }
          return subtreeCount;
        }
        function traverseAllChildren(children, callback, traverseContext) {
          if (children == null) {
            return 0;
          }
          return traverseAllChildrenImpl(children, "", callback, traverseContext);
        }
        function getComponentKey(component, index) {
          if (typeof component === "object" && component !== null && component.key != null) {
            return escape(component.key);
          }
          return index.toString(36);
        }
        function forEachSingleChild(bookKeeping, child, name) {
          var func = bookKeeping.func, context = bookKeeping.context;
          func.call(context, child, bookKeeping.count++);
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          if (children == null) {
            return children;
          }
          var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
          traverseAllChildren(children, forEachSingleChild, traverseContext);
          releaseTraverseContext(traverseContext);
        }
        function mapSingleChildIntoContext(bookKeeping, child, childKey) {
          var result = bookKeeping.result, keyPrefix = bookKeeping.keyPrefix, func = bookKeeping.func, context = bookKeeping.context;
          var mappedChild = func.call(context, child, bookKeeping.count++);
          if (Array.isArray(mappedChild)) {
            mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function(c) {
              return c;
            });
          } else if (mappedChild != null) {
            if (isValidElement(mappedChild)) {
              mappedChild = cloneAndReplaceKey(
                mappedChild,
                // Keep both the (mapped) and old keys if they differ, just as
                // traverseAllChildren used to do for objects as children
                keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + "/" : "") + childKey
              );
            }
            result.push(mappedChild);
          }
        }
        function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
          var escapedPrefix = "";
          if (prefix != null) {
            escapedPrefix = escapeUserProvidedKey(prefix) + "/";
          }
          var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
          traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
          releaseTraverseContext(traverseContext);
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          mapIntoWithKeyPrefixInternal(children, result, null, func, context);
          return result;
        }
        function countChildren(children) {
          return traverseAllChildren(children, function() {
            return null;
          }, null);
        }
        function toArray(children) {
          var result = [];
          mapIntoWithKeyPrefixInternal(children, result, null, function(child) {
            return child;
          });
          return result;
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            {
              throw Error("React.Children.only expected to receive a single React element child.");
            }
          }
          return children;
        }
        function createContext(defaultValue, calculateChangedBits) {
          if (calculateChangedBits === void 0) {
            calculateChangedBits = null;
          } else {
            {
              if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
              }
            }
          }
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
              _calculateChangedBits: context._calculateChangedBits
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        function lazy(ctor) {
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _ctor: ctor,
            // React uses these fields to store the result.
            _status: -1,
            _result: null
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          return {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
        }
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          return {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (!(dispatcher !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context, unstable_observedBits) {
          var dispatcher = resolveDispatcher();
          {
            if (unstable_observedBits !== void 0) {
              error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://fb.me/rules-of-hooks" : "");
            }
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context, unstable_observedBits);
        }
        function useState(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement(element);
          {
            error('Each child in a list should have a unique "key" prop.%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
          }
          setCurrentlyValidatingElement(null);
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var name = getComponentName(type);
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              setCurrentlyValidatingElement(element);
              checkPropTypes(propTypes, element.props, "prop", name, ReactDebugCurrentFrame.getStackAddendum);
              setCurrentlyValidatingElement(null);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            setCurrentlyValidatingElement(fragment);
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                break;
              }
            }
            if (fragment.ref !== null) {
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
            }
            setCurrentlyValidatingElement(null);
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (Array.isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        {
          try {
            var frozenObject = Object.freeze({});
            var testMap = /* @__PURE__ */ new Map([[frozenObject, null]]);
            var testSet = /* @__PURE__ */ new Set([frozenObject]);
            testMap.set(0, 0);
            testSet.add(0);
          } catch (e) {
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useEffect = useEffect;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/troika-xr/node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/troika-xr/node_modules/react/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/troika-xr/dist/troika-xr.esm.js
var import_react2 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());

// node_modules/troika-xr/node_modules/troika-core/dist/troika-core.esm.js
var import_react = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var assign = Object.assign || _assign;
function _assign() {
  let target = arguments[0];
  for (let i = 1, len = arguments.length; i < len; i++) {
    let source = arguments[i];
    if (source) {
      for (let prop in source) {
        if (source.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
  }
  return target;
}
function assignIf() {
  let target = arguments[0];
  for (let i = 1, len = arguments.length; i < len; i++) {
    let source = arguments[i];
    if (source) {
      for (let prop in source) {
        if (source.hasOwnProperty(prop) && !target.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
  }
  return target;
}
function assignDeep(target, source) {
  if (source) {
    for (let prop in source) {
      if (source.hasOwnProperty(prop)) {
        if (target[prop] && typeof target[prop] === "object" && typeof source[prop] === "object") {
          assignDeep(target[prop], source[prop]);
        } else {
          target[prop] = source[prop];
        }
      }
    }
  }
}
function forOwn(object, fn, scope) {
  for (let prop in object) {
    if (object.hasOwnProperty(prop)) {
      fn.call(scope, object[prop], prop, object);
    }
  }
}
var getIdForObject = /* @__PURE__ */ (() => {
  let objIds = /* @__PURE__ */ new WeakMap();
  let lastId = 0;
  return function getIdForObject2(obj) {
    let id = objIds.get(obj);
    if (!id) {
      objIds.set(obj, id = `$id${++lastId}`);
    }
    return id;
  };
})();
function memoize(fn) {
  let prevArgs, prevThis, prevResult;
  return function() {
    let changed = !prevArgs || this !== prevThis || arguments.length !== prevArgs.length;
    if (!changed) {
      for (let i = 0, len = arguments.length; i < len; i++) {
        if (arguments[i] !== prevArgs[i]) {
          changed = true;
          break;
        }
      }
    }
    if (changed) {
      prevArgs = Array.prototype.slice.call(arguments);
      prevThis = this;
      prevResult = fn.apply(this, arguments);
    }
    return prevResult;
  };
}
function createClassExtender(name, doExtend) {
  const cache = /* @__PURE__ */ new WeakMap();
  return function(classToExtend) {
    let extended = cache.get(classToExtend);
    if (!extended) {
      extended = doExtend(classToExtend);
      cache.set(classToExtend, extended);
    }
    return extended;
  };
}
function isReactElement(obj) {
  const t = obj.$$typeof;
  return t && t.toString && t.toString() === "Symbol(react.element)" || false;
}
var utils = Object.freeze({
  __proto__: null,
  assign,
  _assign,
  assignIf,
  assignDeep,
  forOwn,
  getIdForObject,
  memoize,
  createClassExtender,
  isReactElement
});
var Facade = class _Facade {
  constructor(parent) {
    this.$facadeId = `facade${idCounter++}`;
    this.parent = parent;
  }
  /**
   * Performs a manual update of this facade, invoking the afterUpdate lifecycle method and triggering a
   * render. This can be called in event handlers, for example, to affect changes to this facade and its
   * subtree. This process is synchronous. Never override this method as a way to react to updates, as it
   * is not the only way a component is updated; instead override `afterUpdate` or use setters.
   * @param {object} [props] - A set of properties to be copied to the facade
   */
  update(props) {
    if (props && typeof props === "object") {
      this.transition = props.transition;
      this.animation = props.animation;
      for (let prop in props) {
        if (props.hasOwnProperty(prop) && !_Facade.isSpecialDescriptorProperty(prop)) {
          this[prop] = props[prop];
        }
      }
    }
    this.afterUpdate();
    this.requestRender();
  }
  /**
   * Called at the end of an update batch, after all individual properties have been assigned.
   */
  afterUpdate() {
    let ref = this.ref;
    if (ref !== this._lastRef) {
      if (typeof this._lastRef === "function") {
        this._lastRef.call(null, null);
      }
      if (typeof ref === "function") {
        ref.call(null, this);
        this._lastRef = ref;
      } else {
        this._lastRef = null;
      }
    }
  }
  /**
   * Dispatch a message with optional data up the facade parent tree.
   */
  notifyWorld(message, data) {
    if (this.parent) {
      this.parent.onNotifyWorld(this, message, data);
    }
  }
  /**
   * Default onNotifyWorld handler just bubbles it up the parent chain.
   */
  onNotifyWorld(source, message, data) {
    let notifiableParent = this._notifiableParent;
    if (notifiableParent) {
      notifiableParent.onNotifyWorld.call(notifiableParent, source, message, data);
    } else {
      notifiableParent = this.parent;
      let defaultImpl = _Facade.prototype.onNotifyWorld;
      while (notifiableParent) {
        if (notifiableParent.onNotifyWorld !== defaultImpl) {
          this._notifiableParent = notifiableParent;
          notifiableParent.onNotifyWorld(source, message, data);
          break;
        }
        notifiableParent = notifiableParent.parent;
      }
    }
  }
  /**
   * Notifies the top-level world manager that this object has changed in some way that affects its
   * visible rendering, so a rendering frame will be scheduled.
   */
  requestRender() {
    this.notifyWorld("needsRender");
  }
  traverse(fn) {
    fn(this);
  }
  forEachChild(fn) {
  }
  /**
   * Add an event listener for the given event type.
   * @param {String} type
   * @param {Function} handler
   */
  addEventListener(type, handler) {
    this.notifyWorld("addEventListener", { type, handler });
  }
  /**
   * Remove an event listener for the given event type.
   * @param {String} type
   * @param {Function} handler
   */
  removeEventListener(type, handler) {
    this.notifyWorld("removeEventListener", { type, handler });
  }
  /**
   * Dispatch an Event object on this facade, with DOM events bubbling logic.
   * @param {Event} event
   */
  dispatchEvent(event) {
    this.notifyWorld("dispatchEvent", event);
  }
  /**
   * Called when the instance is being removed from the scene. Override this to implement any
   * custom cleanup logic.
   */
  destructor() {
    if (this.parent) {
      this.notifyWorld("removeAllEventListeners");
    }
    if (typeof this.ref === "function") {
      this.ref.call(null, null);
    }
    this.parent = this._notifiableParent = null;
  }
};
assign(Facade.prototype, {
  ref: null,
  _lastRef: null,
  _notifiableParent: null
});
var idCounter = 0;
var DEF_SPECIAL_PROPS = { key: 1, facade: 1, transition: 1, animation: 1 };
Facade.isSpecialDescriptorProperty = function(name) {
  return DEF_SPECIAL_PROPS.hasOwnProperty(name);
};
Facade.defineEventProperty = function(facadeClass, propName, eventType) {
  let privateProp = `${propName}handler`;
  Object.defineProperty(facadeClass.prototype, propName, {
    get() {
      return this[privateProp];
    },
    set(handler) {
      const oldHandler = this[privateProp];
      if ((handler || null) !== (oldHandler || null)) {
        if (typeof oldHandler === "function") {
          this.removeEventListener(eventType, oldHandler);
        }
        if (typeof handler === "function") {
          this.addEventListener(eventType, handler);
        }
        this[privateProp] = handler;
      }
    }
  });
};
var DEFAULT_DURATION = 750;
var DEFAULT_EASING = "easeOutCubic";
var TEMP_ARRAY = [null];
function animationIdJsonReplacer(key, value) {
  return key === "paused" ? void 0 : value === Infinity ? "Infinity" : value;
}
function compareByTime(a, b) {
  return a.time - b.time;
}
var extendAsAnimatable = createClassExtender("animatable", function(BaseFacadeClass) {
  class AnimatableFacade extends BaseFacadeClass {
    constructor(...args) {
      super(...args);
      this.animation$runner = new Runner();
      this.animation$runner.onTick = () => {
        this.afterUpdate();
        this.requestRender();
      };
    }
    /**
     * Handle the special "transition" property. The descriptor should be an object with
     * transitionable property names as keys and transition parameters as values. The
     * transition parameters can either be objects describing the transition parameters,
     * or `true` for a default transition.
     *
     *   transition: {
     *     x: true, // uses a default duration-based transition
     *     y: 'spring', //uses a default spring-based transition
     *     z: {
     *       // ...custom transition config
     *     }
     *   }
     *
     * The custom transition config object can take one of two forms for duration- vs.
     * spring-based animations:
     *
     * Duration-based:
     *
     *   {
     *     duration: n, //in ms, defaults to 750
     *     easing: e, //easing function, defaults to 'easeOutCubic'
     *     delay: n, //in ms, defaults to 0
     *     interpolate: 'number' //one of the builtin named interpolators ('number', 'color', etc.) or a custom Function
     *   }
     *
     * Spring-based:
     *
     *   {
     *     spring: s, //either `true`, a named preset string e.g. "wobbly", or an object with {mass, tension, friction}
     *     delay: n //in ms, defaults to 0
     *   }
     *
     * Note that spring-based transitions do not currently support custom interpolations so they should only be used
     * for numeric values.
     */
    set transition(descriptor) {
      if (descriptor) {
        for (let propName in descriptor) {
          if (descriptor.hasOwnProperty(propName)) {
            defineTransitionPropInterceptor(propName, this);
          }
        }
      }
      this.transition$descriptor = descriptor;
    }
    get transition() {
      return this.transition$descriptor;
    }
    /**
     * Handle the special "animation" property. The descriptor should be an object or array
     * of objects defining a set of keyframes and their playback parameters. Keyframes are
     * defined by numeric keys from 0 to 100, each defining an object with the target
     * property values for that keyframe.
     *
     *   animation: [{
     *     0: {rotateZ: 0, color: 0x000000}, //can also use key "from"
     *     100: {rotateZ: Math.PI * 2, color: 0xffffff}, //can also use key "to"
     *     delay: 0, //starting delay in ms
     *     duration: 2000, //total anim duration in ms, defaults to 750
     *     easing: 'linear', //easing for the whole animation, defaults to 'linear'
     *     iterations: 5, //number of times to loop the animation, defaults to 1. Set to Infinity for endless loop.
     *     direction: 'forward', //either 'forward', 'backward', or 'alternate'
     *     interpolate: {color: 'color'}, //mapping of property names to Interpolators.js names or custom functions
     *     paused: false //if true the animation will be paused at its current position until set back to false
     *   }, ...]
     *
     * Internally the animations will be built into a set of nested tweens:
     *
     * |--------------------------- Main MultiTween ------------------------------------|
     *
     * |------------- Anim 1 MultiTween w/ easing+repeat ----------------|
     * |--- prop1 tween 1 ---|--- prop1 tween 2 ---|--- prop1 tween 3 ---|
     * |--------- prop2 tween 1 --------|--------- prop2 tween 2 --------|
     *
     *                    delay -->|-------- Anim 2 MultiTween w/ easing+repeat --------|
     *                             |----- prop3 tween 1 -----|----- prop3 tween 2 ------|
     *                             |------------------- prop4 tween --------------------|
     *                                            |----------- prop5 tween -------------|
     */
    set animation(descriptor) {
      if (this.animation$descriptor === descriptor)
        return;
      this.animation$descriptor = descriptor;
      let oldAnimTweens = this.animation$tweens || null;
      let newAnimTweens = this.animation$tweens = descriptor ? /* @__PURE__ */ Object.create(null) : null;
      let runner = this.animation$runner;
      let hasChanged = false;
      if (descriptor && !Array.isArray(descriptor)) {
        TEMP_ARRAY[0] = descriptor;
        descriptor = TEMP_ARRAY;
      }
      if (descriptor) {
        for (let i = 0, len = descriptor.length; i < len; i++) {
          let animDesc = descriptor[i];
          if (!animDesc)
            continue;
          let animId = JSON.stringify(animDesc, animationIdJsonReplacer);
          if (oldAnimTweens && animId in oldAnimTweens) {
            let tween = oldAnimTweens[animId];
            if (animDesc.paused) {
              runner.pause(tween);
            } else {
              runner.start(tween);
            }
            newAnimTweens[animId] = tween;
          } else {
            let delay = 0;
            let duration = DEFAULT_DURATION;
            let easing = "linear";
            let iterations = 1;
            let keyframes = [];
            let direction = "forward";
            for (let key in animDesc) {
              if (animDesc.hasOwnProperty(key)) {
                switch (key) {
                  case "duration":
                    duration = animDesc[key];
                    break;
                  case "delay":
                    delay = animDesc[key];
                    break;
                  case "easing":
                    easing = animDesc[key];
                    break;
                  case "iterations":
                    iterations = animDesc[key];
                    break;
                  case "direction":
                    direction = animDesc[key];
                    break;
                  default: {
                    let percent = key === "from" ? 0 : key === "to" ? 100 : parseFloat(key);
                    if (!isNaN(percent) && percent >= 0 && percent <= 100) {
                      keyframes.push({ time: percent / 100, props: animDesc[key] });
                      for (let animProp in animDesc[key]) {
                        if (animDesc[key].hasOwnProperty(animProp)) {
                          defineTransitionPropInterceptor(animProp, this);
                          let tweenKey = animProp + "anim:tween";
                          if (this[tweenKey]) {
                            runner.stop(this[tweenKey]);
                            this[tweenKey] = null;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (keyframes.length) {
              keyframes.sort(compareByTime);
              if (keyframes[0].time > 0) {
                keyframes.unshift(assignIf({ time: 0 }, keyframes[0]));
              }
              let keyframePropTweens = [];
              for (let j = 1, len2 = keyframes.length; j < len2; j++) {
                let keyframe = keyframes[j];
                let props = keyframe.props;
                for (let prop in props) {
                  if (props.hasOwnProperty(prop)) {
                    let prevKeyframe = null;
                    for (let k = j; k--; ) {
                      if (prop in keyframes[k].props) {
                        prevKeyframe = keyframes[k];
                        break;
                      }
                    }
                    if (prevKeyframe) {
                      let propTween = new Tween(
                        this[prop + "anim:actuallySet"].bind(this),
                        //callback
                        prevKeyframe.props[prop],
                        //fromValue
                        props[prop],
                        //toValue
                        (keyframe.time - prevKeyframe.time) * duration,
                        //duration
                        prevKeyframe.time * duration,
                        //delay
                        "linear",
                        //easing
                        1,
                        //iterations
                        "forward",
                        //direction
                        animDesc.interpolate && animDesc.interpolate[prop] || "number"
                      );
                      propTween.$$property = prop;
                      keyframePropTweens.push(propTween);
                    }
                  }
                }
              }
              let tween = newAnimTweens[animId] = new MultiTween(keyframePropTweens, duration, delay, easing, iterations, direction);
              if (!animDesc.paused) {
                runner.start(tween);
              }
              if (delay === 0) {
                let firstKeyframeProps = keyframes[0].props;
                for (let prop in firstKeyframeProps) {
                  if (firstKeyframeProps.hasOwnProperty(prop)) {
                    this[prop + "anim:actuallySet"](firstKeyframeProps[prop]);
                  }
                }
              }
            }
            hasChanged = true;
          }
        }
      }
      if (oldAnimTweens) {
        for (let animId in oldAnimTweens) {
          if (!newAnimTweens || !newAnimTweens[animId]) {
            let tween = oldAnimTweens[animId];
            tween.gotoEnd();
            runner.stop(tween);
            hasChanged = true;
          }
        }
      }
      if (hasChanged) {
        if (newAnimTweens) {
          let animatingProps = this.animation$animatingProps = /* @__PURE__ */ Object.create(null);
          for (let animId in newAnimTweens) {
            let propTweens = newAnimTweens[animId].tweens;
            for (let i = propTweens.length; i--; ) {
              animatingProps[propTweens[i].$$property] = true;
            }
          }
        } else {
          this.animation$animatingProps = null;
        }
      }
    }
    get animation() {
      return this.animation$descriptor;
    }
    destructor() {
      const runner = this.animation$runner;
      if (this.exitAnimation && !this.parent.isDestroying) {
        runner.stopAll();
        this.animation = this.exitAnimation;
        this.exitAnimation = this.transition = null;
        const onTick = runner.onTick;
        runner.onTick = () => {
          if (this.parent && !this.parent.isDestroying) {
            onTick();
          } else {
            runner.onDone = null;
            this.destructor();
          }
        };
        runner.onDone = () => {
          this.requestRender();
          this.destructor();
        };
      } else {
        runner.destructor();
        super.destructor();
      }
    }
  }
  function defineTransitionPropInterceptor(propName, currentInstance) {
    if (!AnimatableFacade.prototype.hasOwnProperty(propName)) {
      let actualValueKey = `${propName}anim:actualValue`;
      let actuallySetKey = `${propName}anim:actuallySet`;
      let hasBeenSetKey = `${propName}anim:hasBeenSet`;
      let activeTweenKey = `${propName}anim:tween`;
      let superGetter, superSetter;
      let proto = BaseFacadeClass.prototype;
      while (proto) {
        let desc = Object.getOwnPropertyDescriptor(proto, propName);
        if (desc) {
          superSetter = desc.set;
          superGetter = desc.get;
          if (superSetter && !superGetter || superGetter && !superSetter) {
            throw new Error(`Animatable: property ${propName} has a custom ${superSetter ? "setter" : "getter"} but no ${superSetter ? "getter" : "setter"}. Animatable properties must have both.`);
          }
          break;
        }
        proto = Object.getPrototypeOf(proto);
      }
      let actuallySet = superSetter ? function actuallySet2(value) {
        superSetter.call(this, value);
        if (!this[hasBeenSetKey]) {
          this[hasBeenSetKey] = true;
        }
      } : function actuallySet2(value) {
        this[actualValueKey] = value;
        if (!this[hasBeenSetKey]) {
          this[hasBeenSetKey] = true;
        }
      };
      Object.defineProperty(AnimatableFacade.prototype, actuallySetKey, { value: actuallySet });
      Object.defineProperty(AnimatableFacade.prototype, propName, {
        get() {
          return superGetter ? superGetter.call(this) : this[hasBeenSetKey] ? this[actualValueKey] : BaseFacadeClass.prototype[propName];
        },
        set(value) {
          if (this.animation$animatingProps && this.animation$animatingProps[propName]) {
            return;
          }
          let runner = this.animation$runner;
          let transition = this.transition;
          if (transition && transition[propName] && this[hasBeenSetKey] && transition.hasOwnProperty(propName)) {
            transition = transition[propName];
            let springConfig = transition === "spring" ? "default" : transition.spring;
            let tween2 = this[activeTweenKey];
            let needsNewTween = false;
            if (tween2) {
              if (value !== tween2.toValue) {
                if (springConfig && tween2.isSpring) {
                  tween2.toValue = value;
                } else {
                  runner.stop(tween2);
                  needsNewTween = true;
                }
              }
            } else if (value !== this[propName]) {
              needsNewTween = true;
            }
            if (needsNewTween) {
              tween2 = this[activeTweenKey] = springConfig ? new SpringTween(
                actuallySet.bind(this),
                //callback
                this[propName],
                //fromValue
                value,
                //toValue
                springConfig,
                //springConfig (mass, friction, tension)
                0,
                //initialVelocity
                transition.delay || 0
                //delay
              ) : new Tween(
                actuallySet.bind(this),
                //callback
                this[propName],
                //fromValue
                value,
                //toValue
                transition.duration || DEFAULT_DURATION,
                //duration
                transition.delay || 0,
                //delay
                transition.easing || DEFAULT_EASING,
                //easing
                1,
                //iterations
                "forward",
                //direction
                transition.interpolate || "number"
                //interpolate
              );
              tween2.onDone = () => {
                tween2 = this[activeTweenKey] = null;
              };
              runner.start(tween2);
            }
            return;
          }
          actuallySet.call(this, value);
          let tween = this[activeTweenKey];
          if (tween)
            runner.stop(tween);
          this[activeTweenKey] = null;
        }
      });
    }
    if (currentInstance.hasOwnProperty(propName)) {
      currentInstance[`${propName}anim:actualValue`] = currentInstance[propName];
      currentInstance[`${propName}anim:hasBeenSet`] = true;
      delete currentInstance[propName];
    }
  }
  return AnimatableFacade;
});
var extendAsPointerStatesAware = createClassExtender("pointerStates", function(BaseFacadeClass) {
  const isHoveringProp = "pntr:isHovering";
  const isActiveProp = "pntr:isActive";
  const propsWithInterceptors = /* @__PURE__ */ Object.create(null);
  class PointerStatesAware extends BaseFacadeClass {
    constructor(parent) {
      super(parent);
      this.addEventListener("mouseover", hoverOverHandler);
      this.addEventListener("mouseout", hoverOutHandler);
      this.addEventListener("mousedown", activeDownHandler);
      this.addEventListener("mouseup", activeUpHandler);
    }
    afterUpdate() {
      this._applyPointerStates();
      super.afterUpdate();
    }
    _applyPointerStates() {
      const pointerStates = this.pointerStates;
      const hoverValuesToUse = pointerStates && this[isHoveringProp] && pointerStates.hover || null;
      const activeValuesToUse = pointerStates && this[isActiveProp] && pointerStates.active || null;
      const lastAppliedValues = this["pntr:lastAppliedValues"] || propsWithInterceptors;
      const appliedValues = this["pntr:lastAppliedValues"] = hoverValuesToUse || activeValuesToUse ? assign(/* @__PURE__ */ Object.create(null), hoverValuesToUse, activeValuesToUse) : null;
      if (appliedValues) {
        for (let prop in appliedValues) {
          definePropInterceptor(prop, this);
          actuallySet(this, prop, appliedValues[prop]);
        }
      }
      if (lastAppliedValues) {
        for (let prop in lastAppliedValues) {
          if (!appliedValues || !(prop in appliedValues)) {
            actuallySet(this, prop, this[`${prop}pntr:baseValue`]);
          }
        }
      }
    }
  }
  Object.defineProperty(PointerStatesAware.prototype, "isPointerStateAware", { value: true });
  function definePropInterceptor(propName, currentInstance) {
    const hasBeenSetProp = `${propName}pntr:hasBeenSet`;
    if (!currentInstance[hasBeenSetProp]) {
      currentInstance[`${propName}pntr:baseValue`] = currentInstance[propName];
      delete currentInstance[propName];
      currentInstance[hasBeenSetProp] = true;
    }
    if (!PointerStatesAware.prototype.hasOwnProperty(propName)) {
      propsWithInterceptors[propName] = 1;
      const baseValueProp = `${propName}pntr:baseValue`;
      const appliedValueProp = `${propName}pntr:appliedValue`;
      Object.defineProperty(PointerStatesAware.prototype, propName, {
        get() {
          const superGetter = getSuperGetter(propName);
          return superGetter ? superGetter.call(this) : appliedValueProp in this ? this[appliedValueProp] : this[baseValueProp];
        },
        set(value) {
          this[baseValueProp] = value;
        }
      });
    }
  }
  function actuallySet(instance, propName, value) {
    const superSetter = getSuperSetter(propName);
    if (superSetter) {
      superSetter.call(instance, value);
    } else {
      instance[`${propName}pntr:appliedValue`] = value;
    }
  }
  function getSuperGetter(propName) {
    let proto = BaseFacadeClass.prototype;
    if (propName in proto) {
      while (proto) {
        let desc = Object.getOwnPropertyDescriptor(proto, propName);
        if (desc && desc.get) {
          return desc.get;
        }
        proto = Object.getPrototypeOf(proto);
      }
    }
    return null;
  }
  function getSuperSetter(propName) {
    let proto = BaseFacadeClass.prototype;
    if (propName in proto) {
      while (proto) {
        let desc = Object.getOwnPropertyDescriptor(proto, propName);
        if (desc && desc.set) {
          return desc.set;
        }
        proto = Object.getPrototypeOf(proto);
      }
    }
    return null;
  }
  function hoverOverHandler(e) {
    e.currentTarget[isHoveringProp] = true;
    afterPointerStateChange(e);
  }
  function hoverOutHandler(e) {
    e.currentTarget[isHoveringProp] = e.currentTarget[isActiveProp] = false;
    afterPointerStateChange(e);
  }
  function activeDownHandler(e) {
    e.currentTarget[isActiveProp] = true;
    afterPointerStateChange(e);
  }
  function activeUpHandler(e) {
    e.currentTarget[isActiveProp] = false;
    afterPointerStateChange(e);
  }
  function afterPointerStateChange(e) {
    let highestFacade = e.currentTarget;
    let parent = highestFacade.parent;
    while (parent && parent.shouldUpdateChildren()) {
      if (parent.isPointerStateAware) {
        highestFacade = parent;
      }
      parent = parent.parent;
    }
    highestFacade.afterUpdate();
    highestFacade.requestRender();
  }
  return PointerStatesAware;
});
var TEMP_ARRAY$1 = [null];
var ParentFacade = class extends Facade {
  constructor(parent) {
    super(parent);
    this.children = null;
    this._orderedChildKeys = [];
  }
  afterUpdate() {
    if (this.shouldUpdateChildren()) {
      this.updateChildren(this.describeChildren());
    }
    super.afterUpdate();
  }
  /**
   * Return the descriptor(s) for the actual children to be created and managed. By default
   * this simply returns the value of the `children` property set by the parent, but you can
   * override it to customize how the child content should be structured, for instance to wrap
   * the `children` within a deeper structure, add in anonymous child siblings, or modify the
   * `children` configurations.
   * @protected
   * @return {FacadeDescriptor | Array<FacadeDescriptor>}
   */
  describeChildren() {
    return this.children;
  }
  /**
   * Override to selectively prevent traversing to child nodes on `afterUpdate`, for
   * potential performance gain.
   * @returns {boolean}
   */
  shouldUpdateChildren() {
    return true;
  }
  updateChildren(children) {
    const oldDict = this._childrenDict || null;
    let newDict = this._childrenDict = null;
    const orderedChildKeys = this._orderedChildKeys;
    orderedChildKeys.length = 0;
    if (children) {
      if (!Array.isArray(children)) {
        TEMP_ARRAY$1[0] = children;
        children = TEMP_ARRAY$1;
      }
      for (let i = 0, len = children.length; i < len; i++) {
        let childDesc = children[i];
        if (!childDesc)
          continue;
        if (!newDict) {
          newDict = this._childrenDict = /* @__PURE__ */ Object.create(null);
        }
        const isJSX = isReactElement(childDesc);
        let propsObj = isJSX ? childDesc.props : childDesc;
        let facadeClass = isJSX ? childDesc.type : childDesc.facade;
        let key = childDesc.key;
        if (!key) {
          let j = 0;
          do {
            key = `auto:${facadeClass.name}:${j++}`;
          } while (newDict[key]);
        }
        if (true) {
          if (typeof facadeClass !== "function") {
            throw new Error('All scene objects must have a "facade" property pointing to a class/constructor');
          }
        }
        if (newDict[key]) {
          console.warn(`Duplicate key in children: ${key}`);
          while (newDict[key]) {
            key += "|dupe";
          }
        }
        let transition = propsObj.transition;
        let animation = propsObj.animation;
        if (transition || animation || propsObj.exitAnimation) {
          facadeClass = extendAsAnimatable(facadeClass);
        }
        if (propsObj.pointerStates) {
          facadeClass = extendAsPointerStatesAware(facadeClass);
        }
        let oldImpl = oldDict && oldDict[key];
        let newImpl;
        if (oldImpl && oldImpl.constructor === facadeClass) {
          newImpl = oldImpl;
        } else {
          if (oldImpl)
            oldImpl.destructor();
          newImpl = new facadeClass(this);
        }
        newImpl.transition = transition;
        newImpl.animation = animation;
        for (let prop in propsObj) {
          if (propsObj.hasOwnProperty(prop) && !Facade.isSpecialDescriptorProperty(prop)) {
            newImpl[prop] = propsObj[prop];
          }
        }
        newDict[key] = newImpl;
        orderedChildKeys.push(key);
        newImpl.afterUpdate();
      }
    }
    if (oldDict) {
      for (let key in oldDict) {
        if (!newDict || !newDict[key]) {
          oldDict[key].destructor();
        }
      }
    }
  }
  getChildByKey(key) {
    let dict = this._childrenDict;
    return dict && dict[key] || null;
  }
  /**
   * Walk this facade's descendant tree, invoking a function for it and each descendant.
   * The iteration order will match the order in which the `children` were declared. It may
   * also include items that have been queued for removal but not yet removed, e.g. facades
   * in the process of an `exitAnimation`.
   * @param {Function} fn
   * @param {Object} [thisArg]
   */
  traverse(fn, thisArg) {
    fn.call(thisArg, this);
    const keys = this._orderedChildKeys;
    const dict = this._childrenDict;
    for (let i = 0, len = keys.length; i < len; i++) {
      dict[keys[i]].traverse(fn, thisArg);
    }
  }
  /**
   * Iterate over this facade's direct child facades, invoking a function for each.
   * The iteration order will match the order in which the `children` were declared. It may
   * also include items that have been queued for removal but not yet removed, e.g. facades
   * in the process of an `exitAnimation`.
   * @param {Function} fn
   * @param {Object} [thisArg]
   */
  forEachChild(fn, thisArg) {
    const keys = this._orderedChildKeys;
    const dict = this._childrenDict;
    for (let i = 0, len = keys.length; i < len; i++) {
      fn.call(thisArg, dict[keys[i]], keys[i]);
    }
  }
  destructor() {
    this.isDestroying = true;
    let dict = this._childrenDict;
    if (dict) {
      for (let key in dict) {
        dict[key].destructor();
      }
    }
    super.destructor();
  }
};
var pointerMotionEventProps = [
  "onMouseOver",
  "onMouseOut",
  "onMouseMove",
  "onDragStart",
  "onDrag",
  "onDragEnter",
  "onDragOver",
  "onDragLeave"
];
var pointerActionEventProps = [
  "onMouseDown",
  "onMouseUp",
  "onClick",
  "onDoubleClick",
  "onDrop",
  "onDragEnd",
  "onWheel"
];
var pointerActionEventTypes = pointerActionEventProps.map(eventPropToType);
var pointerMotionEventTypes = pointerMotionEventProps.map(eventPropToType);
var pointerEventProps = pointerMotionEventProps.concat(pointerActionEventProps);
var pointerEventTypes = pointerMotionEventTypes.concat(pointerActionEventTypes);
function eventPropToType(prop) {
  return prop === "onDoubleClick" ? "dblclick" : prop.replace(/^on/, "").toLowerCase();
}
var PointerEventTarget = class extends ParentFacade {
  /**
   * Determine if this PointerEventTarget should intercept pointer events:
   * - By default only facades with a pointer event listener assigned will be counted, to prevent being blocked by unwanted objects
   * - If an object should definitely block events from objects behind it, set `pointerEvents:true`
   * - If an object has one of the pointer event properties but should be ignored in picking, set `pointerEvents:false`
   */
  interceptsPointerEvents(eventRegistry) {
    if (this.pointerEvents === false) {
      return false;
    }
    if (this.pointerEvents) {
      return true;
    }
    for (let i = 0, len = pointerEventTypes.length; i < len; i++) {
      if (eventRegistry.hasFacadeListenersOfType(this, pointerEventTypes[i])) {
        return true;
      }
    }
  }
};
Object.defineProperty(PointerEventTarget.prototype, "isPointerEventTarget", { value: true });
pointerEventProps.forEach((propName) => {
  Facade.defineEventProperty(PointerEventTarget, propName, eventPropToType(propName));
});
function EventRegistry() {
  const byEventType = /* @__PURE__ */ Object.create(null);
  this.addListenerForFacade = (facade, type, handler) => {
    const listenersOfType = byEventType[type] || (byEventType[type] = {
      count: 0,
      byFacadeId: /* @__PURE__ */ Object.create(null)
    });
    const facadeId = facade.$facadeId;
    const oldHandlers = listenersOfType.byFacadeId[facadeId];
    if (!oldHandlers) {
      listenersOfType.count++;
      listenersOfType.byFacadeId[facadeId] = handler;
    } else if (Array.isArray(oldHandlers)) {
      if (oldHandlers.indexOf(handler) === -1) {
        listenersOfType.count++;
        oldHandlers.push(handler);
      }
    } else if (oldHandlers !== handler) {
      listenersOfType.count++;
      listenersOfType.byFacadeId[facadeId] = [oldHandlers, handler];
    }
  };
  this.removeListenerForFacade = (facade, type, handler) => {
    const listenersOfType = byEventType[type];
    const facadeId = facade.$facadeId;
    const oldHandlers = listenersOfType && listenersOfType.byFacadeId[facadeId];
    if (oldHandlers === handler) {
      listenersOfType.count--;
      delete listenersOfType.byFacadeId[facadeId];
    } else if (Array.isArray(oldHandlers)) {
      const idx = oldHandlers.indexOf(handler);
      if (idx > -1) {
        listenersOfType.count--;
        if (oldHandlers.length === 1) {
          delete listenersOfType.byFacadeId[facadeId];
        } else {
          oldHandlers.splice(idx, 1);
        }
      }
    }
  };
  this.removeAllListenersForFacade = (facade) => {
    const facadeId = facade.$facadeId;
    for (let type in byEventType) {
      let facadeListeners = byEventType[type].byFacadeId[facadeId];
      if (facadeListeners) {
        byEventType[type].count -= Array.isArray(facadeListeners) ? facadeListeners.length : 1;
        delete byEventType[type].byFacadeId[facadeId];
      }
    }
  };
  this.hasFacadeListenersOfType = (facade, type) => {
    return byEventType[type] ? !!byEventType[type].byFacadeId[facade.$facadeId] : false;
  };
  this.hasAnyListenersOfType = (type) => {
    return byEventType[type] ? byEventType[type].count > 0 : false;
  };
  this.findBubblingEventTarget = (targetFacade, eventType) => {
    while (targetFacade) {
      if (this.hasFacadeListenersOfType(targetFacade, eventType)) {
        return targetFacade;
      }
      targetFacade = targetFacade.parent;
    }
    return null;
  };
  function tryCall(func, scope, arg1, arg2) {
    try {
      func.call(scope, arg1, arg2);
    } catch (err) {
      console.error(err);
    }
  }
  this.forEachFacadeListenerOfType = (facade, type, callback, scope) => {
    const listenersOfType = byEventType[type];
    const facadeId = facade.$facadeId;
    const handlers = listenersOfType && listenersOfType.byFacadeId[facadeId];
    if (handlers) {
      if (Array.isArray(handlers)) {
        for (let i = 0; i < handlers.length; i++) {
          tryCall(callback, scope, handlers[i], facadeId);
        }
      } else {
        tryCall(callback, scope, handlers, facadeId);
      }
    }
  };
  this.forEachListenerOfType = (type, callback, scope) => {
    const listenersOfType = byEventType[type];
    if (listenersOfType && listenersOfType.count > 0) {
      for (let facadeId in listenersOfType.byFacadeId) {
        const facadeListeners = listenersOfType.byFacadeId[facadeId];
        if (Array.isArray(facadeListeners)) {
          for (let i = 0; i < facadeListeners.length; i++) {
            tryCall(callback, scope, facadeListeners[i], facadeId);
          }
        } else {
          tryCall(callback, scope, facadeListeners, facadeId);
        }
      }
    }
  };
  this.dispatchEventOnFacade = (facade, event) => {
    let currentTarget = facade;
    function callHandler(handler) {
      handler.call(currentTarget, event);
    }
    event.target = facade;
    while (currentTarget && !event.propagationStopped) {
      event.currentTarget = currentTarget;
      this.forEachFacadeListenerOfType(currentTarget, event.type, callHandler, null);
      if (event.bubbles) {
        currentTarget = currentTarget.parent;
      } else {
        break;
      }
    }
  };
}
var TAP_DISTANCE_THRESHOLD = 10;
var TAP_GESTURE_MAX_DUR = 300;
var TAP_DBLCLICK_MAX_DUR = 300;
var DEFAULT_EVENT_SOURCE = {};
var domPointerMotionEventTypes = [
  "mousemove",
  "mouseout",
  "touchmove"
];
var domPointerActionEventTypes = [
  "mousedown",
  "mouseup",
  "click",
  "dblclick",
  "wheel",
  "touchstart",
  "touchend",
  "touchcancel"
];
var dropEventTypes = [
  "mouseup",
  "touchend",
  "touchcancel"
];
var pointerActionEventTypeMappings = {
  "touchstart": "mousedown",
  "touchend": "mouseup",
  "touchcancel": "mouseup"
};
var touchDragPropsToNormalize = ["clientX", "clientY", "screenX", "screenY", "pageX", "pageY"];
var SyntheticEvent = class {
  constructor(nativeEvent, type, target, relatedTarget, extraProps) {
    for (let prop in nativeEvent) {
      if (typeof nativeEvent[prop] !== "function") {
        this[prop] = nativeEvent[prop];
      }
    }
    this.target = target;
    this.relatedTarget = relatedTarget;
    this.type = type;
    this.nativeEvent = nativeEvent;
    assign(this, extraProps);
    if (nativeEvent.touches) {
      let touches = isTouchEndOrCancel(nativeEvent) ? nativeEvent.changedTouches : nativeEvent.touches;
      if (touches.length === 1) {
        touchDragPropsToNormalize.forEach((prop) => {
          this[prop] = touches[0][prop];
        });
      }
    }
  }
  preventDefault() {
    this.defaultPrevented = true;
    this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.propagationStopped = true;
    this.nativeEvent.stopPropagation();
  }
};
function isTouchEndOrCancel(e) {
  return e.type === "touchend" || e.type === "touchcancel";
}
function killEvent(e) {
  e.stopPropagation();
  e.preventDefault();
}
var WorldBaseFacade = class extends ParentFacade {
  constructor(element) {
    super(null);
    this.width = this.height = 1;
    this._element = element;
    this._htmlOverlays = /* @__PURE__ */ Object.create(null);
    this.eventRegistry = new EventRegistry();
    this._onPointerMotionEvent = this._onPointerMotionEvent.bind(this);
    this._onPointerActionEvent = this._onPointerActionEvent.bind(this);
    this._onDropEvent = this._onDropEvent.bind(this);
    this._togglePointerListeners(true);
  }
  afterUpdate() {
    this._queueRender();
    super.afterUpdate();
  }
  onNotifyWorld(source, message, data) {
    let handler = this._notifyWorldHandlers[message];
    if (handler) {
      handler.call(this, source, data);
    }
  }
  _isContinuousRender() {
    return this.continuousRender;
  }
  /**
   * @property {{requestAnimationFrame, cancelAnimationFrame}} renderingScheduler
   * The object holding `requestAnimationFrame` and `cancelAnimationFrame` scheduling
   * functions. Defaults to `window` but can be switched to another implementation, e.g.
   * to use an XRSession's custom scheduler.
   */
  set renderingScheduler(scheduler) {
    scheduler = scheduler || window;
    if (scheduler !== this.renderingScheduler) {
      const activeHandle = this._nextFrameTimer;
      if (activeHandle) {
        this.renderingScheduler.cancelAnimationFrame(activeHandle);
        this._nextFrameTimer = null;
      }
      this._renderingScheduler = scheduler;
    }
  }
  get renderingScheduler() {
    return this._renderingScheduler || window;
  }
  // Schedule a render pass on the next frame
  _queueRender() {
    if (!this._nextFrameTimer) {
      const handler = this._nextFrameHandler || (this._nextFrameHandler = (...args) => {
        let { onStatsUpdate, onBeforeRender, onAfterRender } = this;
        let start = onStatsUpdate && Date.now();
        if (onBeforeRender)
          onBeforeRender(this);
        this.doRender(...args);
        if (onStatsUpdate) {
          let now = Date.now();
          onStatsUpdate({
            "Render CPU Time (ms)": now - start,
            "Time Between Frames (ms)": this._lastFrameTime ? now - this._lastFrameTime : "?",
            "FPS": this._lastFrameTime ? Math.round(1e3 / (now - this._lastFrameTime)) : "?"
          });
          this._lastFrameTime = now;
        }
        this._doRenderHtmlItems();
        if (onAfterRender)
          onAfterRender(this);
        this._nextFrameTimer = null;
        if (this._isContinuousRender()) {
          this._queueRender();
        }
      });
      this._nextFrameTimer = this.renderingScheduler.requestAnimationFrame(handler);
    }
  }
  /**
   * @abstract
   */
  doRender() {
  }
  /**
   * @abstract
   */
  getFacadeUserSpaceXYZ() {
  }
  _doRenderHtmlItems() {
    if (this.renderHtmlItems) {
      let htmlItemsData = [];
      let overlayFacades = this._htmlOverlays;
      for (let key in overlayFacades) {
        let facade = overlayFacades[key];
        let data = this.getFacadeUserSpaceXYZ(facade);
        if (data.z >= 0) {
          data.key = facade.$facadeId;
          data.html = facade.html;
          data.exact = facade.exact;
          htmlItemsData.push(data);
        }
      }
      this.renderHtmlItems(htmlItemsData);
    }
  }
  /**
   * Hook allowing world implementations to pre-normalize native pointer events, for instance
   * computing derived worldspace properties that are simpler for downstream code to use.
   * @param {Event} e
   * @protected
   */
  _normalizePointerEvent(e) {
  }
  /**
   * Entry point for handling events related to pointer motion (e.g. mouse or touch movement).
   * This will be called by the code that wraps this World facade to bridge native DOM events
   * into the Troika world.
   * @param {Event} e
   */
  _onPointerMotionEvent(e) {
    this._normalizePointerEvent(e);
    const eventState = this._getPointerEventState(e);
    if (pointerMotionEventTypes.some(this.eventRegistry.hasAnyListenersOfType)) {
      const hoverInfo = e.type === "mouseout" || isTouchEndOrCancel(e) ? null : this._findHoverTarget(e);
      let lastHovered = eventState.hoveredFacade;
      let hovered = eventState.hoveredFacade = hoverInfo && hoverInfo.facade;
      let dragInfo = eventState.dragInfo;
      if (dragInfo) {
        if (!dragInfo.dragStartFired) {
          this._firePointerEvent("dragstart", dragInfo.dragStartEvent, dragInfo.draggedFacade, null, hoverInfo);
          dragInfo.dragStartFired = true;
        }
        this._firePointerEvent("drag", e, dragInfo.draggedFacade, null, hoverInfo);
      }
      if (hovered !== lastHovered) {
        if (lastHovered) {
          this._firePointerEvent("mouseout", e, lastHovered, hovered, hoverInfo);
          if (dragInfo) {
            this._firePointerEvent("dragleave", e, lastHovered, hovered, hoverInfo);
          }
        }
        if (hovered) {
          this._firePointerEvent("mouseover", e, hovered, lastHovered, hoverInfo);
          if (dragInfo) {
            this._firePointerEvent("dragenter", e, hovered, lastHovered, hoverInfo);
          }
        }
      }
      if (hovered) {
        this._firePointerEvent("mousemove", e, hovered, null, hoverInfo);
        if (dragInfo) {
          this._firePointerEvent("dragover", e, hovered, null, hoverInfo);
        }
      }
    }
    let tapInfo = eventState.tapInfo;
    if (tapInfo && e.type === "touchmove") {
      let touch = e.changedTouches[0];
      if (touch && Math.sqrt(Math.pow(touch.clientX - tapInfo.x, 2) + Math.pow(touch.clientY - tapInfo.y, 2)) > TAP_DISTANCE_THRESHOLD) {
        eventState.tapInfo = null;
      }
    }
  }
  /**
   * Entry point for handling events related to pointer motion (e.g. mouse clicks or touch taps).
   * This will be called by the code that wraps this World facade to bridge native DOM events
   * into the Troika world.
   * @param {Event} e
   */
  _onPointerActionEvent(e) {
    this._normalizePointerEvent(e);
    if (dropEventTypes.indexOf(e.type) > -1) {
      this._onDropEvent(e);
    }
    if (e.type === "touchstart") {
      if (e.touches.length === 1) {
        this._onPointerMotionEvent(e);
      }
      this._enableContextMenu(false);
    }
    const eventRegistry = this.eventRegistry;
    if (eventRegistry.hasAnyListenersOfType("dragstart") || pointerActionEventTypes.some(eventRegistry.hasAnyListenersOfType)) {
      let hoverInfo = this._findHoverTarget(e);
      let facade = hoverInfo && hoverInfo.facade;
      if (facade) {
        const eventState = this._getPointerEventState(e);
        this._firePointerEvent(pointerActionEventTypeMappings[e.type] || e.type, e, facade, null, hoverInfo);
        if (eventRegistry.findBubblingEventTarget(facade, "click") || eventRegistry.findBubblingEventTarget(facade, "dblclick")) {
          let tapInfo = eventState.tapInfo;
          if (e.type === "touchstart" && e.touches.length === 1) {
            eventState.tapInfo = {
              facade,
              x: e.touches[0].clientX,
              y: e.touches[0].clientY,
              startTime: Date.now(),
              isDblClick: tapInfo && Date.now() - tapInfo.startTime < TAP_DBLCLICK_MAX_DUR
            };
          } else {
            if (tapInfo && tapInfo.facade === facade && e.type === "touchend" && e.touches.length === 0 && e.changedTouches.length === 1 && Date.now() - tapInfo.startTime < TAP_GESTURE_MAX_DUR) {
              this._firePointerEvent("click", e, facade, null, hoverInfo);
              if (tapInfo.isDblClick) {
                this._firePointerEvent("dblclick", e, facade, null, hoverInfo);
              }
            }
          }
        }
        if (e.type === "mousedown" || e.type === "touchstart") {
          const dragger = eventRegistry.findBubblingEventTarget(facade, "dragstart");
          if (dragger) {
            let dragStartEvent = new SyntheticEvent(e, "dragstart", dragger, null, { intersection: hoverInfo });
            eventState.dragInfo = {
              draggedFacade: dragger,
              dragStartFired: false,
              dragStartEvent
            };
            this._toggleDropListeners(true);
          }
        }
      }
      e.preventDefault();
    }
    if (isTouchEndOrCancel(e)) {
      if (e.changedTouches.length === 1) {
        this._onPointerMotionEvent(e);
      }
      this._enableContextMenu(true);
    }
  }
  _onDropEvent(e) {
    const eventState = this._getPointerEventState(e);
    let dragInfo = eventState.dragInfo;
    if (dragInfo) {
      this._normalizePointerEvent(e);
      let hoverInfo = this._findHoverTarget(e);
      let targetFacade = hoverInfo && hoverInfo.facade;
      if (targetFacade) {
        this._firePointerEvent("drop", e, targetFacade, null, hoverInfo);
      }
      this._firePointerEvent("dragend", e, dragInfo.draggedFacade, null, hoverInfo);
      this._toggleDropListeners(false);
      eventState.dragInfo = null;
    }
  }
  _firePointerEvent(eventType, originalEvent, targetFacade, relatedTargetFacade, intersection) {
    let newEvent = originalEvent instanceof SyntheticEvent ? originalEvent : new SyntheticEvent(
      originalEvent,
      eventType,
      targetFacade,
      relatedTargetFacade,
      {
        bubbles: true,
        intersection
      }
    );
    this.eventRegistry.dispatchEventOnFacade(targetFacade, newEvent);
  }
  _getPointerEventState(e) {
    const states = this._pointerEventStates || (this._pointerEventStates = /* @__PURE__ */ new WeakMap());
    const eventSource = e.eventSource || DEFAULT_EVENT_SOURCE;
    let eventState = states.get(eventSource);
    if (!eventState) {
      states.set(eventSource, eventState = {});
    }
    return eventState;
  }
  _toggleDropListeners(on) {
    dropEventTypes.forEach((type) => {
      document[(on ? "add" : "remove") + "EventListener"](type, this._onDropEvent, true);
    });
  }
  _togglePointerListeners(on) {
    let canvas = this._element;
    if (canvas && on !== this._pointerListenersAttached) {
      let method = (on ? "add" : "remove") + "EventListener";
      domPointerMotionEventTypes.forEach((type) => {
        canvas[method](type, this._onPointerMotionEvent, false);
      });
      domPointerActionEventTypes.forEach((type) => {
        canvas[method](type, this._onPointerActionEvent, false);
      });
      this._pointerListenersAttached = on;
    }
  }
  _enableContextMenu(enable) {
    let canvas = this._element;
    if (canvas) {
      canvas[(enable ? "remove" : "add") + "EventListener"]("contextmenu", killEvent, true);
    }
  }
  /**
   * @abstract
   * Given a pointer-related Event, find and return all facade objects that are intersected
   * by that event. If any hits are found, this should return an array of objects that contain
   * at least `facade` and `distance` properties. Any additional properties will be exposed to
   * event listeners on the synthetic event object as an `intersection` property.
   * @param {Event} e
   * @param {Function} [filterFn]
   * @return {Array<{facade, distance, ?distanceBias, ...}>|null}
   */
  getFacadesAtEvent(e, filterFn) {
    throw new Error("getFacadesAtEvent: no impl");
  }
  _findHoverTarget(e) {
    if (e.touches && e.touches.length > 1) {
      return null;
    }
    let allHits = this.getFacadesAtEvent(
      e,
      (facade) => facade.isPointerEventTarget && facade.interceptsPointerEvents(this.eventRegistry)
    );
    if (allHits) {
      let closestHit = allHits[0];
      for (let i = 1; i < allHits.length; i++) {
        if (allHits[i].distance < closestHit.distance || allHits[i].distance === closestHit.distance && (allHits[i].distanceBias || 0) < (closestHit.distanceBias || 0)) {
          closestHit = allHits[i];
        }
      }
      return closestHit;
    }
    return null;
  }
  destructor() {
    if (this._nextFrameTimer) {
      this.renderingScheduler.cancelAnimationFrame(this._nextFrameTimer);
    }
    this._togglePointerListeners(false);
    this._toggleDropListeners(false);
    super.destructor();
  }
};
Object.defineProperty(WorldBaseFacade.prototype, "isWorld", { value: true });
WorldBaseFacade.prototype._notifyWorldHandlers = {
  needsRender() {
    this._queueRender();
  },
  addEventListener(source, data) {
    this.eventRegistry.addListenerForFacade(source, data.type, data.handler);
  },
  removeEventListener(source, data) {
    this.eventRegistry.removeListenerForFacade(source, data.type, data.handler);
  },
  removeAllEventListeners(source) {
    this.eventRegistry.removeAllListenersForFacade(source);
  },
  dispatchEvent(source, event) {
    if (!(event instanceof SyntheticEvent)) {
      event = new SyntheticEvent(event, event.type, event.target, event.relatedTarget);
    }
    this.eventRegistry.dispatchEventOnFacade(source, event);
  },
  addHtmlOverlay(source) {
    this._htmlOverlays[source.$facadeId] = source;
  },
  removeHtmlOverlay(source) {
    delete this._htmlOverlays[source.$facadeId];
  },
  statsUpdate(source, data) {
    let onStatsUpdate = this.onStatsUpdate;
    if (onStatsUpdate)
      onStatsUpdate(data);
  }
};
var CT_STYLES = {
  position: "absolute",
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  pointerEvents: "none",
  transformStyle: "preserve-3d"
};
var HtmlOverlayContent = class extends import_react.default.Component {
  shouldComponentUpdate(newProps) {
    return newProps.html !== this.props.html || (newProps.html.props && newProps.html.props.shouldUpdateOnMove) === true;
  }
  render() {
    let html = this.props.html;
    return typeof html === "string" ? import_react.default.createElement("span", null, html) : import_react.default.cloneElement(html);
  }
};
HtmlOverlayContent.displayName = "Canvas3D.HtmlOverlayContent";
HtmlOverlayContent.propTypes = {
  html: import_prop_types.default.node
};
var HtmlOverlay = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.setItems = this.setItems.bind(this);
    this.state = {
      items: null
    };
  }
  shouldComponentUpdate(newProps, newState) {
    let oldState = this.state;
    return newState.items && newState.items.length || oldState.items && oldState.items.length;
  }
  setItems(items) {
    let lastItems = this.state.items;
    if (items && items.length || lastItems && lastItems.length) {
      this.setState({ items: items || null });
    }
  }
  render() {
    let items = this.state.items;
    let round = Math.round;
    return items && items.length ? import_react.default.createElement(
      "div",
      {
        className: "troika_html_overlay",
        style: CT_STYLES
      },
      items.map(({ key, html, x, y, z, exact }) => {
        if (!exact) {
          x = round(x);
          y = round(y);
        }
        return import_react.default.createElement(
          "div",
          {
            key,
            style: {
              position: "absolute",
              transform: `translate3d(${x}px, ${y}px, ${-z}px)`
            }
          },
          import_react.default.createElement(HtmlOverlayContent, { html })
        );
      })
    ) : null;
  }
};
HtmlOverlay.displayName = "Canvas3D.HtmlOverlay";
var style = {
  position: "absolute",
  top: 0,
  right: 0,
  background: "rgba(0,0,0,.5)",
  font: "11px sans-serif",
  padding: 10
};
var Stats = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.state = { stats: {} };
  }
  setStats(stats) {
    this.setState({ stats });
  }
  render() {
    let stats = this.state.stats;
    return import_react.default.createElement(
      "div",
      { style },
      Object.keys(stats).sort().map(
        (key) => import_react.default.createElement("div", { key }, `${key}: ${stats[key]}`)
      )
    );
  }
};
var defaultCanvasStyle = { width: "100%", height: "100%" };
var CanvasBase = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this._stats = {};
    this.updateStats = this.updateStats.bind(this);
    this.renderHtmlItems = this.renderHtmlItems.bind(this);
    this._bindHtmlOverlayRef = this._bindHtmlOverlayRef.bind(this);
    this._bindCanvasRef = this._bindCanvasRef.bind(this);
    this._bindStatsRef = this._bindStatsRef.bind(this);
  }
  componentDidUpdate() {
    this.updateWorld();
  }
  initWorld(canvas) {
    const world = new this.props.worldFacade(canvas);
    world.renderHtmlItems = this.renderHtmlItems;
    return world;
  }
  updateWorld() {
    const world = this._world;
    if (world) {
      const { props } = this;
      let useStats = props.stats;
      let start = useStats && Date.now();
      world.width = props.width;
      world.height = props.height;
      world.pixelRatio = props.pixelRatio;
      world.continuousRender = props.continuousRender;
      world.onStatsUpdate = useStats ? this.updateStats : null;
      assign(world, props.worldProps);
      world.afterUpdate();
      if (useStats) {
        this.updateStats({ "Last World Update (ms)": Date.now() - start });
      }
    }
  }
  destroyWorld() {
    if (this._world) {
      this._world.destructor();
      delete this._world;
    }
    clearTimeout(this._statsDelay);
  }
  renderHtmlItems(items) {
    if (this._htmlOverlayRef) {
      this._htmlOverlayRef.setItems(items);
    }
  }
  updateStats(stats) {
    this._stats = assign({}, this._stats, stats);
    if (!this._statsDelay) {
      this._statsDelay = setTimeout(() => {
        this._statsDelay = null;
        let ref = this._statsRef;
        if (ref) {
          ref.setStats(this._stats);
        }
      }, 250);
    }
  }
  _bindHtmlOverlayRef(cmp) {
    this._htmlOverlayRef = cmp;
  }
  _bindCanvasRef(canvas) {
    if (canvas) {
      try {
        this._world = this.initWorld(canvas);
        this.updateWorld();
      } catch (e) {
        console.warn(`Troika.${this.constructor.displayName}: world init failed, using fallback content.`, e);
        this._failedWorldInit = true;
        this._world = null;
        this.forceUpdate();
      }
    } else {
      this.destroyWorld();
    }
    const cb = this.props.onCanvasRef;
    if (cb)
      cb(canvas);
  }
  _bindStatsRef(ref) {
    this._statsRef = ref;
  }
  render() {
    let { props } = this;
    return import_react.default.createElement(
      "div",
      {
        className: `troika ${props.className || ""}`,
        style: {
          position: "relative",
          overflow: "hidden",
          width: props.width,
          height: props.height,
          cursor: props.cursor,
          userSelect: "none"
        }
      },
      this._failedWorldInit ? this.props.children : import_react.default.createElement(
        "canvas",
        {
          className: "troika_canvas",
          ref: this._bindCanvasRef,
          style: props.canvasStyle || defaultCanvasStyle
        }
      ),
      import_react.default.createElement(HtmlOverlay, { ref: this._bindHtmlOverlayRef }),
      props.stats ? import_react.default.createElement(Stats, { ref: this._bindStatsRef }) : null
    );
  }
};
CanvasBase.commonPropTypes = {
  width: import_prop_types.default.number.isRequired,
  height: import_prop_types.default.number.isRequired,
  pixelRatio: import_prop_types.default.number,
  worldFacade: import_prop_types.default.func,
  worldProps: import_prop_types.default.object,
  canvasStyle: import_prop_types.default.object,
  className: import_prop_types.default.string,
  continuousRender: import_prop_types.default.bool,
  onCanvasRef: import_prop_types.default.func,
  stats: import_prop_types.default.bool,
  cursor: import_prop_types.default.string
};

// node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
function toTrianglesDrawMode(geometry, drawMode) {
  if (drawMode === TrianglesDrawMode) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry;
  }
  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
    let index = geometry.getIndex();
    if (index === null) {
      const indices = [];
      const position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (let i = 0; i < position.count; i++) {
          indices.push(i);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (let i = 1; i <= numberOfTriangles; i++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i));
        newIndices.push(index.getX(i + 1));
      }
    } else {
      for (let i = 0; i < numberOfTriangles; i++) {
        if (i % 2 === 0) {
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i + 2));
        } else {
          newIndices.push(index.getX(i + 2));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry;
  }
}

// node_modules/three/examples/jsm/loaders/GLTFLoader.js
var GLTFLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsDispersionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureAVIFExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsEmissiveStrengthExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIridescenceExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsAnisotropyExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsBumpExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshGpuInstancing(parser);
    });
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      const relativeUrl = LoaderUtils.extractUrlBase(url);
      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path);
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(data) {
      try {
        scope.parse(data, resourcePath, function(gltf) {
          onLoad(gltf);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e) {
        _onError(e);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad, onError) {
    let json;
    const extensions = {};
    const plugins = {};
    const textDecoder = new TextDecoder();
    if (typeof data === "string") {
      json = JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      const magic = textDecoder.decode(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError)
            onError(error);
          return;
        }
        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else {
        json = JSON.parse(textDecoder.decode(data));
      }
    } else {
      json = data;
    }
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError)
        onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i = 0; i < this.pluginCallbacks.length; i++) {
      const plugin = this.pluginCallbacks[i](parser);
      if (!plugin.name)
        console.error("THREE.GLTFLoader: Invalid plugin found: missing name");
      plugins[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i = 0; i < json.extensionsUsed.length; ++i) {
        const extensionName = json.extensionsUsed[i];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
  parseAsync(data, path) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(data, path, resolve, reject);
    });
  }
};
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object) {
      objects[key] = object;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
var EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
var GLTFLightsExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency)
      return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color = new Color(16777215);
    if (lightDef.color !== void 0)
      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    assignExtrasToUserData(lightNode, lightDef);
    if (lightDef.intensity !== void 0)
      lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  getDependency(type, index) {
    if (type !== "light")
      return;
    return this._loadLight(index);
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0)
      return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
};
var GLTFMaterialsUnlitExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsEmissiveStrengthExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
    if (emissiveStrength !== void 0) {
      materialParams.emissiveIntensity = emissiveStrength;
    }
    return Promise.resolve();
  }
};
var GLTFMaterialsClearcoatExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, scale);
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsDispersionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;
    return Promise.resolve();
  }
};
var GLTFMaterialsIridescenceExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.iridescenceFactor !== void 0) {
      materialParams.iridescence = extension.iridescenceFactor;
    }
    if (extension.iridescenceTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
    }
    if (extension.iridescenceIor !== void 0) {
      materialParams.iridescenceIOR = extension.iridescenceIor;
    }
    if (materialParams.iridescenceThicknessRange === void 0) {
      materialParams.iridescenceThicknessRange = [100, 400];
    }
    if (extension.iridescenceThicknessMinimum !== void 0) {
      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
    }
    if (extension.iridescenceThicknessMaximum !== void 0) {
      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
    }
    if (extension.iridescenceThicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsSheenExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      const colorFactor = extension.sheenColorFactor;
      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsTransmissionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsVolumeExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    return Promise.all(pending);
  }
};
var GLTFMaterialsIorExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
};
var GLTFMaterialsSpecularExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsBumpExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;
    if (extension.bumpTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "bumpMap", extension.bumpTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsAnisotropyExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.anisotropyStrength !== void 0) {
      materialParams.anisotropy = extension.anisotropyStrength;
    }
    if (extension.anisotropyRotation !== void 0) {
      materialParams.anisotropyRotation = extension.anisotropyRotation;
    }
    if (extension.anisotropyTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFTextureBasisUExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader);
  }
};
var GLTFTextureWebPExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFTextureAVIFExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, extension.source, loader);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image = new Image();
        image.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
        image.onload = image.onerror = function() {
          resolve(image.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFMeshoptCompression = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return buffer.then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const source = new Uint8Array(res, byteOffset, byteLength);
        if (decoder.decodeGltfBufferAsync) {
          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
            return res2.buffer;
          });
        } else {
          return decoder.ready.then(function() {
            const result = new ArrayBuffer(count * stride);
            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
            return result;
          });
        }
      });
    } else {
      return null;
    }
  }
};
var GLTFMeshGpuInstancing = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
    this.parser = parser;
  }
  createNodeMesh(nodeIndex) {
    const json = this.parser.json;
    const nodeDef = json.nodes[nodeIndex];
    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
      return null;
    }
    const meshDef = json.meshes[nodeDef.mesh];
    for (const primitive of meshDef.primitives) {
      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
        return null;
      }
    }
    const extensionDef = nodeDef.extensions[this.name];
    const attributesDef = extensionDef.attributes;
    const pending = [];
    const attributes = {};
    for (const key in attributesDef) {
      pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => {
        attributes[key] = accessor;
        return attributes[key];
      }));
    }
    if (pending.length < 1) {
      return null;
    }
    pending.push(this.parser.createNodeMesh(nodeIndex));
    return Promise.all(pending).then((results) => {
      const nodeObject = results.pop();
      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
      const count = results[0].count;
      const instancedMeshes = [];
      for (const mesh of meshes) {
        const m = new Matrix4();
        const p = new Vector3();
        const q = new Quaternion();
        const s = new Vector3(1, 1, 1);
        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
        for (let i = 0; i < count; i++) {
          if (attributes.TRANSLATION) {
            p.fromBufferAttribute(attributes.TRANSLATION, i);
          }
          if (attributes.ROTATION) {
            q.fromBufferAttribute(attributes.ROTATION, i);
          }
          if (attributes.SCALE) {
            s.fromBufferAttribute(attributes.SCALE, i);
          }
          instancedMesh.setMatrixAt(i, m.compose(p, q, s));
        }
        for (const attributeName in attributes) {
          if (attributeName === "_COLOR_0") {
            const attr = attributes[attributeName];
            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);
          } else if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
          }
        }
        Object3D.prototype.copy.call(instancedMesh, mesh);
        this.parser.assignFinalMaterial(instancedMesh);
        instancedMeshes.push(instancedMesh);
      }
      if (nodeObject.isGroup) {
        nodeObject.clear();
        nodeObject.add(...instancedMeshes);
        return nodeObject;
      }
      return instancedMeshes[0];
    });
  }
};
var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
var GLTFBinaryExtension = class {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    const textDecoder = new TextDecoder();
    this.header = {
      magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = textDecoder.decode(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
};
var GLTFDracoMeshCompressionExtension = class {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType.name;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve, reject) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0)
              attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);
      });
    });
  }
};
var GLTFTextureTransformExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform) {
    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform.texCoord !== void 0) {
      texture.channel = transform.texCoord;
    }
    if (transform.offset !== void 0) {
      texture.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== void 0) {
      texture.rotation = transform.rotation;
    }
    if (transform.scale !== void 0) {
      texture.repeat.fromArray(transform.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
};
var GLTFMeshQuantizationExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
};
var GLTFCubicSplineInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i = 0; i !== valueSize; i++) {
      result[i] = values[offset + i];
    }
    return result;
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const stride2 = stride * 2;
    const stride3 = stride * 3;
    const td = t1 - t0;
    const p = (t - t0) / td;
    const pp = p * p;
    const ppp = pp * p;
    const offset1 = i1 * stride3;
    const offset0 = offset1 - stride3;
    const s2 = -2 * ppp + 3 * pp;
    const s3 = ppp - pp;
    const s0 = 1 - s2;
    const s1 = s3 - pp + p;
    for (let i = 0; i !== stride; i++) {
      const p0 = values[offset0 + i + stride];
      const m0 = values[offset0 + i + stride2] * td;
      const p1 = values[offset1 + i + stride];
      const m1 = values[offset1 + i] * td;
      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  }
};
var _q = new Quaternion();
var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t, t1) {
    const result = super.interpolate_(i1, t0, t, t1);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
};
var WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
var ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
  if (cache["DefaultMaterial"] === void 0) {
    cache["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  let hasMorphColor = false;
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (target.POSITION !== void 0)
      hasMorphPosition = true;
    if (target.NORMAL !== void 0)
      hasMorphNormal = true;
    if (target.COLOR_0 !== void 0)
      hasMorphColor = true;
    if (hasMorphPosition && hasMorphNormal && hasMorphColor)
      break;
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)
    return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  const pendingColorAccessors = [];
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
    if (hasMorphColor) {
      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
      pendingColorAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors),
    Promise.all(pendingColorAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    const morphColors = accessors[2];
    if (hasMorphPosition)
      geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal)
      geometry.morphAttributes.normal = morphNormals;
    if (hasMorphColor)
      geometry.morphAttributes.color = morphColors;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i = 0, il = meshDef.weights.length; i < il; i++) {
      mesh.morphTargetInfluences[i] = meshDef.weights[i];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i = 0, il = targetNames.length; i < il; i++) {
        mesh.morphTargetDictionary[targetNames[i]] = i;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  let geometryKey;
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  if (primitiveDef.targets !== void 0) {
    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {
      geometryKey += ":" + createAttributesKey(primitiveDef.targets[i]);
    }
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i = 0, il = keys.length; i < il; i++) {
    attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(uri) {
  if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0)
    return "image/jpeg";
  if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0)
    return "image/webp";
  return "image/png";
}
var _identityMatrix = new Matrix4();
var GLTFParser = class {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.nodeCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.sourceCache = {};
    this.textureCache = {};
    this.nodeNamesUsed = {};
    let isSafari = false;
    let isFirefox = false;
    let firefoxVersion = -1;
    if (typeof navigator !== "undefined") {
      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;
      isFirefox = navigator.userAgent.indexOf("Firefox") > -1;
      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    if (typeof createImageBitmap === "undefined" || isSafari || isFirefox && firefoxVersion < 98) {
      this.textureLoader = new TextureLoader(this.options.manager);
    } else {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this.nodeCache = {};
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      return Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        for (const scene of result.scenes) {
          scene.updateMatrixWorld();
        }
        onLoad(result);
      });
    }).catch(onError);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(cache, index) {
    if (index === void 0)
      return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1)
      return object;
    const ref = object.clone();
    const updateMappings = (original, clone) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone, mappings);
      }
      for (const [i, child] of original.children.entries()) {
        updateMappings(child, clone.children[i]);
      }
    };
    updateMappings(object, ref);
    ref.name += "_instance_" + cache.uses[index]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result)
        return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result)
        pending.push(result);
    }
    return pending;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(type, index) {
    const cacheKey = type + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this._invokeOne(function(ext) {
            return ext.loadNode && ext.loadNode(index);
          });
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this._invokeOne(function(ext) {
            return ext.loadAnimation && ext.loadAnimation(index);
          });
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          dependency = this._invokeOne(function(ext) {
            return ext != this && ext.getDependency && ext.getDependency(type, index);
          });
          if (!dependency) {
            throw new Error("Unknown type: " + type);
          }
          break;
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const normalized = accessorDef.normalized === true;
      const array = new TypedArray(accessorDef.count * itemSize);
      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        for (let i = 0, il = sparseIndices.length; i < il; i++) {
          const index = sparseIndices[i];
          bufferAttribute.setX(index, sparseValues[i * itemSize]);
          if (itemSize >= 2)
            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3)
            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4)
            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return bufferAttribute;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const sourceIndex = textureDef.source;
    const sourceDef = json.images[sourceIndex];
    let loader = this.textureLoader;
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri);
      if (handler !== null)
        loader = handler;
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader);
  }
  loadTextureImage(textureIndex, sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const textureDef = json.textures[textureIndex];
    const sourceDef = json.images[sourceIndex];
    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
      texture.flipY = false;
      texture.name = textureDef.name || sourceDef.name || "";
      if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
        texture.name = sourceDef.uri;
      }
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  loadImageSource(sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then((texture) => texture.clone());
    }
    const sourceDef = json.images[sourceIndex];
    const URL = self.URL || self.webkitURL;
    let sourceURI = sourceDef.uri || "";
    let isObjectURL = false;
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: sourceDef.mimeType });
        sourceURI = URL.createObjectURL(blob);
        return sourceURI;
      });
    } else if (sourceDef.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL.revokeObjectURL(sourceURI);
      }
      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
      return texture;
    }).catch(function(error) {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      throw error;
    });
    this.sourceCache[sourceIndex] = promise;
    return promise;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(materialParams, mapName, mapDef, colorSpace) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (!texture)
        return null;
      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
        texture = texture.clone();
        texture.channel = mapDef.texCoord;
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }
      if (colorSpace !== void 0) {
        texture.colorSpace = colorSpace;
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        lineMaterial.map = material.map;
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (useDerivativeTangents)
        cacheKey += "derivative-tangents:";
      if (useVertexColors)
        cacheKey += "vertex-colors:";
      if (useFlatShading)
        cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors)
          cachedMaterial.vertexColors = true;
        if (useFlatShading)
          cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale)
            cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale)
            cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale, scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      const emissiveFactor = materialDef.emissiveFactor;
      materialParams.emissive = new Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
    }
    return Promise.all(pending).then(function() {
      const material = new materialType(materialParams);
      if (materialDef.name)
        material.name = materialDef.name;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions)
        addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    if (sanitizedName in this.nodeNamesUsed) {
      return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
    } else {
      this.nodeNamesUsed[sanitizedName] = 0;
      return sanitizedName;
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const primitive = primitives[i];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i = 0, il = geometries.length; i < il; i++) {
        const geometry = geometries[i];
        const primitive = primitives[i];
        let mesh;
        const material = materials[i];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions)
          addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i = 0, il = meshes.length; i < il; i++) {
        parser.associations.set(meshes[i], {
          meshes: meshIndex,
          primitives: i
        });
      }
      if (meshes.length === 1) {
        if (meshDef.extensions)
          addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
        return meshes[0];
      }
      const group = new Group();
      if (meshDef.extensions)
        addUnknownExtensionsToUserData(extensions, group, meshDef);
      parser.associations.set(group, { meshes: meshIndex });
      for (let i = 0, il = meshes.length; i < il; i++) {
        group.add(meshes[i]);
      }
      return group;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name)
      camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const pending = [];
    for (let i = 0, il = skinDef.joints.length; i < il; i++) {
      pending.push(this._loadNodeShallow(skinDef.joints[i]));
    }
    if (skinDef.inverseBindMatrices !== void 0) {
      pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
    } else {
      pending.push(null);
    }
    return Promise.all(pending).then(function(results) {
      const inverseBindMatrices = results.pop();
      const jointNodes = results;
      const bones = [];
      const boneInverses = [];
      for (let i = 0, il = jointNodes.length; i < il; i++) {
        const jointNode = jointNodes[i];
        if (jointNode) {
          bones.push(jointNode);
          const mat = new Matrix4();
          if (inverseBindMatrices !== null) {
            mat.fromArray(inverseBindMatrices.array, i * 16);
          }
          boneInverses.push(mat);
        } else {
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i]);
        }
      }
      return new Skeleton(bones, boneInverses);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(animationIndex) {
    const json = this.json;
    const parser = this;
    const animationDef = json.animations[animationIndex];
    const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i = 0, il = animationDef.channels.length; i < il; i++) {
      const channel = animationDef.channels[i];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      if (target.node === void 0)
        continue;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i = 0, il = nodes.length; i < il; i++) {
        const node = nodes[i];
        const inputAccessor = inputAccessors[i];
        const outputAccessor = outputAccessors[i];
        const sampler = samplers[i];
        const target = targets[i];
        if (node === void 0)
          continue;
        if (node.updateMatrix) {
          node.updateMatrix();
        }
        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
        if (createdTracks) {
          for (let k = 0; k < createdTracks.length; k++) {
            tracks.push(createdTracks[k]);
          }
        }
      }
      return new AnimationClip(animationName, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0)
      return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o) {
          if (!o.isMesh)
            return;
          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
            o.morphTargetInfluences[i] = nodeDef.weights[i];
          }
        });
      }
      return node;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodePending = parser._loadNodeShallow(nodeIndex);
    const childPending = [];
    const childrenDef = nodeDef.children || [];
    for (let i = 0, il = childrenDef.length; i < il; i++) {
      childPending.push(parser.getDependency("node", childrenDef[i]));
    }
    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
    return Promise.all([
      nodePending,
      Promise.all(childPending),
      skeletonPending
    ]).then(function(results) {
      const node = results[0];
      const children = results[1];
      const skeleton = results[2];
      if (skeleton !== null) {
        node.traverse(function(mesh) {
          if (!mesh.isSkinnedMesh)
            return;
          mesh.bind(skeleton, _identityMatrix);
        });
      }
      for (let i = 0, il = children.length; i < il; i++) {
        node.add(children[i]);
      }
      return node;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    if (this.nodeCache[nodeIndex] !== void 0) {
      return this.nodeCache[nodeIndex];
    }
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    const pending = [];
    const meshPromise = parser._invokeOne(function(ext) {
      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
    });
    if (meshPromise) {
      pending.push(meshPromise);
    }
    if (nodeDef.camera !== void 0) {
      pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
        return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
      }));
    }
    parser._invokeAll(function(ext) {
      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
    }).forEach(function(promise) {
      pending.push(promise);
    });
    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i = 0, il = objects.length; i < il; i++) {
          node.add(objects[i]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions)
        addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
    return this.nodeCache[nodeIndex];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(sceneIndex) {
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene = new Group();
    if (sceneDef.name)
      scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions)
      addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i = 0, il = nodeIds.length; i < il; i++) {
      pending.push(parser.getDependency("node", nodeIds[i]));
    }
    return Promise.all(pending).then(function(nodes) {
      for (let i = 0, il = nodes.length; i < il; i++) {
        scene.add(nodes[i]);
      }
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene);
      return scene;
    });
  }
  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
    const tracks = [];
    const targetName = node.name ? node.name : node.uuid;
    const targetNames = [];
    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
      node.traverse(function(object) {
        if (object.morphTargetInfluences) {
          targetNames.push(object.name ? object.name : object.uuid);
        }
      });
    } else {
      targetNames.push(targetName);
    }
    let TypedKeyframeTrack;
    switch (PATH_PROPERTIES[target.path]) {
      case PATH_PROPERTIES.weights:
        TypedKeyframeTrack = NumberKeyframeTrack;
        break;
      case PATH_PROPERTIES.rotation:
        TypedKeyframeTrack = QuaternionKeyframeTrack;
        break;
      case PATH_PROPERTIES.position:
      case PATH_PROPERTIES.scale:
        TypedKeyframeTrack = VectorKeyframeTrack;
        break;
      default:
        switch (outputAccessor.itemSize) {
          case 1:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case 2:
          case 3:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        break;
    }
    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
    const outputArray = this._getArrayFromAccessor(outputAccessor);
    for (let j = 0, jl = targetNames.length; j < jl; j++) {
      const track = new TypedKeyframeTrack(
        targetNames[j] + "." + PATH_PROPERTIES[target.path],
        inputAccessor.array,
        outputArray,
        interpolation
      );
      if (sampler.interpolation === "CUBICSPLINE") {
        this._createCubicSplineTrackInterpolant(track);
      }
      tracks.push(track);
    }
    return tracks;
  }
  _getArrayFromAccessor(accessor) {
    let outputArray = accessor.array;
    if (accessor.normalized) {
      const scale = getNormalizedComponentScale(outputArray.constructor);
      const scaled = new Float32Array(outputArray.length);
      for (let j = 0, jl = outputArray.length; j < jl; j++) {
        scaled[j] = outputArray[j] * scale;
      }
      outputArray = scaled;
    }
    return outputArray;
  }
  _createCubicSplineTrackInterpolant(track) {
    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
      const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
    };
    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
  }
};
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max = accessor.max;
    if (min !== void 0 && max !== void 0) {
      box.set(
        new Vector3(min[0], min[1], min[2]),
        new Vector3(max[0], max[1], max[2])
      );
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector = new Vector3();
    for (let i = 0, il = targets.length; i < il; i++) {
      const target = targets[i];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max = accessor.max;
        if (min !== void 0 && max !== void 0) {
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere = new Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes)
      continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  if (ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in attributes) {
    console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}

// node_modules/troika-xr/dist/troika-xr.esm.js
var XRLauncher = class extends import_react2.default.PureComponent {
  constructor(props) {
    super(props);
    this._onClick = this._onClick.bind(this);
  }
  _onClick() {
    this.props.onSelectSession(this.props.xrSession ? null : "immersive-vr");
  }
  render() {
    const props = this.props;
    return import_react2.default.createElement(
      "button",
      {
        onClick: this._onClick,
        disabled: !props.xrSupported
      },
      props.xrSupported ? props.xrSession ? "Exit XR" : "Enter XR" : "XR Not Available"
    );
  }
};
var cursorGeom = new SphereGeometry();
var cursorMaterial = new MeshBasicMaterial({ color: 16777215 });
var tempVec3 = new Vector3();
var tempQuat = new Quaternion();
var degToRadMult = Math.PI / 180;
var CursorFacade = class extends Object3DFacade {
  constructor(parent) {
    super(parent, new Mesh(
      cursorGeom,
      cursorMaterial.clone()
    ));
    this.size = 0.3;
    this.defaultDistance = 0;
  }
  afterUpdate() {
    const { rayIntersection, defaultDistance, targetRayPose } = this;
    let point = rayIntersection && rayIntersection.point;
    if (!point && defaultDistance && targetRayPose) {
      point = tempVec3.set(0, 0, -1).multiplyScalar(defaultDistance).applyQuaternion(tempQuat.copy(targetRayPose.transform.orientation)).add(targetRayPose.transform.position);
    }
    if (point) {
      point.copy.call(this, point);
      this.scale = point.distanceTo(this.getCameraPosition()) * Math.sin(this.size * degToRadMult);
      this.visible = true;
    } else {
      this.visible = false;
    }
    super.afterUpdate();
  }
};
var TARGET_RAY_RENDERORDER = 1e8;
function copyXRPoseToFacadeProps(pose, facade) {
  if (pose && facade) {
    const { position, orientation } = pose.transform;
    facade.x = position.x;
    facade.y = position.y;
    facade.z = position.z;
    facade.quaternionX = orientation.x;
    facade.quaternionY = orientation.y;
    facade.quaternionZ = orientation.z;
    facade.quaternionW = orientation.w;
  }
}
var getGeometry = () => {
  const geometry = new CylinderGeometry(1, 1, 1, 4, 1, false).translate(0, 0.5, 0).rotateY(Math.PI / 4).rotateX(Math.PI / -2);
  getGeometry = () => geometry;
  return geometry;
};
var getMaterial = () => {
  const material = createDerivedMaterial(
    new MeshBasicMaterial({
      transparent: true,
      opacity: 0.5,
      color: 16777215,
      depthTest: false
    }),
    {
      vertexDefs: `varying float dist;`,
      vertexMainIntro: `dist = -position.z;`,
      fragmentDefs: `varying float dist;`,
      fragmentColorTransform: `gl_FragColor.a *= smoothstep(1.0, 0.6, dist);`
    }
  );
  getMaterial = () => material;
  return material;
};
var TargetRayFacade = class extends Object3DFacade {
  constructor(parent) {
    super(parent, new Group());
    this.threeObject.add(this.laserMesh = new Mesh(getGeometry(), getMaterial()));
    this.radius = 3e-3;
    this.startDistance = 0.05;
    this.maxLength = 0.4;
    this.renderOrder = TARGET_RAY_RENDERORDER;
  }
  afterUpdate() {
    const { laserMesh, targetRayPose, radius, rayIntersection, startDistance, maxLength } = this;
    if (targetRayPose) {
      copyXRPoseToFacadeProps(targetRayPose, this);
      laserMesh.scale.set(
        radius,
        radius,
        (rayIntersection ? Math.min(rayIntersection.distance, maxLength) : maxLength) - startDistance
      );
      laserMesh.position.z = -startDistance;
      laserMesh.visible = true;
    } else {
      laserMesh.visible = false;
    }
    super.afterUpdate();
  }
};
var getGeometry$1 = () => {
  const geometry = new CylinderGeometry(0.03, 0.05, 0.1, 8).rotateX(Math.PI / -2).translate(0, 0, 0.05);
  getGeometry$1 = () => geometry;
  return geometry;
};
var getMaterial$1 = () => {
  const material = new MeshStandardMaterial({
    color: 6710886,
    emissive: 6710886,
    roughness: 0.5,
    metalness: 0.5
  });
  getMaterial$1 = () => material;
  return material;
};
var Basic = class extends Object3DFacade {
  constructor(parent) {
    const mesh = new Mesh(getGeometry$1(), getMaterial$1());
    super(parent, mesh);
  }
};
var GLTFFacade = class extends Object3DFacade {
  constructor(parent) {
    super(parent, new Group());
    this.url = null;
    this.rootTransform = null;
    this.autoDispose = true;
  }
  afterUpdate() {
    let { url } = this;
    if (url !== this._url) {
      this._url = url;
      this.removeObjects();
      if (url) {
        let loader = new GLTFLoader();
        loader.setCrossOrigin("anonymous");
        loader.load(
          url,
          (result) => {
            this.onLoad(result);
          },
          null,
          (err) => {
            console.error("Failed loading controller model", err);
          }
        );
      }
    }
    super.afterUpdate();
  }
  onLoad(gltf) {
    if (this.threeObject) {
      gltf = this.normalize(gltf);
      let root = gltf.scene;
      if (this.rootTransform) {
        root.applyMatrix4(this.rootTransform);
      }
      this.threeObject.add(root);
      root.updateMatrixWorld(true);
      this.gltf = gltf;
      this.afterUpdate();
    }
  }
  normalize(gltf) {
    return gltf;
  }
  removeObjects() {
    const { gltf } = this;
    if (gltf && gltf.scene) {
      if (this.autoDispose) {
        gltf.scene.traverse(({ geometry, material }) => {
          if (geometry) {
            geometry.dispose();
          }
          if (material) {
            if (material.texture) {
              material.texture.dispose();
            }
            material.dispose();
          }
        });
      }
      if (this.threeObject) {
        this.threeObject.remove(gltf.scene);
      }
      this.gltf = null;
    }
  }
  destructor() {
    this.removeObjects();
    super.destructor();
  }
};
var MODEL_GEN = "gen2";
function getModelUrl(gen, hand) {
  return `https://cdn.aframe.io/controllers/oculus/oculus-touch-controller-${gen}-${hand}.gltf`;
}
var MODEL_PARAMS = {
  gen1: {
    left: {
      url: getModelUrl("gen1", "left"),
      transform: new Matrix4().compose(
        new Vector3(0, 0, -0.1),
        new Quaternion(),
        new Vector3(1, 1, 1)
      )
    },
    right: {
      url: getModelUrl("gen1", "right"),
      transform: new Matrix4().compose(
        new Vector3(0, 0, -0.1),
        new Quaternion(),
        new Vector3(1, 1, 1)
      )
    }
  },
  gen2: {
    left: {
      url: getModelUrl("gen2", "left"),
      transform: new Matrix4().compose(
        new Vector3(0.01, -0.01, -0.05),
        new Quaternion().setFromEuler(new Euler(-0.67, 0, 0)),
        new Vector3(1, 1, 1)
      )
    },
    right: {
      url: getModelUrl("gen2", "right"),
      transform: new Matrix4().compose(
        new Vector3(-0.01, -0.01, -0.05),
        new Quaternion().setFromEuler(new Euler(-0.67, 0, 0)),
        new Vector3(1, 1, 1)
      )
    }
  }
};
var OculusTouchGrip = class extends GLTFFacade {
  /**
   * @property bodyColor
   * @property emissive
   * @property emissiveIntensity
   * @property buttonColor
   * @property buttonActiveColor
   */
  constructor(parent) {
    super(parent);
    this.xrInputSource = null;
    this.bodyColor = 10066329;
    this.buttonColor = 16777215;
    this.buttonActiveColor = 13434828;
    this.emissiveIntensity = 0.3;
  }
  afterUpdate() {
    let hand = this.xrInputSource.handedness;
    if (hand !== "left" && hand !== "right") {
      hand = "left";
    }
    if (hand !== this._hand) {
      this._hand = hand;
      this.url = MODEL_PARAMS[MODEL_GEN][hand].url;
      this.rootTransform = MODEL_PARAMS[MODEL_GEN][hand].transform;
    }
    this.updateMaterials();
    super.afterUpdate();
  }
  normalize(gltf) {
    this.meshes = /* @__PURE__ */ Object.create(null);
    gltf.scene.traverse((obj) => {
      if (obj.isMesh) {
        obj.material = obj.material.clone();
        this.meshes[obj.name] = obj;
      }
    });
    return gltf;
  }
  updateMaterials() {
    const { meshes } = this;
    if (meshes) {
      for (let name in meshes) {
        const color = name === "body" ? this.bodyColor : this.buttonColor;
        const material = meshes[name].material;
        if (color !== material._lastColor) {
          material.color.set(color);
          material.emissive.set(color);
          material._lastColor = color;
        }
        material.emissiveIntensity = this.emissiveIntensity;
      }
    }
  }
};
var PROFILE_MODELS = [
  /*{
    match: xrInputSource => {
      return true //TODO
    },
    facade: HandsGrip
  },*/
  {
    match: (xrInputSource) => {
      return /Oculus/.test(navigator.userAgent) || xrInputSource.profiles && xrInputSource.profiles.some((profile) => /oculus-touch/.test(profile));
    },
    facade: OculusTouchGrip
  },
  {
    match: (xrInputSource) => true,
    facade: Basic,
    space: "targetRay"
  }
];
function findModelConfig(xrInputSource) {
  for (let i = 0; i < PROFILE_MODELS.length; i++) {
    if (PROFILE_MODELS[i].match(xrInputSource)) {
      const result = utils.assign({}, PROFILE_MODELS[i]);
      delete result.match;
      return result;
    }
  }
}
var GripFacade = class extends Group3DFacade {
  afterUpdate() {
    const { xrInputSource } = this;
    let modelConfig = this.modelConfig;
    if (xrInputSource && xrInputSource !== this._lastSource) {
      this._lastSource = xrInputSource;
      modelConfig = this.modelConfig = findModelConfig(xrInputSource);
      if (modelConfig) {
        modelConfig.xrInputSource = xrInputSource;
      }
    }
    if (modelConfig) {
      const pose = modelConfig.space === "targetRay" ? this.targetRayPose : this.gripPose;
      this.visible = !!pose;
      if (pose) {
        copyXRPoseToFacadeProps(pose, this);
      }
      modelConfig.rayIntersection = this.rayIntersection;
    }
    this.children = modelConfig || null;
    super.afterUpdate();
  }
};
var BUTTON_TRIGGER = 0;
var BUTTON_SQUEEZE = 1;
var BUTTON_TOUCHPAD = 2;
var BUTTON_THUMBSTICK = 3;
var BUTTON_DEFAULT_BACK = 5;
var AXIS_TOUCHPAD_X = 0;
var AXIS_TOUCHPAD_Y = 1;
var AXIS_THUMBSTICK_X = 2;
var AXIS_THUMBSTICK_Y = 3;
var SCENE_EVENTS = ["mousemove", "mouseover", "mouseout", "mousedown", "mouseup", "click"];
var XRSESSION_EVENTS = ["selectstart", "selectend", "squeezestart", "squeezeend"];
var CLICK_MAX_DUR = 300;
var HAPTICS = {
  //TODO allow control
  mouseover: { value: 0.3, duration: 10 },
  click: { value: 1, duration: 20 }
};
var DEFAULT_CURSOR = {
  facade: CursorFacade
};
var DEFAULT_TARGET_RAY = {
  facade: TargetRayFacade
};
var DEFAULT_GRIP = {
  facade: GripFacade
};
function toggleEvents(target, on, eventTypes, handler) {
  if (target) {
    eventTypes.forEach((type) => {
      target[`${on ? "add" : "remove"}EventListener`](type, handler);
    });
  }
}
var XRInputSourceFacade = class extends Group3DFacade {
  constructor(parent) {
    super(parent);
    this.isXRInputSource = true;
    this.xrInputSource = null;
    this.xrSession = null;
    this.xrReferenceSpace = null;
    this.targetRayPose = null;
    this.gripPose = null;
    this.rayIntersection = null;
    this.cursor = utils.assign(DEFAULT_CURSOR);
    this.targetRay = utils.assign(DEFAULT_TARGET_RAY);
    this.grip = utils.assign(DEFAULT_GRIP);
    this.isPointing = true;
    this.clickOnPoke = false;
    this.children = [
      null,
      //cursor
      null,
      //targetRay
      null
      //grip
    ];
    this._ray = new Ray();
    this._onSessionEvent = this._onSessionEvent.bind(this);
    this._onSceneRayEvent = this._onSceneRayEvent.bind(this);
    this.addEventListener("xrframe", this._onXrFrame.bind(this));
    toggleEvents(this.getSceneFacade(), true, SCENE_EVENTS, this._onSceneRayEvent);
  }
  afterUpdate() {
    const { xrSession, _lastXrSession, xrInputSource, rayIntersection, children, isPointing, cursor, targetRay, grip, targetRayPose, gripPose } = this;
    if (xrSession !== _lastXrSession) {
      this._lastXrSession = xrSession;
      toggleEvents(_lastXrSession, false, XRSESSION_EVENTS, this._onSessionEvent);
      if (!this._isXrStandardGamepad()) {
        toggleEvents(xrSession, true, XRSESSION_EVENTS, this._onSessionEvent);
      }
    }
    let cursorCfg = null, targetRayCfg = null, gripCfg = null;
    if (xrInputSource.targetRayMode !== "screen") {
      cursorCfg = isPointing && cursor;
      if (cursorCfg) {
        cursorCfg.key = "cursor";
        cursorCfg.targetRayPose = targetRayPose;
        cursorCfg.gripPose = gripPose;
        cursorCfg.rayIntersection = rayIntersection;
        cursorCfg.xrInputSource = xrInputSource;
      }
    }
    if (xrInputSource.targetRayMode === "tracked-pointer") {
      targetRayCfg = isPointing && targetRay;
      if (targetRayCfg) {
        targetRayCfg.key = "targetRay";
        targetRayCfg.targetRayPose = targetRayPose;
        targetRayCfg.gripPose = gripPose;
        targetRayCfg.rayIntersection = rayIntersection;
        targetRayCfg.xrInputSource = xrInputSource;
      }
      gripCfg = gripPose ? grip : null;
      if (gripCfg) {
        gripCfg.key = "grip";
        gripCfg.targetRayPose = targetRayPose;
        gripCfg.gripPose = gripPose;
        gripCfg.rayIntersection = rayIntersection;
        gripCfg.xrInputSource = xrInputSource;
      }
    }
    children[0] = cursorCfg;
    children[1] = targetRayCfg;
    children[2] = gripCfg;
    super.afterUpdate();
  }
  _onXrFrame(time, xrFrame) {
    const { xrInputSource, isPointing, _ray: ray } = this;
    const offsetReferenceSpace = this.getCameraFacade().offsetReferenceSpace;
    if (offsetReferenceSpace) {
      const { targetRaySpace, gripSpace } = xrInputSource;
      const targetRayPose = xrFrame.getPose(targetRaySpace, offsetReferenceSpace);
      if (targetRayPose && isPointing) {
        ray.origin.copy(targetRayPose.transform.position);
        ray.direction.set(0, 0, -1).applyQuaternion(targetRayPose.transform.orientation);
        this.notifyWorld("rayPointerMotion", ray);
      }
      this.targetRayPose = targetRayPose;
      this.gripPose = gripSpace ? xrFrame.getPose(gripSpace, offsetReferenceSpace) : null;
    }
    if (this._isXrStandardGamepad()) {
      this._trackGamepadState(xrInputSource.gamepad);
    }
    this.afterUpdate();
  }
  _isXrStandardGamepad() {
    const { gamepad } = this.xrInputSource;
    return gamepad && gamepad.mapping === "xr-standard";
  }
  _trackGamepadState(gamepad) {
    const buttons = gamepad.buttons;
    const pressedTimes = this._buttonPresses || (this._buttonPresses = []);
    const now = Date.now();
    const ray = this._ray;
    for (let i = 0; i < buttons.length; i++) {
      if (buttons[i].pressed !== !!pressedTimes[i]) {
        if (this.isPointing) {
          this.notifyWorld("rayPointerAction", {
            ray,
            type: buttons[i].pressed ? "mousedown" : "mouseup",
            button: i
          });
          if (pressedTimes[i] && !buttons[i].pressed && now - pressedTimes[i] <= CLICK_MAX_DUR) {
            this.notifyWorld("rayPointerAction", {
              ray,
              type: "click",
              button: i
            });
          }
        }
        pressedTimes[i] = buttons[i].pressed ? now : null;
      }
      pressedTimes.length = buttons.length;
    }
    const axes = gamepad.axes;
    for (let i = 0; i < axes.length; i += 2) {
      const deltaX = (axes[i] || 0) * 10;
      const deltaY = (axes[i + 1] || 0) * 10;
      if (Math.hypot(deltaX, deltaY) > 0.1) {
        if (this.isPointing) {
          this.notifyWorld("rayPointerAction", {
            ray,
            type: "wheel",
            deltaX,
            deltaY,
            deltaMode: 0
            //pixel mode
          });
        }
      }
    }
  }
  _onSessionEvent(e) {
    if (e.inputSource === this.xrInputSource) {
      const button = /^squeeze/.test(e.type) ? BUTTON_SQUEEZE : BUTTON_TRIGGER;
      this.notifyWorld("rayPointerAction", {
        ray: this._ray,
        type: /start$/.test(e.type) ? "mousedown" : "mouseup",
        button
      });
      if (/end$/.test(e.type)) {
        this.notifyWorld("rayPointerAction", {
          ray: this._ray,
          type: "click",
          button
        });
      }
    }
  }
  _onSceneRayEvent(e) {
    if (e.nativeEvent.eventSource === this) {
      const { gamepad, targetRayMode } = this.xrInputSource;
      this.rayIntersection = e.intersection;
      this.afterUpdate();
      if (gamepad) {
        const isScene = e.target === e.currentTarget;
        const hapticPulse = e.type === "click" ? HAPTICS.click : e.type === "mouseover" && !isScene ? HAPTICS.mouseover : null;
        if (hapticPulse) {
          const hapticActuator = gamepad.hapticActuators && gamepad.hapticActuators[0];
          if (hapticActuator) {
            hapticActuator.pulse(hapticPulse.value || 1, hapticPulse.duration || 100);
          }
        }
      }
      let defaultPrevented = e.defaultPrevented;
      const fireEvent = (type) => {
        if (type) {
          const customEvent = new Event(type, { bubbles: true });
          customEvent.eventSource = this;
          e.target.dispatchEvent(customEvent);
          defaultPrevented = defaultPrevented || customEvent.defaultPrevented;
        }
      };
      fireEvent(RAY_TARGET_EVENTS[e.button] && RAY_TARGET_EVENTS[e.button][e.type]);
      if (!defaultPrevented && e.type === "click" && e.button === BUTTON_DEFAULT_BACK) {
        this.notifyWorld("endXRSession");
      }
      if (targetRayMode === "tracked-pointer" && this.clickOnPoke) {
        this._checkPokeGesture(e);
      }
    }
  }
  _checkPokeGesture(e) {
    const DEBOUNCE = 500;
    const RAY_DISTANCE = 0.1;
    const { intersection, target } = e;
    const pokeState = this._pokeState || (this._pokeState = { target: null, isPoking: false, time: 0 });
    const isPoking = !!intersection && intersection.distance < RAY_DISTANCE;
    if (isPoking && (!pokeState.isPoking || target !== pokeState.target) && Date.now() - pokeState.time > DEBOUNCE) {
      pokeState.time = Date.now();
      this.notifyWorld("rayPointerAction", {
        ray: e.ray,
        type: "click",
        button: BUTTON_TRIGGER
      });
    }
    pokeState.isPoking = isPoking;
    pokeState.target = target;
  }
  destructor() {
    toggleEvents(this.xrSession, false, XRSESSION_EVENTS, this._onSessionEvent);
    toggleEvents(this.getSceneFacade(), false, SCENE_EVENTS, this._onSceneRayEvent);
    super.destructor();
  }
};
var RAY_TARGET_EVENTS = {
  [BUTTON_TRIGGER]: {
    mousedown: "xrselectstart",
    mouseup: "xrselectend",
    click: "xrselect"
  },
  [BUTTON_SQUEEZE]: {
    mousedown: "xrsqueezestart",
    mouseup: "xrsqueezeend",
    click: "xrsqueeze"
  }
  // TODO decide on event names, and handle touching without press:
  // all: {
  //   mousedown: 'xrbuttondown',
  //   mouseup: 'xrbuttonup',
  //   click: 'xrbuttonclick'
  // }
};
Facade.defineEventProperty(Object3DFacade, "onXRSelectStart", "xrselectstart");
Facade.defineEventProperty(Object3DFacade, "onXRSelect", "xrselect");
Facade.defineEventProperty(Object3DFacade, "onXRSelectEnd", "xrselectend");
Facade.defineEventProperty(Object3DFacade, "onXRSqueezeStart", "xrsqueezestart");
Facade.defineEventProperty(Object3DFacade, "onXRSqueeze", "xrsqueeze");
Facade.defineEventProperty(Object3DFacade, "onXRSqueezeEnd", "xrsqueezeend");
var XRInputSourceManager = class extends ParentFacade {
  constructor(parent) {
    super(parent);
    this._sourcesDirty = true;
    this.xrSession = null;
    this.xrReferenceSpace = null;
    this._xrInputSourceSubtree = new ParentFacade(this);
    this._onInputSourcesChange = (e) => {
      this._sourcesDirty = true;
      this.afterUpdate();
    };
  }
  afterUpdate() {
    const { xrSession, _lastXrSession } = this;
    if (xrSession !== _lastXrSession) {
      this._lastXrSession = xrSession;
      if (_lastXrSession) {
        _lastXrSession.removeEventListener("inputsourceschange", this._onInputSourcesChange);
      }
      if (xrSession) {
        xrSession.addEventListener("inputsourceschange", this._onInputSourcesChange);
      }
    }
    if (this._sourcesDirty) {
      this._sourcesDirty = false;
      const inputSources = xrSession && xrSession.inputSources;
      this._xrInputSourceSubtree.children = inputSources && Array.from(inputSources).map((xrInputSource) => {
        return {
          facade: XRInputSourceFacade,
          key: utils.getIdForObject(xrInputSource),
          xrInputSource,
          xrSession: this.xrSession,
          xrReferenceSpace: this.xrReferenceSpace
        };
      });
      this._xrInputSourceSubtree.afterUpdate();
    }
    super.afterUpdate();
  }
  destructor() {
    if (this.xrSession) {
      this.xrSession.removeEventListener("inputsourceschange", this._onInputSourcesChange);
    }
    super.destructor();
    this._xrInputSourceSubtree.destructor();
  }
};
var tempVec3$1 = new Vector3();
var tempVec3b = new Vector3();
var tempQuat$1 = new Quaternion();
var dummyObj = {};
var tempMat4 = new Matrix4();
function extendAsXRCamera(BaseCameraFacadeClass) {
  return doExtendAsXRCamera(BaseCameraFacadeClass || PerspectiveCamera3DFacade);
}
var doExtendAsXRCamera = utils.createClassExtender("xrCamera", function(BaseCameraFacadeClass) {
  return class XRCameraFacade extends BaseCameraFacadeClass {
    constructor(parent) {
      super(parent);
      this.xrSession = null;
      this.xrReferenceSpace = null;
      const mainCam = this.threeObject;
      mainCam.isArrayCamera = true;
      mainCam.cameras = [];
      this.offsetReferenceSpace = null;
      this.addEventListener("xrframe", this._onXrFrame.bind(this));
    }
    afterUpdate() {
      const { near, far, xrSession } = this;
      const { depthNear, depthFar } = xrSession.renderState;
      if (near !== depthNear || far !== depthFar) {
        xrSession.updateRenderState({
          depthNear: near,
          depthFar: far
        });
      }
      super.afterUpdate();
    }
    updateMatrices() {
      const { xrReferenceSpace } = this;
      const offsetChanging = this._matrixChanged || xrReferenceSpace !== this._lastRefSpace;
      super.updateMatrices();
      if (offsetChanging) {
        this._lastRefSpace = xrReferenceSpace;
        invertMatrix4(this.threeObject.matrix, tempMat4).decompose(tempVec3$1, tempQuat$1, dummyObj);
        this.offsetReferenceSpace = xrReferenceSpace ? xrReferenceSpace.getOffsetReferenceSpace(new XRRigidTransform(tempVec3$1, tempQuat$1)) : null;
      }
    }
    /**
     * Handle syncing the cameras to the current XRFrame's pose data
     */
    _onXrFrame(timestamp, xrFrame) {
      const { xrSession, offsetReferenceSpace, threeObject: mainCam } = this;
      const pose = offsetReferenceSpace && xrFrame.getViewerPose(offsetReferenceSpace);
      if (pose && xrSession && xrSession.renderState.baseLayer) {
        const views = pose.views;
        const viewCameras = mainCam.cameras;
        while (viewCameras.length > views.length) {
          mainCam.layers.disable(viewCameras.length--);
        }
        for (let i = 0; i < views.length; i++) {
          const view = views[i];
          let viewCam = viewCameras[i];
          if (!viewCam) {
            viewCam = viewCameras[i] = new PerspectiveCamera();
            viewCam.viewport = new Vector4();
            viewCam.layers.enable(i + 1);
            mainCam.layers.enable(i + 1);
          }
          const viewport = xrSession.renderState.baseLayer.getViewport(view);
          viewCam.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          viewCam.matrixWorld.fromArray(view.transform.matrix);
          viewCam.matrixWorldInverse.fromArray(view.transform.inverse.matrix);
          viewCam.projectionMatrix.fromArray(view.projectionMatrix);
        }
        if (views.length === 2) {
          setProjectionFromUnion(mainCam, viewCameras[0], viewCameras[1]);
        }
      }
    }
  };
});
function setProjectionFromUnion(camera, cameraL, cameraR) {
  tempVec3$1.setFromMatrixPosition(cameraL.matrixWorld);
  tempVec3b.setFromMatrixPosition(cameraR.matrixWorld);
  const ipd = tempVec3$1.distanceTo(tempVec3b);
  const projL = cameraL.projectionMatrix.elements;
  const projR = cameraR.projectionMatrix.elements;
  const near = projL[14] / (projL[10] - 1);
  const far = projL[14] / (projL[10] + 1);
  const topFov = (projL[9] + 1) / projL[5];
  const bottomFov = (projL[9] - 1) / projL[5];
  const leftFov = (projL[8] - 1) / projL[0];
  const rightFov = (projR[8] + 1) / projR[0];
  const left = near * leftFov;
  const right = near * rightFov;
  const zOffset = ipd / (-leftFov + rightFov);
  const xOffset = zOffset * -leftFov;
  cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
  camera.translateX(xOffset);
  camera.translateZ(zOffset);
  camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
  invertMatrix4(camera.matrixWorld, camera.matrixWorldInverse);
  const near2 = near + zOffset;
  const far2 = far + zOffset;
  const left2 = left - xOffset;
  const right2 = right + (ipd - xOffset);
  const top2 = topFov * far / far2 * near2;
  const bottom2 = bottomFov * far / far2 * near2;
  camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
}
var emptyArray = [];
var tempVec2 = new Vector2();
var _xrSessions = /* @__PURE__ */ new WeakMap();
var WorldXRFacade = class extends World3DFacade {
  /**
   * Relevant things passed in from XRAware:
   * @property {XRSession} xrSession
   * @property {XRSessionMode} xrSessionMode
   * @property {XRReferenceSpace} xrReferenceSpace
   * @property {XRReferenceSpaceType} xrReferenceSpaceType
   * @property {number|string} xrFramebufferScaleFactor
   *
   * New global event types:
   * `xrframe` - fired on each frame, with the current time and XRFrame object as arguments
   */
  afterUpdate() {
    this._togglePointerListeners(!this._isImmersive());
    super.afterUpdate();
    const { xrSession, _threeRenderer: renderer } = this;
    const prevXrSession = _xrSessions.get(this);
    if (xrSession !== prevXrSession) {
      _xrSessions.set(this, xrSession);
      this.renderingScheduler = xrSession || window;
      setAnimationScheduler(xrSession || window);
      if (xrSession) {
        let baseLayer = xrSession.renderState.baseLayer;
        const gl = renderer.getContext();
        if (baseLayer && baseLayer._glContext === gl) {
          bindFramebuffer(renderer, baseLayer.framebuffer);
        } else {
          const promise = gl.makeXRCompatible ? gl.makeXRCompatible() : Promise.resolve();
          promise.then(() => {
            if (this.xrSession === xrSession) {
              baseLayer = new XRWebGLLayer(xrSession, gl, {
                antialias: !!renderer.getContextAttributes().antialias,
                framebufferScaleFactor: parseFramebufferScaleFactor(this.xrFramebufferScaleFactor, xrSession)
              });
              baseLayer._glContext = gl;
              xrSession.updateRenderState({ baseLayer });
              bindFramebuffer(renderer, baseLayer.framebuffer);
              this._queueRender();
            }
          });
        }
      } else {
        bindFramebuffer(renderer, null);
        renderer.setRenderTarget(renderer.getRenderTarget());
        renderer.getSize(tempVec2);
        renderer.setDrawingBufferSize(tempVec2.x, tempVec2.y, renderer.getPixelRatio());
        this._queueRender();
      }
    }
  }
  /**
   * @override
   */
  doRender(timestamp, xrFrame) {
    if (xrFrame && xrFrame.session) {
      this.eventRegistry.forEachListenerOfType("xrframe", (fn) => fn(timestamp, xrFrame), this);
    }
    super.doRender();
  }
  _isOpaque() {
    return this.xrSession && this.xrSession.environmentBlendMode === "opaque";
  }
  _isImmersive() {
    return this.xrSession && this.xrSessionMode !== "inline";
  }
  /**
   * @override to use an XR stereo camera when in immersive XR mode
   */
  _getCameraDef() {
    const camera = super._getCameraDef();
    if (this._isImmersive()) {
      camera.facade = extendAsXRCamera(camera.facade);
      camera.xrSession = this.xrSession;
      camera.xrReferenceSpace = this.xrReferenceSpace;
    }
    return camera;
  }
  /**
   * @override to add VR controllers manager object
   */
  _getSceneDef() {
    const scene = super._getSceneDef();
    const { xrSession, xrReferenceSpace } = this;
    if (xrSession && xrReferenceSpace) {
      scene.objects = emptyArray.concat(
        scene.objects,
        {
          key: "xrInputMgr",
          facade: XRInputSourceManager,
          xrSession,
          xrReferenceSpace
        }
      );
    }
    return scene;
  }
  /**
   * @override to always continuously render when in XR
   */
  _isContinuousRender() {
    return this.xrSession || this.continuousRender;
  }
  /**
   * @override to skip rendering HTML overlays when in immersive mode
   */
  _doRenderHtmlItems() {
    if (this._isImmersive()) {
      if (this.renderHtmlItems) {
        this.renderHtmlItems(emptyArray);
      }
    } else {
      super._doRenderHtmlItems();
    }
  }
};
WorldXRFacade.prototype._notifyWorldHandlers = Object.create(
  World3DFacade.prototype._notifyWorldHandlers,
  {
    // notification to end the XR session
    endXRSession: {
      value: function(source, data) {
        if (this.xrSession) {
          this.xrSession.end();
        }
      }
    }
  }
);
function parseFramebufferScaleFactor(value, xrSession) {
  let scale = 1;
  if (value != null) {
    if (typeof value === "string") {
      if (/native/.test(value)) {
        const mult = +value.replace(/\s*native\s*/, "") || 1;
        const nativeScale = XRWebGLLayer.getNativeFramebufferScaleFactor(xrSession);
        scale = nativeScale * mult;
      }
    } else {
      scale = +value;
    }
    if (isNaN(scale))
      scale = 1;
  }
  return scale;
}
function bindFramebuffer(renderer, framebuffer) {
  if (renderer.setFramebuffer) {
    renderer.setFramebuffer(framebuffer);
  } else if (renderer.state.bindXRFramebuffer) {
    renderer.state.bindXRFramebuffer(framebuffer);
  } else {
    renderer.state.bindFramebuffer(framebuffer);
  }
}
var SESSION_MODES = ["inline", "immersive-vr"];
var REFERENCE_SPACE_TYPES = ["viewer", "local", "local-floor", "bounded-floor", "unbounded"];
var XRAwarePropTypes = {
  xrSupported: import_prop_types2.default.bool,
  xrSupportedSessionModes: import_prop_types2.default.arrayOf(import_prop_types2.default.oneOf(SESSION_MODES)),
  xrSession: import_prop_types2.default.object,
  xrSessionMode: import_prop_types2.default.oneOf(SESSION_MODES),
  xrReferenceSpace: import_prop_types2.default.object,
  xrReferenceSpaceType: import_prop_types2.default.oneOf(REFERENCE_SPACE_TYPES),
  xrLauncher: import_prop_types2.default.element
};
function ReactXRAware(ReactClass, options) {
  options = utils.assign({
    xrLauncherRenderer: XRLauncher,
    sessionModes: ["immersive-vr"],
    referenceSpaces: ["bounded-floor", "local-floor"],
    framebufferScaleFactor: 1
  }, options);
  class XRAware extends import_react2.default.Component {
    constructor(props) {
      super(props);
      this.state = {
        xrSupportedSessionModes: [],
        xrSession: null,
        xrSessionMode: null,
        xrReferenceSpace: null,
        xrReferenceSpaceType: null
      };
      [
        "_checkXrSupport",
        "_onSessionEnded",
        "_onLauncherSelect"
      ].forEach((method) => {
        this[method] = this[method].bind(this);
      });
      const xr = navigator.xr;
      if (xr) {
        xr.addEventListener("devicechange", this._checkXrSupport);
      }
      this._checkXrSupport();
    }
    componentWillUnmount() {
      const xr = navigator.xr;
      if (xr) {
        xr.removeEventListener("devicechange", this._checkXrSupport);
      }
    }
    _checkXrSupport() {
      const xr = navigator.xr;
      if (xr) {
        const xrSupportedSessionModes = [];
        Promise.all(options.sessionModes.map((mode) => {
          if (typeof xr.isSessionSupported === "function") {
            return xr.isSessionSupported(mode).then((supported) => {
              if (supported) {
                xrSupportedSessionModes.push(mode);
              } else {
                console.info(`XR session type '${mode}' not supported`);
              }
            });
          } else {
            return xr.supportsSession(mode).then(() => {
              xrSupportedSessionModes.push(mode);
            }, (err) => {
              console.info(`XR session type '${mode}' not supported`, err);
            });
          }
        })).then(() => {
          this.setState({ xrSupportedSessionModes });
        });
      } else {
        this.setState({
          xrSupportedSessionModes: []
        });
      }
    }
    _startSession(xrSessionMode) {
      let { xrSupportedSessionModes, xrSession } = this.state;
      if (xrSession) {
        xrSession.end();
      }
      if (xrSupportedSessionModes.includes(xrSessionMode)) {
        const candidateRefSpaces = options.referenceSpaces;
        if (!candidateRefSpaces || !candidateRefSpaces.length) {
          console.error("XRAware `referencesSpaces` cannot be empty");
          return;
        }
        navigator.xr.requestSession(xrSessionMode, {
          optionalFeatures: candidateRefSpaces.slice(0, -1),
          requiredFeatures: candidateRefSpaces.slice(-1)
        }).then((xrSession2) => {
          xrSession2.addEventListener("end", this._onSessionEnded, false);
          const getRefSpace = (index = 0) => {
            const type = candidateRefSpaces[index];
            return xrSession2.requestReferenceSpace(type).then((xrReferenceSpace) => [xrReferenceSpace, type]).catch((err) => {
              console.debug(`Reference space ${type} not supported or denied by user.`, err);
              if (index + 1 === candidateRefSpaces.length) {
                throw new Error(`All requested referenceSpaces (${candidateRefSpaces.join(", ")}) are either unsupported or were denied by the user.`);
              } else {
                return getRefSpace(index + 1);
              }
            });
          };
          return getRefSpace().then(([xrReferenceSpace, xrReferenceSpaceType]) => {
            this.setState({
              xrSession: xrSession2,
              xrSessionMode,
              xrReferenceSpace,
              xrReferenceSpaceType
            });
          });
        }).catch((err) => {
          console.error(err);
        });
      }
    }
    _onSessionEnded(e) {
      e.session.removeEventListener("end", this._onSessionEnded, false);
      this.setState({
        xrSession: null,
        xrSessionMode: null,
        xrReferenceSpace: null,
        xrReferenceSpaceType: null
      });
    }
    _onLauncherSelect(mode) {
      this._startSession(mode);
    }
    render() {
      const { props, state } = this;
      const { xrSupportedSessionModes, xrSession, xrSessionMode, xrReferenceSpace, xrReferenceSpaceType } = state;
      const xrSupported = xrSupportedSessionModes.length > 0;
      const xrLauncher = import_react2.default.createElement(
        options.xrLauncherRenderer,
        {
          xrSupportedSessionModes,
          xrSupported,
          xrSession,
          onSelectSession: this._onLauncherSelect
        }
      );
      const contextValue = {
        worldFacade: WorldXRFacade,
        worldProps: {
          xrSession,
          xrSessionMode,
          xrReferenceSpace,
          xrReferenceSpaceType,
          xrFramebufferScaleFactor: options.framebufferScaleFactor
        }
      };
      return import_react2.default.createElement(
        Canvas3D.contextType.Provider,
        { value: contextValue },
        import_react2.default.createElement(
          ReactClass,
          utils.assign({}, props, {
            xrSupported,
            xrSupportedSessionModes,
            xrSession,
            xrSessionMode,
            xrReferenceSpace,
            xrReferenceSpaceType,
            xrLauncher
          }),
          props.children
        )
      );
    }
  }
  XRAware.displayName = `XRAware(${ReactClass.displayName || ReactClass.name || "?"})`;
  return XRAware;
}
var getStrapGeometry = utils.memoize(() => {
  return new CylinderGeometry(
    1,
    1,
    1,
    64,
    1,
    true
    // Math.PI / 4 * 3,
    // Math.PI / 4 * 6
  ).rotateX(Math.PI / 2);
});
var getStrapMaterial = utils.memoize(() => {
  return new MeshStandardMaterial({
    color: 3355443,
    side: DoubleSide
  });
});
var Strap = class extends Object3DFacade {
  constructor(parent) {
    super(parent, new Mesh(getStrapGeometry(), getStrapMaterial()));
  }
  set smallRadius(val) {
    this.scaleX = val;
  }
  set largeRadius(val) {
    this.scaleY = val;
  }
  set width(val) {
    this.scaleZ = val;
  }
};
var getCogGeometry = utils.memoize(() => {
  let outerRadius = 0.01;
  let innerRadius = 6e-3;
  let midRadius = (innerRadius + outerRadius) * 0.75;
  let teeth = 8;
  let twoPi = Math.PI * 2;
  let shape = new Shape().moveTo(midRadius, 0);
  for (let i = 0; i < teeth; i++) {
    let angle = i / teeth * twoPi;
    shape.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
    angle = (i + 0.5) / teeth * twoPi;
    shape.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
    shape.lineTo(Math.cos(angle) * midRadius, Math.sin(angle) * midRadius);
    if (i === teeth - 1) {
      shape.lineTo(midRadius, 0);
    } else {
      angle = (i + 1) / teeth * twoPi;
      shape.lineTo(Math.cos(angle) * midRadius, Math.sin(angle) * midRadius);
    }
  }
  shape.holes.push(
    new Path().absellipse(0, 0, innerRadius, innerRadius, 0, twoPi, false)
  );
  return new ExtrudeGeometry(shape, {
    curveSegments: teeth * 2,
    depth: 5e-3,
    bevelEnabled: false
  });
});
var Cog = class extends MeshFacade {
  get geometry() {
    return getCogGeometry();
  }
};
var tempVec3$2 = new Vector3();
var cogActiveAnim = {
  from: { rotateX: 0 },
  to: { rotateX: Math.PI * 2 },
  duration: 5e3,
  iterations: Infinity
};
var gripOffsetDist = 0.08;
var gripOffsetAngle = Math.PI / 4;
var largeRadius = 0.035;
var smallRadius = largeRadius * 0.75;
var strapWidth = 0.025;
var Wristband = class extends Group3DFacade {
  /**
   * Sync to the current XRFrame's gripPose - all matrix syncing is localized here
   * to avoid a full afterUpdate pass on every frame.
   */
  syncPose(gripPose) {
    if (gripPose) {
      this.visible = true;
      copyXRPoseToFacadeProps(gripPose, this);
      this.traverse(updateMatrices);
      if (this.onCogMove && this._cogFacade) {
        this.onCogMove(this._cogFacade.getWorldPosition(tempVec3$2));
      }
    } else {
      this.visible = false;
    }
  }
  describeChildren() {
    let { active } = this;
    let groupDef = this._childTpl || (this._childTpl = {
      key: "g",
      facade: Group3DFacade,
      rotateX: -gripOffsetAngle,
      y: gripOffsetDist * Math.cos(gripOffsetAngle),
      z: gripOffsetDist * Math.sin(gripOffsetAngle),
      children: [
        {
          key: "strap",
          facade: Strap,
          smallRadius,
          largeRadius,
          width: strapWidth
        },
        {
          key: "cog",
          facade: Cog,
          ref: (f) => {
            this._cogFacade = f;
          },
          rotateY: Math.PI / 2,
          x: smallRadius,
          animation: null,
          transition: {
            scale: {
              duration: 500,
              easing: "easeOutBack"
            },
            "material.color": {
              interpolate: "color"
            }
          }
        }
      ]
    });
    let [, cogDef] = groupDef.children;
    cogDef.scale = active ? 1.75 : 1;
    cogDef["material.color"] = active ? 3381759 : 10066329;
    cogDef.animation = active ? cogActiveAnim : null;
    return groupDef;
  }
};
function updateMatrices(obj) {
  if (obj.updateMatrices) {
    obj.updateMatrices();
  }
}
var vertexShader = `
varying vec2 vUV;
void main() {
  vUV = uv;
  if (uv.y == 0.0) { //src pos is worldspace
    gl_Position = projectionMatrix * viewMatrix * vec4(position, 1.0);
  } else {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
}
`;
var baseAlpha = 0.2;
var scanlines = [
  // sep = separation between lines
  // vel = movement speed, in scans per second
  // size = width of line's gradient
  // alpha = alpha to add at line's center
  { sep: 0.4, vel: 0.15, size: 0.1, alpha: 0.1 },
  { sep: 0.7, vel: 0.2, size: 0.15, alpha: 0.1 },
  { sep: 0.3, vel: 0.3, size: 0.1, alpha: 0.1 },
  { sep: 0.2, vel: 0.6, size: 0.1, alpha: 0.04 },
  { sep: 0.1, vel: 0.4, size: 0.02, alpha: 0.04 }
];
var fragmentShader = `
uniform float time;
uniform vec4 fade;
uniform vec3 color;
varying vec2 vUV;

float distToScanline(float x, float separation, float velocity) {
  x += time / 1000.0 * velocity;
  float dist = abs(x - round(x / separation) * separation);
  return dist;
}

void main() {
  float alpha = ${baseAlpha};
  ${scanlines.map(
  ({ sep, vel, size, alpha }) => `alpha += ${alpha} * smoothstep(${size / 2}, 0.0, distToScanline(vUV.y, ${sep}, ${vel}));`
).join("\n")}
  alpha *= min(smoothstep(fade.x, fade.y, vUV.y), smoothstep(fade.w, fade.z, vUV.y));
  gl_FragColor = vec4(color, alpha);
}
`;
var epoch = Date.now();
var defaultColor = 3381759;
var createMaterial = function() {
  return new ShaderMaterial({
    uniforms: {
      time: { get value() {
        return epoch - Date.now();
      } },
      color: { value: new Color() },
      fade: { value: new Vector4(0, 0.4, 0.7, 1) }
      //fade in+out gradient stops
    },
    vertexShader,
    fragmentShader,
    transparent: true
    // side: DoubleSide
  });
};
var Projection = class extends MeshFacade {
  constructor(parent) {
    super(parent);
    this.threeObject.frustumCulled = false;
    this.renderOrder = 99999;
    this.geometry = new BufferGeometry();
    this.autoDisposeGeometry = true;
    this.color = defaultColor;
    this.material = createMaterial();
  }
  syncSourcePosition() {
    let { sourceWorldPosition: srcPos } = this;
    let posAttr = this.threeObject.geometry.getAttribute("position");
    if (srcPos && posAttr && (srcPos.x !== posAttr.getX(0) || srcPos.y !== posAttr.getY(0) || srcPos.z !== posAttr.getZ(0))) {
      posAttr.setXYZ(0, srcPos.x, srcPos.y, srcPos.z);
      posAttr.needsUpdate = true;
    }
  }
  afterUpdate() {
    let { targetVertices, geometry, color } = this;
    let posAttr = this.geometry.getAttribute("position");
    if (!posAttr || posAttr._data !== targetVertices) {
      let posArr = new Float32Array(targetVertices.length + 3);
      posArr.set(targetVertices, 3);
      posAttr = new BufferAttribute(posArr, 3);
      posAttr.usage = DynamicDrawUsage;
      geometry.setAttribute("position", posAttr);
      let uvAttr = new BufferAttribute(new Float32Array(posAttr.count * 2), 2);
      for (let i = 1; i < uvAttr.count; i++) {
        uvAttr.setY(i, 1);
      }
      geometry.setAttribute("uv", uvAttr);
      let indexArr = [];
      for (let i = 1, len = targetVertices.length / 3; i <= len; i++) {
        indexArr.push(0, i === 1 ? len : i - 1, i);
      }
      geometry.setIndex(indexArr);
    }
    this.syncSourcePosition();
    if (color == null) {
      color = defaultColor;
    }
    if (color !== this._color) {
      this.material.uniforms.color.value.set(this._color = color);
    }
    super.afterUpdate();
  }
};
var tempMat4$1 = new Matrix4();
var targetPos = new Vector3();
var camPos = new Vector3();
var ContentContainer = class extends Object3DFacade {
  constructor(parent) {
    super(parent, new Group());
    this.distancePastGrip = 0.25;
    this.minDistanceFromCamera = 0.5;
    this.heightAboveGrip = 0.15;
    this.platformRadius = 0.25;
    this.projectionColor = null;
    this.projectionSourcePosition = null;
    this.gripPose = null;
    this.active = false;
    this.keepContentAlive = false;
  }
  /**
   * Sync to the current XRFrame's gripPose - all matrix syncing is localized here
   * to avoid a full afterUpdate pass on every frame.
   */
  syncPose(gripPose) {
    let visible = false;
    if (gripPose) {
      let cam = this.getCameraFacade().threeObject;
      camPos.setFromMatrixPosition(cam.matrixWorld).applyMatrix4(invertMatrix4(this.threeObject.parent.matrixWorld, tempMat4$1));
      let targetScale;
      if (this.active) {
        targetPos.copy(gripPose.transform.position);
        targetPos.y = camPos.y;
        targetPos.sub(camPos);
        targetPos.setLength(Math.max(this.minDistanceFromCamera, targetPos.length() + this.distancePastGrip));
        targetPos.add(camPos);
        targetPos.y = gripPose.transform.position.y + this.heightAboveGrip;
        targetScale = 1;
      } else {
        targetPos.copy(gripPose.transform.position);
        targetScale = 1e-3;
      }
      let pos = this.threeObject.position;
      pos.lerp(targetPos, 0.05);
      this.scale += (targetScale - this.scale) * 0.3;
      visible = this.scale > 0.01;
      if (visible) {
        this.rotateY = Math.atan2(camPos.x - pos.x, camPos.z - pos.z);
        let proj = this.getChildByKey("$projection");
        if (proj) {
          proj.syncSourcePosition();
        }
        this.traverse(updateMatrices$1);
      }
    }
    if (visible !== this.visible) {
      this.update({ visible });
    }
  }
  describeChildren() {
    if (!this.visible && !this.keepContentAlive) {
      return null;
    }
    let kids = this._kidsTpl || (this._kidsTpl = [
      {
        key: "$platform",
        facade: CircleFacade,
        radius: 1,
        material: "lambert",
        castShadow: true,
        receiveShadow: true,
        "material.color": 3355443
      },
      {
        key: "$projection",
        facade: Projection,
        sourceWorldPosition: new Vector3(),
        targetVertices: Object.freeze(function() {
          let verts = [];
          for (let i = 0; i < 32; i++) {
            let angle = Math.PI * 2 * (i / 32);
            verts.push(Math.cos(angle), 0, Math.sin(angle));
          }
          return verts;
        }())
      }
    ]);
    kids[0].scale = kids[1].scale = this.platformRadius;
    kids[1].sourceWorldPosition = this.projectionSourcePosition;
    kids[0]["material.color"] = this.platformColor;
    kids[1].color = this.projectionColor;
    return kids.concat(this.children);
  }
};
function updateMatrices$1(obj) {
  if (obj.updateMatrices) {
    obj.updateMatrices();
    obj._checkBoundsChange();
  }
}
var tempMat4$2 = new Matrix4();
var tempQuat$2 = new Quaternion();
var tempVec3$3 = new Vector3();
var upVec3 = new Vector3(0, 1, 0);
var WristMountedUI = class extends Group3DFacade {
  constructor(parent) {
    super(parent);
    this.activeUpAngle = Math.PI / 7;
    this.preferredHand = "left";
    this.platformRadius = 0.25;
    this.platformColor = 3355443;
    this.projectionColor = 3381759;
    this.keepContentAlive = false;
    this.onActiveChange = null;
    this.gripPose = null;
    this.active = false;
    this._cogPos = new Vector3();
    this.addEventListener("xrframe", this.onXRFrame.bind(this));
  }
  describeChildren() {
    if (!this.gripPose) {
      return null;
    }
    let children = this._childTpl || (this._childTpl = [
      {
        key: "wristband",
        facade: Wristband,
        active: false,
        gripPose: null,
        onCogMove: (worldPos) => {
          this._cogPos.copy(worldPos);
        }
      },
      {
        key: "content",
        facade: ContentContainer,
        active: false,
        gripPose: null,
        children: null
      }
    ]);
    let [wristbandDef, contentDef] = children;
    wristbandDef.active = contentDef.active = this.active;
    contentDef.platformRadius = this.platformRadius;
    contentDef.platformColor = this.platformColor;
    contentDef.projectionColor = this.projectionColor;
    contentDef.projectionSourcePosition = this._cogPos;
    contentDef.keepContentAlive = this.keepContentAlive;
    contentDef.children = this.children;
    return children;
  }
  updateMatrices() {
    this.threeObject.matrixWorld.copy(this.getCameraFacade().threeObject.matrix);
    this.markWorldMatrixDirty();
  }
  onXRFrame(time, xrFrame) {
    let gripPose = null;
    let active = false;
    let inputSources = xrFrame.session.inputSources;
    if (inputSources) {
      let gripSpace = null;
      for (let i = 0, len = inputSources.length; i < len; i++) {
        if (inputSources[i].handedness === this.preferredHand) {
          gripSpace = inputSources[i].gripSpace;
          break;
        }
      }
      if (gripSpace) {
        let cam = this.getCameraFacade();
        gripPose = xrFrame.getPose(gripSpace, cam.xrReferenceSpace);
        if (gripPose) {
          tempVec3$3.set(1, 0, 0).applyQuaternion(
            tempQuat$2.setFromRotationMatrix(tempMat4$2.fromArray(gripPose.transform.matrix))
          );
          active = tempVec3$3.angleTo(upVec3) < this.activeUpAngle;
        }
      }
    }
    if (active !== this.active) {
      if (this.onActiveChange) {
        this.onActiveChange(active);
      }
      this.update({ active });
    }
    if (!!gripPose !== !!this.gripPose) {
      this.update({ gripPose });
    } else if (gripPose) {
      this.forEachChild((child) => child.syncPose(gripPose));
    }
  }
};
var degreeToRad = Math.PI / 180;
var getMarkerGeometry = function() {
  const radius = 0.15;
  const innerRadius = 0.1;
  const depth = 0.05;
  const shape = new Shape();
  shape.moveTo(radius, -radius).lineTo(radius, 0).absellipse(0, 0, radius, radius, 0, 270 * degreeToRad, false, 0).lineTo(radius, -radius);
  shape.holes = [
    new Path().moveTo(innerRadius, -innerRadius).lineTo(0, -innerRadius).absellipse(0, 0, innerRadius, innerRadius, 270 * degreeToRad, 0, true, 0).lineTo(innerRadius, -innerRadius)
  ];
  const geom = new ExtrudeGeometry(shape, {
    curveSegments: 64,
    depth,
    bevelEnabled: false
    // bevelSize: 0.01,
    // bevelThickness: 0.01,
    // bevelSegments: 1
  }).rotateX(Math.PI / 2).rotateY(Math.PI / 4).translate(0, depth, 0);
  getMarkerGeometry = () => geom;
  return geom;
};
var GroundTarget = class extends MeshFacade {
  constructor(parent) {
    super(parent);
    this.geometry = getMarkerGeometry();
    this.material = new MeshLambertMaterial({
      transparent: true,
      opacity: 0.8
    });
    this.autoDisposeGeometry = true;
  }
};
var raycastPlane = new Plane().setComponents(0, 1, 0, 0);
var tempVec3$4 = new Vector3();
var tempQuat$3 = new Quaternion();
var infiniteSphere = new Sphere(void 0, Infinity);
var TeleportControls = class extends Object3DFacade {
  constructor(parent) {
    super(parent, new Group());
    this.maxDistance = 10;
    this.targeting = false;
    this.onTeleport = null;
    let markerConfig = this.markerConfig = {
      key: "marker",
      facade: GroundTarget,
      "material.color": 13209,
      visible: false
    };
    this.children = [
      markerConfig
    ];
    let lastAxisAngle = 0;
    this.addEventListener("dragstart", (e) => {
      lastAxisAngle = 0;
      this.targeting = true;
      this.afterUpdate();
    });
    this.addEventListener("drag", (e) => {
      if (this.targeting) {
        let point = e.ray.intersectPlane(raycastPlane, tempVec3$4);
        if (point && point.distanceTo(this.getCameraPosition()) < this.maxDistance) {
          this.targeting = true;
          markerConfig.x = tempVec3$4.x;
          markerConfig.z = tempVec3$4.z;
          this.requestRender();
          tempQuat$3.setFromRotationMatrix(this.getCameraFacade().threeObject.matrixWorld);
          tempVec3$4.set(0, 0, -1).applyQuaternion(tempQuat$3);
          markerConfig.rotateY = Math.atan2(-tempVec3$4.x, -tempVec3$4.z) + lastAxisAngle;
        } else {
          this.targeting = false;
        }
        this.afterUpdate();
      }
    });
    this.addEventListener("dragend", (e) => {
      if (this.targeting) {
        this.targeting = false;
        this.afterUpdate();
        this.onTeleport({
          position: { x: markerConfig.x, z: markerConfig.z },
          rotation: markerConfig.rotateY
        });
      }
    });
    const rotateDebounce = 500;
    const rotateBy = Math.PI / -4;
    let lastRotateTime = 0;
    this.addEventListener("wheel", (e) => {
      if (this.targeting) {
        lastAxisAngle = Math.atan2(-e.deltaX, -e.deltaY);
      } else {
        let now = Date.now();
        if (now - lastRotateTime > rotateDebounce && Math.abs(e.deltaX) > Math.abs(e.deltaY)) {
          lastRotateTime = now;
          this.onTeleport({
            rotation: Math.sign(e.deltaX) * rotateBy + this.getCameraFacade().rotateY
          });
        }
      }
    });
  }
  afterUpdate() {
    this.markerConfig.visible = this.targeting;
    super.afterUpdate();
  }
  getBoundingSphere() {
    return infiniteSphere;
  }
  // Raycast for dragging events will hit anywhere on ground plane if no other object
  // is hit first.
  raycast(raycaster) {
    const intersection = raycaster.ray.intersectPlane(raycastPlane, tempVec3$4);
    return intersection ? [{
      distance: raycaster.ray.origin.distanceTo(intersection),
      point: intersection.clone()
    }] : null;
  }
};
export {
  AXIS_THUMBSTICK_X,
  AXIS_THUMBSTICK_Y,
  AXIS_TOUCHPAD_X,
  AXIS_TOUCHPAD_Y,
  BUTTON_DEFAULT_BACK,
  BUTTON_SQUEEZE,
  BUTTON_THUMBSTICK,
  BUTTON_TOUCHPAD,
  BUTTON_TRIGGER,
  Basic as BasicGrip,
  CursorFacade,
  GripFacade,
  OculusTouchGrip,
  ReactXRAware,
  TARGET_RAY_RENDERORDER,
  TargetRayFacade,
  TeleportControls,
  WorldXRFacade,
  WristMountedUI,
  XRAwarePropTypes,
  XRInputSourceFacade,
  copyXRPoseToFacadeProps,
  extendAsXRCamera
};
/*! Bundled license information:

react/cjs/react.development.js:
  (** @license React v16.14.0
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=troika-xr.js.map
