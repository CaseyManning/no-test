import {
  require_checkPropTypes,
  require_object_assign,
  require_prop_types
} from "./chunk-IEZNACBM.js";
import {
  createDerivedMaterial,
  getShaderUniformTypes,
  getShadersForMaterial,
  invertMatrix4,
  voidMainRegExp
} from "./chunk-WHW3KZEO.js";
import {
  AmbientLight,
  BoxGeometry,
  BufferGeometry,
  CanvasTexture,
  CircleGeometry,
  Color,
  DirectionalLight,
  DirectionalLightHelper,
  DoubleSide,
  Fog,
  FogExp2,
  Frustum,
  Group,
  HemisphereLight,
  HemisphereLightHelper,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  LinearSRGBColorSpace,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshDistanceMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  NoToneMapping,
  Object3D,
  OrthographicCamera,
  PerspectiveCamera,
  PlaneGeometry,
  PointLight,
  PointLightHelper,
  Quaternion,
  Ray,
  Raycaster,
  RectAreaLight,
  Scene,
  Sphere,
  SphereGeometry,
  SpotLight,
  SpotLightHelper,
  Vector2,
  Vector3,
  WebGLRenderer
} from "./chunk-67OUPF4S.js";
import {
  __commonJS,
  __toESM
} from "./chunk-LQ2VYIYD.js";

// node_modules/troika-3d/node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/troika-3d/node_modules/react/cjs/react.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var _assign2 = require_object_assign();
        var checkPropTypes = require_checkPropTypes();
        var ReactVersion = "16.14.0";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var ReactCurrentBatchConfig = {
          suspense: null
        };
        var ReactCurrentOwner = {
          /**
           * @internal
           * @type {ReactComponent}
           */
          current: null
        };
        var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
        function describeComponentFrame(name, source, ownerName) {
          var sourceInfo = "";
          if (source) {
            var path = source.fileName;
            var fileName = path.replace(BEFORE_SLASH_RE, "");
            {
              if (/^index\./.test(fileName)) {
                var match = path.match(BEFORE_SLASH_RE);
                if (match) {
                  var pathBeforeSlash = match[1];
                  if (pathBeforeSlash) {
                    var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, "");
                    fileName = folderName + "/" + fileName;
                  }
                }
              }
            }
            sourceInfo = " (at " + fileName + ":" + source.lineNumber + ")";
          } else if (ownerName) {
            sourceInfo = " (created by " + ownerName + ")";
          }
          return "\n    in " + (name || "Unknown") + sourceInfo;
        }
        var Resolved = 1;
        function refineResolvedLazyComponent(lazyComponent) {
          return lazyComponent._status === Resolved ? lazyComponent._result : null;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                return "Context.Consumer";
              case REACT_PROVIDER_TYPE:
                return "Context.Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type.render);
              case REACT_LAZY_TYPE: {
                var thenable = type;
                var resolvedThenable = refineResolvedLazyComponent(thenable);
                if (resolvedThenable) {
                  return getComponentName(resolvedThenable);
                }
                break;
              }
            }
          }
          return null;
        }
        var ReactDebugCurrentFrame = {};
        var currentlyValidatingElement = null;
        function setCurrentlyValidatingElement(element) {
          {
            currentlyValidatingElement = element;
          }
        }
        {
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentlyValidatingElement) {
              var name = getComponentName(currentlyValidatingElement.type);
              var owner = currentlyValidatingElement._owner;
              stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var IsSomeRendererActing = {
          current: false
        };
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
          IsSomeRendererActing,
          // Used by renderers to avoid bundling object-assign twice in UMD bundles:
          assign: _assign2
        };
        {
          _assign2(ReactSharedInternals, {
            // These should not be included in production.
            ReactDebugCurrentFrame,
            // Shim for React DOM 16.0.0 which still destructured (but not used) this.
            // TODO: remove in React 17.0.
            ReactComponentTreeHook: {}
          });
        }
        function warn(format) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
        function error(format) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
        function printWarning(level, format, args) {
          {
            var hasExistingStack = args.length > 0 && typeof args[args.length - 1] === "string" && args[args.length - 1].indexOf("\n    in") === 0;
            if (!hasExistingStack) {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
            try {
              var argIndex = 0;
              var message = "Warning: " + format.replace(/%s/g, function() {
                return args[argIndex++];
              });
              throw new Error(message);
            } catch (x) {
            }
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          /**
           * Checks whether or not this composite component is mounted.
           * @param {ReactClass} publicInstance The instance we want to test.
           * @return {boolean} True if mounted, false otherwise.
           * @protected
           * @final
           */
          isMounted: function(publicInstance) {
            return false;
          },
          /**
           * Forces an update. This should only be invoked when it is known with
           * certainty that we are **not** in a DOM transaction.
           *
           * You may want to call this when you know that some deeper aspect of the
           * component's state has changed but `setState` was not called.
           *
           * This will not invoke `shouldComponentUpdate`, but it will invoke
           * `componentWillUpdate` and `componentDidUpdate`.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          /**
           * Replaces all of the state. Always use this or `setState` to mutate state.
           * You should treat `this.state` as immutable.
           *
           * There is no guarantee that `this.state` will be immediately updated, so
           * accessing `this.state` after calling this method may return the old value.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} completeState Next state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} callerName name of the calling function in the public API.
           * @internal
           */
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          /**
           * Sets a subset of the state. This only exists because _pendingState is
           * internal. This provides a merging strategy that is not available to deep
           * properties which is confusing. TODO: Expose pendingState or don't use it
           * during the merge.
           *
           * @param {ReactClass} publicInstance The instance that should rerender.
           * @param {object} partialState Next partial state to be merged with state.
           * @param {?function} callback Called after component is updated.
           * @param {?string} Name of the calling function in the public API.
           * @internal
           */
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
            {
              throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        _assign2(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://fb.me/react-special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://fb.me/react-strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self, source, owner, props) {
          var element = {
            // This tag allows us to uniquely identify this as a React Element
            $$typeof: REACT_ELEMENT_TYPE,
            // Built-in properties that belong on the element
            type,
            key,
            ref,
            props,
            // Record the component responsible for creating this element.
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            self = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (!!(element === null || element === void 0)) {
            {
              throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
          }
          var propName;
          var props = _assign2({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = ("" + key).replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return ("" + text).replace(userProvidedKeyEscapeRegex, "$&/");
        }
        var POOL_SIZE = 10;
        var traverseContextPool = [];
        function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
          if (traverseContextPool.length) {
            var traverseContext = traverseContextPool.pop();
            traverseContext.result = mapResult;
            traverseContext.keyPrefix = keyPrefix;
            traverseContext.func = mapFunction;
            traverseContext.context = mapContext;
            traverseContext.count = 0;
            return traverseContext;
          } else {
            return {
              result: mapResult,
              keyPrefix,
              func: mapFunction,
              context: mapContext,
              count: 0
            };
          }
        }
        function releaseTraverseContext(traverseContext) {
          traverseContext.result = null;
          traverseContext.keyPrefix = null;
          traverseContext.func = null;
          traverseContext.context = null;
          traverseContext.count = 0;
          if (traverseContextPool.length < POOL_SIZE) {
            traverseContextPool.push(traverseContext);
          }
        }
        function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            callback(
              traverseContext,
              children,
              // If it's the only child, treat the name as if it was wrapped in an array
              // so that it's consistent if the number of children grows.
              nameSoFar === "" ? SEPARATOR + getComponentKey(children, 0) : nameSoFar
            );
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getComponentKey(child, i);
              subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              {
                if (iteratorFn === children.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is deprecated and will be removed in a future major release. Consider converting children to an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(children);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getComponentKey(child, ii++);
                subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
              }
            } else if (type === "object") {
              var addendum = "";
              {
                addendum = " If you meant to render a collection of children, use an array instead." + ReactDebugCurrentFrame.getStackAddendum();
              }
              var childrenString = "" + children;
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + ")." + addendum);
                }
              }
            }
          }
          return subtreeCount;
        }
        function traverseAllChildren(children, callback, traverseContext) {
          if (children == null) {
            return 0;
          }
          return traverseAllChildrenImpl(children, "", callback, traverseContext);
        }
        function getComponentKey(component, index) {
          if (typeof component === "object" && component !== null && component.key != null) {
            return escape(component.key);
          }
          return index.toString(36);
        }
        function forEachSingleChild(bookKeeping, child, name) {
          var func = bookKeeping.func, context = bookKeeping.context;
          func.call(context, child, bookKeeping.count++);
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          if (children == null) {
            return children;
          }
          var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
          traverseAllChildren(children, forEachSingleChild, traverseContext);
          releaseTraverseContext(traverseContext);
        }
        function mapSingleChildIntoContext(bookKeeping, child, childKey) {
          var result = bookKeeping.result, keyPrefix = bookKeeping.keyPrefix, func = bookKeeping.func, context = bookKeeping.context;
          var mappedChild = func.call(context, child, bookKeeping.count++);
          if (Array.isArray(mappedChild)) {
            mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function(c) {
              return c;
            });
          } else if (mappedChild != null) {
            if (isValidElement(mappedChild)) {
              mappedChild = cloneAndReplaceKey(
                mappedChild,
                // Keep both the (mapped) and old keys if they differ, just as
                // traverseAllChildren used to do for objects as children
                keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + "/" : "") + childKey
              );
            }
            result.push(mappedChild);
          }
        }
        function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
          var escapedPrefix = "";
          if (prefix != null) {
            escapedPrefix = escapeUserProvidedKey(prefix) + "/";
          }
          var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
          traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
          releaseTraverseContext(traverseContext);
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          mapIntoWithKeyPrefixInternal(children, result, null, func, context);
          return result;
        }
        function countChildren(children) {
          return traverseAllChildren(children, function() {
            return null;
          }, null);
        }
        function toArray(children) {
          var result = [];
          mapIntoWithKeyPrefixInternal(children, result, null, function(child) {
            return child;
          });
          return result;
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            {
              throw Error("React.Children.only expected to receive a single React element child.");
            }
          }
          return children;
        }
        function createContext(defaultValue, calculateChangedBits) {
          if (calculateChangedBits === void 0) {
            calculateChangedBits = null;
          } else {
            {
              if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
              }
            }
          }
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            // As a workaround to support multiple concurrent renderers, we categorize
            // some renderers as primary and others as secondary. We only expect
            // there to be two concurrent renderers at most: React Native (primary) and
            // Fabric (secondary); React DOM (primary) and React ART (secondary).
            // Secondary renderers store their context values on separate fields.
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            // Used to track how many concurrent renderers this context currently
            // supports within in a single renderer. Such as parallel server rendering.
            _threadCount: 0,
            // These are circular
            Provider: null,
            Consumer: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
              _calculateChangedBits: context._calculateChangedBits
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        function lazy(ctor) {
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _ctor: ctor,
            // React uses these fields to store the result.
            _status: -1,
            _result: null
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          return {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
        }
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          return {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (!(dispatcher !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context, unstable_observedBits) {
          var dispatcher = resolveDispatcher();
          {
            if (unstable_observedBits !== void 0) {
              error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://fb.me/rules-of-hooks" : "");
            }
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context, unstable_observedBits);
        }
        function useState(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement(element);
          {
            error('Each child in a list should have a unique "key" prop.%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
          }
          setCurrentlyValidatingElement(null);
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var name = getComponentName(type);
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
            // Inner props are checked in the reconciler.
            type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              setCurrentlyValidatingElement(element);
              checkPropTypes(propTypes, element.props, "prop", name, ReactDebugCurrentFrame.getStackAddendum);
              setCurrentlyValidatingElement(null);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            setCurrentlyValidatingElement(fragment);
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                break;
              }
            }
            if (fragment.ref !== null) {
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
            }
            setCurrentlyValidatingElement(null);
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (Array.isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentName(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        {
          try {
            var frozenObject = Object.freeze({});
            var testMap = /* @__PURE__ */ new Map([[frozenObject, null]]);
            var testSet = /* @__PURE__ */ new Set([frozenObject]);
            testMap.set(0, 0);
            testSet.add(0);
          } catch (e) {
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useEffect = useEffect;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/troika-3d/node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/troika-3d/node_modules/react/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/troika-animation/dist/troika-animation.esm.js
var { pow, PI, sqrt } = Math;
var HALF_PI = PI / 2;
var TWO_PI = PI * 2;
function makeInOut(inFn, outFn) {
  return (t) => t < 0.5 ? inFn(t * 2) * 0.5 : outFn(t * 2 - 1) * 0.5 + 0.5;
}
function makeExpIn(exp) {
  return (t) => pow(t, exp);
}
function makeExpOut(exp) {
  return (t) => 1 - pow(1 - t, exp);
}
function makeExpInOut(exp) {
  return (t) => t < 0.5 ? pow(t * 2, exp) * 0.5 : (1 - pow(1 - (t * 2 - 1), exp)) * 0.5 + 0.5;
}
var linear = (t) => t;
var easeInQuad = makeExpIn(2);
var easeOutQuad = makeExpOut(2);
var easeInOutQuad = makeExpInOut(2);
var easeInCubic = makeExpIn(3);
var easeOutCubic = makeExpOut(3);
var easeInOutCubic = makeExpInOut(3);
var easeInQuart = makeExpIn(4);
var easeOutQuart = makeExpOut(4);
var easeInOutQuart = makeExpInOut(4);
var easeInQuint = makeExpIn(5);
var easeOutQuint = makeExpOut(5);
var easeInOutQuint = makeExpInOut(5);
var easeInSine = (t) => 1 - Math.cos(t * HALF_PI);
var easeOutSine = (t) => Math.sin(t * HALF_PI);
var easeInOutSine = (t) => -0.5 * (Math.cos(PI * t) - 1);
var easeInExpo = (t) => t === 0 ? 0 : pow(2, 10 * (t - 1));
var easeOutExpo = (t) => t === 1 ? 1 : 1 - pow(2, -10 * t);
var easeInOutExpo = (t) => t === 0 || t === 1 ? t : t < 0.5 ? pow(2, 10 * (t * 2 - 1)) * 0.5 : (1 - pow(2, -10 * (t * 2 - 1))) * 0.5 + 0.5;
var easeInCirc = (t) => 1 - sqrt(1 - t * t);
var easeOutCirc = (t) => sqrt(1 - pow(t - 1, 2));
var easeInOutCirc = makeInOut(easeInCirc, easeOutCirc);
var easeInElastic = (t) => t === 0 || t === 1 ? t : 1 - easeOutElastic(1 - t);
var easeOutElastic = (t) => t === 0 || t === 1 ? t : Math.pow(2, -10 * t) * Math.sin((t - 0.075) * TWO_PI / 0.3) + 1;
var easeInOutElastic = makeInOut(easeInElastic, easeOutElastic);
var easeInBack = (t) => t * t * (2.70158 * t - 1.70158);
var easeOutBack = (t) => (t -= 1) * t * (2.70158 * t + 1.70158) + 1;
var easeInOutBack = (t) => {
  const s = 1.70158 * 1.525;
  return (t *= 2) < 1 ? 0.5 * (t * t * ((s + 1) * t - s)) : 0.5 * ((t -= 2) * t * ((s + 1) * t + s) + 2);
};
var easeInBounce = (t) => 1 - easeOutBounce(1 - t);
var easeOutBounce = (t) => t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
var easeInOutBounce = makeInOut(easeInBounce, easeOutBounce);
var Easings = Object.freeze({
  __proto__: null,
  linear,
  easeInQuad,
  easeOutQuad,
  easeInOutQuad,
  easeInCubic,
  easeOutCubic,
  easeInOutCubic,
  easeInQuart,
  easeOutQuart,
  easeInOutQuart,
  easeInQuint,
  easeOutQuint,
  easeInOutQuint,
  easeInSine,
  easeOutSine,
  easeInOutSine,
  easeInExpo,
  easeOutExpo,
  easeInOutExpo,
  easeInCirc,
  easeOutCirc,
  easeInOutCirc,
  easeInElastic,
  easeOutElastic,
  easeInOutElastic,
  easeInBack,
  easeOutBack,
  easeInOutBack,
  easeInBounce,
  easeOutBounce,
  easeInOutBounce
});
function number(fromValue, toValue, progress) {
  return fromValue + (toValue - fromValue) * progress;
}
function color(fromValue, toValue, progress) {
  fromValue = colorValueToNumber(fromValue);
  toValue = colorValueToNumber(toValue);
  return rgbToNumber(
    number(fromValue >> 16 & 255, toValue >> 16 & 255, progress),
    number(fromValue >> 8 & 255, toValue >> 8 & 255, progress),
    number(fromValue & 255, toValue & 255, progress)
  );
}
var colorValueToNumber = /* @__PURE__ */ function() {
  let colorCanvas, colorCanvasCtx;
  let stringCache = /* @__PURE__ */ Object.create(null);
  let stringCacheSize = 0;
  const stringCacheMaxSize = 2048;
  return function(value) {
    if (typeof value === "number") {
      return value;
    } else if (typeof value === "string") {
      if (value in stringCache) {
        return stringCache[value];
      }
      if (!colorCanvas) {
        colorCanvas = document.createElement("canvas");
        colorCanvasCtx = colorCanvas.getContext("2d");
      }
      colorCanvas.width = colorCanvas.height = 1;
      colorCanvasCtx.fillStyle = value;
      colorCanvasCtx.fillRect(0, 0, 1, 1);
      const colorData = colorCanvasCtx.getImageData(0, 0, 1, 1).data;
      const result = rgbToNumber(colorData[0], colorData[1], colorData[2]);
      if (stringCacheSize > stringCacheMaxSize) {
        stringCache = /* @__PURE__ */ Object.create(null);
        stringCacheSize = 0;
      }
      stringCache[value] = result;
      stringCacheSize++;
      return result;
    } else if (value && value.isColor) {
      return value.getHex();
    } else {
      return 0;
    }
  };
}();
function rgbToNumber(r, g, b) {
  return r << 16 ^ g << 8 ^ b;
}
var Interpolators = Object.freeze({
  __proto__: null,
  number,
  color
});
var AbstractTween = class {
  /**
   * @abstract
   * For a given elapsed time relative to the start of the tween, calculates the value at that time and calls the
   * `callback` function with that value. If the given time is during the `delay` period, the callback will not be
   * invoked.
   * @param {number} time
   */
  gotoElapsedTime(time) {
  }
  /**
   * @abstract
   * Like `gotoElapsedTime` but goes to the very end of the tween.
   */
  gotoEnd() {
  }
  /**
   * @abstract
   * For a given elapsed time relative to the start of the tween, determines if the tween is in its completed end state.
   * @param {number} time
   * @return {boolean}
   */
  isDoneAtElapsedTime(time) {
  }
};
var linear$1 = (v) => v;
var maxSafeInteger = 9007199254740991;
var Tween = class extends AbstractTween {
  constructor(callback, fromValue, toValue, duration = 750, delay = 0, easing = linear$1, iterations = 1, direction = "forward", interpolate = "number") {
    super();
    this.callback = callback;
    this.fromValue = fromValue;
    this.toValue = toValue;
    this.duration = duration;
    this.delay = delay;
    this.easing = typeof easing === "string" ? Easings[easing] || linear$1 : easing;
    this.iterations = iterations;
    this.direction = direction;
    this.interpolate = typeof interpolate === "function" ? interpolate : Interpolators[interpolate] || number;
    this.totalElapsed = this.iterations < maxSafeInteger ? this.delay + this.duration * this.iterations : maxSafeInteger;
  }
  /**
   * For a given elapsed time relative to the start of the tween, calculates the value at that time and calls the
   * `callback` function with that value. If the given time is during the `delay` period, the callback will not be
   * invoked.
   * @param {number} time
   */
  gotoElapsedTime(time) {
    let duration = this.duration;
    let delay = this.delay;
    if (time >= delay) {
      time = Math.min(time, this.totalElapsed) - delay;
      let progress = time % duration / duration;
      if (progress === 0 && time !== 0)
        progress = 1;
      progress = this.easing(progress);
      if (this.direction === "reverse" || this.direction === "alternate" && Math.ceil(time / duration) % 2 === 0) {
        progress = 1 - progress;
      }
      this.callback(this.interpolate(this.fromValue, this.toValue, progress));
    }
  }
  /**
   * Like `gotoElapsedTime` but goes to the very end of the tween.
   */
  gotoEnd() {
    this.gotoElapsedTime(this.totalElapsed);
  }
  /**
   * For a given elapsed time relative to the start of the tween, determines if the tween is in its completed end state.
   * @param {number} time
   * @return {boolean}
   */
  isDoneAtElapsedTime(time) {
    return time > this.totalElapsed;
  }
};
var MultiTween = class extends Tween {
  constructor(tweens, duration, delay, easing, iterations, direction) {
    if (typeof duration !== "number") {
      duration = tweens.reduce((dur, tween) => Math.max(dur, tween.totalElapsed), 0);
    }
    if (duration === Infinity) {
      duration = Number.MAX_VALUE;
    }
    super(null, 0, duration, duration, delay, easing, iterations, direction);
    if (tweens.length === 1) {
      this.callback = tweens[0].gotoElapsedTime.bind(tweens[0]);
    } else {
      tweens.sort(endTimeComparator);
      this.callback = this._syncTweens;
    }
    this.tweens = tweens;
  }
  _syncTweens(time) {
    for (let i = 0, len = this.tweens.length; i < len; i++) {
      this.tweens[i].gotoElapsedTime(time);
    }
  }
};
function endTimeComparator(a, b) {
  return a.totalElapsed - b.totalElapsed;
}
var runners = [];
var nextFrameTimer = null;
var hasStoppedRunners = false;
function noop() {
}
function isRunnerRunning(runner) {
  return runner.runner$running;
}
function isTweenNotStopped(tween) {
  return !tween.runner$stopped;
}
function tick() {
  let now = Date.now();
  nextFrameTimer = null;
  if (hasStoppedRunners) {
    runners = runners.filter(isRunnerRunning);
    hasStoppedRunners = false;
  }
  if (runners.length) {
    for (let i = runners.length; i-- > 0; ) {
      runners[i]._tick(now);
    }
    queueFrame();
  }
}
var _scheduler = window;
function setAnimationScheduler(scheduler) {
  scheduler = scheduler || window;
  if (scheduler !== _scheduler) {
    if (nextFrameTimer) {
      _scheduler.cancelAnimationFrame(nextFrameTimer);
      nextFrameTimer = null;
    }
    _scheduler = scheduler;
    queueFrame();
  }
}
function queueFrame() {
  if (!nextFrameTimer) {
    nextFrameTimer = _scheduler.requestAnimationFrame(tick);
  }
}
function startRunner(runner) {
  if (!runner.runner$running) {
    runner.runner$running = true;
    runners.push(runner);
    queueFrame();
  }
}
function stopRunner(runner) {
  runner.runner$running = false;
  hasStoppedRunners = true;
}
var Runner = class {
  constructor() {
    this.tweens = [];
  }
  destructor() {
    this.tweens = null;
    stopRunner(this);
    this.start = this.stop = this.pause = this._tick = noop;
  }
  /**
   * Add a tween to the runner. It will be invoked on the next frame, not immediately.
   * @param {Tween} tween
   */
  start(tween) {
    if (tween.runner$paused && tween.runner$started) {
      tween.runner$started += Date.now() - tween.runner$paused;
    } else {
      this.tweens.push(tween);
    }
    tween.runner$paused = null;
    tween.runner$stopped = false;
    startRunner(this);
  }
  /**
   * Remove a tween from the runner.
   * @param tween
   */
  stop(tween) {
    tween.runner$stopped = true;
    tween.runner$paused = null;
  }
  /**
   * Pause a tween; call `runner.start(tween)` to unpause it
   * @param tween
   */
  pause(tween) {
    if (!tween.runner$paused) {
      tween.runner$paused = Date.now();
    }
  }
  /**
   * Stop all running tweens.
   */
  stopAll() {
    if (this.tweens) {
      this.tweens.forEach(this.stop, this);
    }
  }
  _tick(now) {
    let tweens = this.tweens;
    let hasStoppedTweens = false;
    let hasRunningTweens = false;
    for (let i = 0, len = tweens.length; i < len; i++) {
      let tween = tweens[i];
      if (!tween.runner$stopped && !tween.runner$paused) {
        let elapsed = now - (tween.runner$started || (tween.runner$started = now));
        tween.gotoElapsedTime(elapsed);
        hasRunningTweens = true;
        if (tween.isDoneAtElapsedTime(elapsed)) {
          this.stop(tween);
          if (tween.onDone) {
            tween.onDone();
          }
        }
      }
      if (tween.runner$stopped) {
        hasStoppedTweens = true;
      }
    }
    if (hasRunningTweens) {
      this.onTick();
    }
    if (hasStoppedTweens) {
      this.tweens = tweens.filter(isTweenNotStopped);
      if (!this.tweens.length) {
        stopRunner(this);
        if (this.onDone) {
          this.onDone();
        }
      }
    }
  }
  /**
   * Override to specify a function that will be called at the end of every frame, after all
   * tweens have been updated.
   */
  onTick() {
  }
  /**
   * Override to specify a function that will be called after all running tweens have completed.
   */
  onDone() {
  }
};
var PRESETS = {
  default: { mass: 1, tension: 170, friction: 26 },
  gentle: { mass: 1, tension: 120, friction: 14 },
  wobbly: { mass: 1, tension: 180, friction: 12 },
  stiff: { mass: 1, tension: 210, friction: 20 },
  slow: { mass: 1, tension: 280, friction: 60 },
  molasses: { mass: 1, tension: 280, friction: 120 }
};
var tensionFactor = 1e-6;
var frictionFactor = 1e-3;
var DEFAULTS = PRESETS.default;
var SpringTween = class extends AbstractTween {
  constructor(callback, fromValue, toValue, springConfig, initialVelocity = 0, delay = 0) {
    super();
    this.isSpring = true;
    this.callback = callback;
    this.currentValue = fromValue;
    this.toValue = toValue;
    this.velocity = initialVelocity;
    this.delay = delay;
    if (typeof springConfig === "string") {
      springConfig = PRESETS[springConfig];
    }
    if (!springConfig)
      springConfig = DEFAULTS;
    const { mass, tension, friction } = springConfig;
    this.mass = typeof mass === "number" ? mass : DEFAULTS.mass;
    this.tension = (typeof tension === "number" ? tension : DEFAULTS.tension) * tensionFactor;
    this.friction = (typeof friction === "number" ? friction : DEFAULTS.friction) * frictionFactor;
    this.minAcceleration = 1e-10;
    this.$lastTime = delay;
    this.$endTime = Infinity;
  }
  gotoElapsedTime(time) {
    if (time >= this.delay) {
      let { toValue, mass, tension, friction, minAcceleration } = this;
      let velocity = this.velocity || 0;
      let value = this.currentValue;
      for (let t = this.$lastTime; t < time; t++) {
        const acceleration = (tension * (toValue - value) - friction * velocity) / mass;
        if (Math.abs(acceleration) < minAcceleration) {
          velocity = 0;
          value = toValue;
          this.$endTime = t;
          break;
        } else {
          velocity += acceleration;
          value += velocity;
        }
      }
      this.velocity = velocity;
      this.$lastTime = time;
      this.callback(this.currentValue = value);
    }
  }
  gotoEnd() {
    this.velocity = 0;
    this.$lastTime = this.$endTime;
    this.callback(this.currentValue = this.toValue);
  }
  isDoneAtElapsedTime(time) {
    return time >= this.$endTime;
  }
};

// node_modules/troika-3d/node_modules/troika-core/dist/troika-core.esm.js
var import_react = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var assign = Object.assign || _assign;
function _assign() {
  let target = arguments[0];
  for (let i = 1, len = arguments.length; i < len; i++) {
    let source = arguments[i];
    if (source) {
      for (let prop in source) {
        if (source.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
  }
  return target;
}
function assignIf() {
  let target = arguments[0];
  for (let i = 1, len = arguments.length; i < len; i++) {
    let source = arguments[i];
    if (source) {
      for (let prop in source) {
        if (source.hasOwnProperty(prop) && !target.hasOwnProperty(prop)) {
          target[prop] = source[prop];
        }
      }
    }
  }
  return target;
}
function assignDeep(target, source) {
  if (source) {
    for (let prop in source) {
      if (source.hasOwnProperty(prop)) {
        if (target[prop] && typeof target[prop] === "object" && typeof source[prop] === "object") {
          assignDeep(target[prop], source[prop]);
        } else {
          target[prop] = source[prop];
        }
      }
    }
  }
}
function forOwn(object, fn, scope) {
  for (let prop in object) {
    if (object.hasOwnProperty(prop)) {
      fn.call(scope, object[prop], prop, object);
    }
  }
}
var getIdForObject = /* @__PURE__ */ (() => {
  let objIds = /* @__PURE__ */ new WeakMap();
  let lastId = 0;
  return function getIdForObject2(obj) {
    let id = objIds.get(obj);
    if (!id) {
      objIds.set(obj, id = `$id${++lastId}`);
    }
    return id;
  };
})();
function memoize(fn) {
  let prevArgs, prevThis, prevResult;
  return function() {
    let changed = !prevArgs || this !== prevThis || arguments.length !== prevArgs.length;
    if (!changed) {
      for (let i = 0, len = arguments.length; i < len; i++) {
        if (arguments[i] !== prevArgs[i]) {
          changed = true;
          break;
        }
      }
    }
    if (changed) {
      prevArgs = Array.prototype.slice.call(arguments);
      prevThis = this;
      prevResult = fn.apply(this, arguments);
    }
    return prevResult;
  };
}
function createClassExtender(name, doExtend) {
  const cache = /* @__PURE__ */ new WeakMap();
  return function(classToExtend) {
    let extended = cache.get(classToExtend);
    if (!extended) {
      extended = doExtend(classToExtend);
      cache.set(classToExtend, extended);
    }
    return extended;
  };
}
function isReactElement(obj) {
  const t = obj.$$typeof;
  return t && t.toString && t.toString() === "Symbol(react.element)" || false;
}
var utils = Object.freeze({
  __proto__: null,
  assign,
  _assign,
  assignIf,
  assignDeep,
  forOwn,
  getIdForObject,
  memoize,
  createClassExtender,
  isReactElement
});
var Facade = class _Facade {
  constructor(parent) {
    this.$facadeId = `facade${idCounter++}`;
    this.parent = parent;
  }
  /**
   * Performs a manual update of this facade, invoking the afterUpdate lifecycle method and triggering a
   * render. This can be called in event handlers, for example, to affect changes to this facade and its
   * subtree. This process is synchronous. Never override this method as a way to react to updates, as it
   * is not the only way a component is updated; instead override `afterUpdate` or use setters.
   * @param {object} [props] - A set of properties to be copied to the facade
   */
  update(props) {
    if (props && typeof props === "object") {
      this.transition = props.transition;
      this.animation = props.animation;
      for (let prop in props) {
        if (props.hasOwnProperty(prop) && !_Facade.isSpecialDescriptorProperty(prop)) {
          this[prop] = props[prop];
        }
      }
    }
    this.afterUpdate();
    this.requestRender();
  }
  /**
   * Called at the end of an update batch, after all individual properties have been assigned.
   */
  afterUpdate() {
    let ref = this.ref;
    if (ref !== this._lastRef) {
      if (typeof this._lastRef === "function") {
        this._lastRef.call(null, null);
      }
      if (typeof ref === "function") {
        ref.call(null, this);
        this._lastRef = ref;
      } else {
        this._lastRef = null;
      }
    }
  }
  /**
   * Dispatch a message with optional data up the facade parent tree.
   */
  notifyWorld(message, data) {
    if (this.parent) {
      this.parent.onNotifyWorld(this, message, data);
    }
  }
  /**
   * Default onNotifyWorld handler just bubbles it up the parent chain.
   */
  onNotifyWorld(source, message, data) {
    let notifiableParent = this._notifiableParent;
    if (notifiableParent) {
      notifiableParent.onNotifyWorld.call(notifiableParent, source, message, data);
    } else {
      notifiableParent = this.parent;
      let defaultImpl = _Facade.prototype.onNotifyWorld;
      while (notifiableParent) {
        if (notifiableParent.onNotifyWorld !== defaultImpl) {
          this._notifiableParent = notifiableParent;
          notifiableParent.onNotifyWorld(source, message, data);
          break;
        }
        notifiableParent = notifiableParent.parent;
      }
    }
  }
  /**
   * Notifies the top-level world manager that this object has changed in some way that affects its
   * visible rendering, so a rendering frame will be scheduled.
   */
  requestRender() {
    this.notifyWorld("needsRender");
  }
  traverse(fn) {
    fn(this);
  }
  forEachChild(fn) {
  }
  /**
   * Add an event listener for the given event type.
   * @param {String} type
   * @param {Function} handler
   */
  addEventListener(type, handler) {
    this.notifyWorld("addEventListener", { type, handler });
  }
  /**
   * Remove an event listener for the given event type.
   * @param {String} type
   * @param {Function} handler
   */
  removeEventListener(type, handler) {
    this.notifyWorld("removeEventListener", { type, handler });
  }
  /**
   * Dispatch an Event object on this facade, with DOM events bubbling logic.
   * @param {Event} event
   */
  dispatchEvent(event) {
    this.notifyWorld("dispatchEvent", event);
  }
  /**
   * Called when the instance is being removed from the scene. Override this to implement any
   * custom cleanup logic.
   */
  destructor() {
    if (this.parent) {
      this.notifyWorld("removeAllEventListeners");
    }
    if (typeof this.ref === "function") {
      this.ref.call(null, null);
    }
    this.parent = this._notifiableParent = null;
  }
};
assign(Facade.prototype, {
  ref: null,
  _lastRef: null,
  _notifiableParent: null
});
var idCounter = 0;
var DEF_SPECIAL_PROPS = { key: 1, facade: 1, transition: 1, animation: 1 };
Facade.isSpecialDescriptorProperty = function(name) {
  return DEF_SPECIAL_PROPS.hasOwnProperty(name);
};
Facade.defineEventProperty = function(facadeClass, propName, eventType) {
  let privateProp = `${propName}handler`;
  Object.defineProperty(facadeClass.prototype, propName, {
    get() {
      return this[privateProp];
    },
    set(handler) {
      const oldHandler = this[privateProp];
      if ((handler || null) !== (oldHandler || null)) {
        if (typeof oldHandler === "function") {
          this.removeEventListener(eventType, oldHandler);
        }
        if (typeof handler === "function") {
          this.addEventListener(eventType, handler);
        }
        this[privateProp] = handler;
      }
    }
  });
};
var DEFAULT_DURATION = 750;
var DEFAULT_EASING = "easeOutCubic";
var TEMP_ARRAY = [null];
function animationIdJsonReplacer(key, value) {
  return key === "paused" ? void 0 : value === Infinity ? "Infinity" : value;
}
function compareByTime(a, b) {
  return a.time - b.time;
}
var extendAsAnimatable = createClassExtender("animatable", function(BaseFacadeClass) {
  class AnimatableFacade extends BaseFacadeClass {
    constructor(...args) {
      super(...args);
      this.animation$runner = new Runner();
      this.animation$runner.onTick = () => {
        this.afterUpdate();
        this.requestRender();
      };
    }
    /**
     * Handle the special "transition" property. The descriptor should be an object with
     * transitionable property names as keys and transition parameters as values. The
     * transition parameters can either be objects describing the transition parameters,
     * or `true` for a default transition.
     *
     *   transition: {
     *     x: true, // uses a default duration-based transition
     *     y: 'spring', //uses a default spring-based transition
     *     z: {
     *       // ...custom transition config
     *     }
     *   }
     *
     * The custom transition config object can take one of two forms for duration- vs.
     * spring-based animations:
     *
     * Duration-based:
     *
     *   {
     *     duration: n, //in ms, defaults to 750
     *     easing: e, //easing function, defaults to 'easeOutCubic'
     *     delay: n, //in ms, defaults to 0
     *     interpolate: 'number' //one of the builtin named interpolators ('number', 'color', etc.) or a custom Function
     *   }
     *
     * Spring-based:
     *
     *   {
     *     spring: s, //either `true`, a named preset string e.g. "wobbly", or an object with {mass, tension, friction}
     *     delay: n //in ms, defaults to 0
     *   }
     *
     * Note that spring-based transitions do not currently support custom interpolations so they should only be used
     * for numeric values.
     */
    set transition(descriptor) {
      if (descriptor) {
        for (let propName in descriptor) {
          if (descriptor.hasOwnProperty(propName)) {
            defineTransitionPropInterceptor(propName, this);
          }
        }
      }
      this.transition$descriptor = descriptor;
    }
    get transition() {
      return this.transition$descriptor;
    }
    /**
     * Handle the special "animation" property. The descriptor should be an object or array
     * of objects defining a set of keyframes and their playback parameters. Keyframes are
     * defined by numeric keys from 0 to 100, each defining an object with the target
     * property values for that keyframe.
     *
     *   animation: [{
     *     0: {rotateZ: 0, color: 0x000000}, //can also use key "from"
     *     100: {rotateZ: Math.PI * 2, color: 0xffffff}, //can also use key "to"
     *     delay: 0, //starting delay in ms
     *     duration: 2000, //total anim duration in ms, defaults to 750
     *     easing: 'linear', //easing for the whole animation, defaults to 'linear'
     *     iterations: 5, //number of times to loop the animation, defaults to 1. Set to Infinity for endless loop.
     *     direction: 'forward', //either 'forward', 'backward', or 'alternate'
     *     interpolate: {color: 'color'}, //mapping of property names to Interpolators.js names or custom functions
     *     paused: false //if true the animation will be paused at its current position until set back to false
     *   }, ...]
     *
     * Internally the animations will be built into a set of nested tweens:
     *
     * |--------------------------- Main MultiTween ------------------------------------|
     *
     * |------------- Anim 1 MultiTween w/ easing+repeat ----------------|
     * |--- prop1 tween 1 ---|--- prop1 tween 2 ---|--- prop1 tween 3 ---|
     * |--------- prop2 tween 1 --------|--------- prop2 tween 2 --------|
     *
     *                    delay -->|-------- Anim 2 MultiTween w/ easing+repeat --------|
     *                             |----- prop3 tween 1 -----|----- prop3 tween 2 ------|
     *                             |------------------- prop4 tween --------------------|
     *                                            |----------- prop5 tween -------------|
     */
    set animation(descriptor) {
      if (this.animation$descriptor === descriptor)
        return;
      this.animation$descriptor = descriptor;
      let oldAnimTweens = this.animation$tweens || null;
      let newAnimTweens = this.animation$tweens = descriptor ? /* @__PURE__ */ Object.create(null) : null;
      let runner = this.animation$runner;
      let hasChanged = false;
      if (descriptor && !Array.isArray(descriptor)) {
        TEMP_ARRAY[0] = descriptor;
        descriptor = TEMP_ARRAY;
      }
      if (descriptor) {
        for (let i = 0, len = descriptor.length; i < len; i++) {
          let animDesc = descriptor[i];
          if (!animDesc)
            continue;
          let animId = JSON.stringify(animDesc, animationIdJsonReplacer);
          if (oldAnimTweens && animId in oldAnimTweens) {
            let tween = oldAnimTweens[animId];
            if (animDesc.paused) {
              runner.pause(tween);
            } else {
              runner.start(tween);
            }
            newAnimTweens[animId] = tween;
          } else {
            let delay = 0;
            let duration = DEFAULT_DURATION;
            let easing = "linear";
            let iterations = 1;
            let keyframes = [];
            let direction = "forward";
            for (let key in animDesc) {
              if (animDesc.hasOwnProperty(key)) {
                switch (key) {
                  case "duration":
                    duration = animDesc[key];
                    break;
                  case "delay":
                    delay = animDesc[key];
                    break;
                  case "easing":
                    easing = animDesc[key];
                    break;
                  case "iterations":
                    iterations = animDesc[key];
                    break;
                  case "direction":
                    direction = animDesc[key];
                    break;
                  default: {
                    let percent = key === "from" ? 0 : key === "to" ? 100 : parseFloat(key);
                    if (!isNaN(percent) && percent >= 0 && percent <= 100) {
                      keyframes.push({ time: percent / 100, props: animDesc[key] });
                      for (let animProp in animDesc[key]) {
                        if (animDesc[key].hasOwnProperty(animProp)) {
                          defineTransitionPropInterceptor(animProp, this);
                          let tweenKey = animProp + "anim:tween";
                          if (this[tweenKey]) {
                            runner.stop(this[tweenKey]);
                            this[tweenKey] = null;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            if (keyframes.length) {
              keyframes.sort(compareByTime);
              if (keyframes[0].time > 0) {
                keyframes.unshift(assignIf({ time: 0 }, keyframes[0]));
              }
              let keyframePropTweens = [];
              for (let j = 1, len2 = keyframes.length; j < len2; j++) {
                let keyframe = keyframes[j];
                let props = keyframe.props;
                for (let prop in props) {
                  if (props.hasOwnProperty(prop)) {
                    let prevKeyframe = null;
                    for (let k = j; k--; ) {
                      if (prop in keyframes[k].props) {
                        prevKeyframe = keyframes[k];
                        break;
                      }
                    }
                    if (prevKeyframe) {
                      let propTween = new Tween(
                        this[prop + "anim:actuallySet"].bind(this),
                        //callback
                        prevKeyframe.props[prop],
                        //fromValue
                        props[prop],
                        //toValue
                        (keyframe.time - prevKeyframe.time) * duration,
                        //duration
                        prevKeyframe.time * duration,
                        //delay
                        "linear",
                        //easing
                        1,
                        //iterations
                        "forward",
                        //direction
                        animDesc.interpolate && animDesc.interpolate[prop] || "number"
                      );
                      propTween.$$property = prop;
                      keyframePropTweens.push(propTween);
                    }
                  }
                }
              }
              let tween = newAnimTweens[animId] = new MultiTween(keyframePropTweens, duration, delay, easing, iterations, direction);
              if (!animDesc.paused) {
                runner.start(tween);
              }
              if (delay === 0) {
                let firstKeyframeProps = keyframes[0].props;
                for (let prop in firstKeyframeProps) {
                  if (firstKeyframeProps.hasOwnProperty(prop)) {
                    this[prop + "anim:actuallySet"](firstKeyframeProps[prop]);
                  }
                }
              }
            }
            hasChanged = true;
          }
        }
      }
      if (oldAnimTweens) {
        for (let animId in oldAnimTweens) {
          if (!newAnimTweens || !newAnimTweens[animId]) {
            let tween = oldAnimTweens[animId];
            tween.gotoEnd();
            runner.stop(tween);
            hasChanged = true;
          }
        }
      }
      if (hasChanged) {
        if (newAnimTweens) {
          let animatingProps = this.animation$animatingProps = /* @__PURE__ */ Object.create(null);
          for (let animId in newAnimTweens) {
            let propTweens = newAnimTweens[animId].tweens;
            for (let i = propTweens.length; i--; ) {
              animatingProps[propTweens[i].$$property] = true;
            }
          }
        } else {
          this.animation$animatingProps = null;
        }
      }
    }
    get animation() {
      return this.animation$descriptor;
    }
    destructor() {
      const runner = this.animation$runner;
      if (this.exitAnimation && !this.parent.isDestroying) {
        runner.stopAll();
        this.animation = this.exitAnimation;
        this.exitAnimation = this.transition = null;
        const onTick = runner.onTick;
        runner.onTick = () => {
          if (this.parent && !this.parent.isDestroying) {
            onTick();
          } else {
            runner.onDone = null;
            this.destructor();
          }
        };
        runner.onDone = () => {
          this.requestRender();
          this.destructor();
        };
      } else {
        runner.destructor();
        super.destructor();
      }
    }
  }
  function defineTransitionPropInterceptor(propName, currentInstance) {
    if (!AnimatableFacade.prototype.hasOwnProperty(propName)) {
      let actualValueKey = `${propName}anim:actualValue`;
      let actuallySetKey = `${propName}anim:actuallySet`;
      let hasBeenSetKey = `${propName}anim:hasBeenSet`;
      let activeTweenKey = `${propName}anim:tween`;
      let superGetter, superSetter;
      let proto2 = BaseFacadeClass.prototype;
      while (proto2) {
        let desc = Object.getOwnPropertyDescriptor(proto2, propName);
        if (desc) {
          superSetter = desc.set;
          superGetter = desc.get;
          if (superSetter && !superGetter || superGetter && !superSetter) {
            throw new Error(`Animatable: property ${propName} has a custom ${superSetter ? "setter" : "getter"} but no ${superSetter ? "getter" : "setter"}. Animatable properties must have both.`);
          }
          break;
        }
        proto2 = Object.getPrototypeOf(proto2);
      }
      let actuallySet = superSetter ? function actuallySet2(value) {
        superSetter.call(this, value);
        if (!this[hasBeenSetKey]) {
          this[hasBeenSetKey] = true;
        }
      } : function actuallySet2(value) {
        this[actualValueKey] = value;
        if (!this[hasBeenSetKey]) {
          this[hasBeenSetKey] = true;
        }
      };
      Object.defineProperty(AnimatableFacade.prototype, actuallySetKey, { value: actuallySet });
      Object.defineProperty(AnimatableFacade.prototype, propName, {
        get() {
          return superGetter ? superGetter.call(this) : this[hasBeenSetKey] ? this[actualValueKey] : BaseFacadeClass.prototype[propName];
        },
        set(value) {
          if (this.animation$animatingProps && this.animation$animatingProps[propName]) {
            return;
          }
          let runner = this.animation$runner;
          let transition = this.transition;
          if (transition && transition[propName] && this[hasBeenSetKey] && transition.hasOwnProperty(propName)) {
            transition = transition[propName];
            let springConfig = transition === "spring" ? "default" : transition.spring;
            let tween2 = this[activeTweenKey];
            let needsNewTween = false;
            if (tween2) {
              if (value !== tween2.toValue) {
                if (springConfig && tween2.isSpring) {
                  tween2.toValue = value;
                } else {
                  runner.stop(tween2);
                  needsNewTween = true;
                }
              }
            } else if (value !== this[propName]) {
              needsNewTween = true;
            }
            if (needsNewTween) {
              tween2 = this[activeTweenKey] = springConfig ? new SpringTween(
                actuallySet.bind(this),
                //callback
                this[propName],
                //fromValue
                value,
                //toValue
                springConfig,
                //springConfig (mass, friction, tension)
                0,
                //initialVelocity
                transition.delay || 0
                //delay
              ) : new Tween(
                actuallySet.bind(this),
                //callback
                this[propName],
                //fromValue
                value,
                //toValue
                transition.duration || DEFAULT_DURATION,
                //duration
                transition.delay || 0,
                //delay
                transition.easing || DEFAULT_EASING,
                //easing
                1,
                //iterations
                "forward",
                //direction
                transition.interpolate || "number"
                //interpolate
              );
              tween2.onDone = () => {
                tween2 = this[activeTweenKey] = null;
              };
              runner.start(tween2);
            }
            return;
          }
          actuallySet.call(this, value);
          let tween = this[activeTweenKey];
          if (tween)
            runner.stop(tween);
          this[activeTweenKey] = null;
        }
      });
    }
    if (currentInstance.hasOwnProperty(propName)) {
      currentInstance[`${propName}anim:actualValue`] = currentInstance[propName];
      currentInstance[`${propName}anim:hasBeenSet`] = true;
      delete currentInstance[propName];
    }
  }
  return AnimatableFacade;
});
var extendAsPointerStatesAware = createClassExtender("pointerStates", function(BaseFacadeClass) {
  const isHoveringProp = "pntr:isHovering";
  const isActiveProp = "pntr:isActive";
  const propsWithInterceptors = /* @__PURE__ */ Object.create(null);
  class PointerStatesAware extends BaseFacadeClass {
    constructor(parent) {
      super(parent);
      this.addEventListener("mouseover", hoverOverHandler);
      this.addEventListener("mouseout", hoverOutHandler);
      this.addEventListener("mousedown", activeDownHandler);
      this.addEventListener("mouseup", activeUpHandler);
    }
    afterUpdate() {
      this._applyPointerStates();
      super.afterUpdate();
    }
    _applyPointerStates() {
      const pointerStates = this.pointerStates;
      const hoverValuesToUse = pointerStates && this[isHoveringProp] && pointerStates.hover || null;
      const activeValuesToUse = pointerStates && this[isActiveProp] && pointerStates.active || null;
      const lastAppliedValues = this["pntr:lastAppliedValues"] || propsWithInterceptors;
      const appliedValues = this["pntr:lastAppliedValues"] = hoverValuesToUse || activeValuesToUse ? assign(/* @__PURE__ */ Object.create(null), hoverValuesToUse, activeValuesToUse) : null;
      if (appliedValues) {
        for (let prop in appliedValues) {
          definePropInterceptor(prop, this);
          actuallySet(this, prop, appliedValues[prop]);
        }
      }
      if (lastAppliedValues) {
        for (let prop in lastAppliedValues) {
          if (!appliedValues || !(prop in appliedValues)) {
            actuallySet(this, prop, this[`${prop}pntr:baseValue`]);
          }
        }
      }
    }
  }
  Object.defineProperty(PointerStatesAware.prototype, "isPointerStateAware", { value: true });
  function definePropInterceptor(propName, currentInstance) {
    const hasBeenSetProp = `${propName}pntr:hasBeenSet`;
    if (!currentInstance[hasBeenSetProp]) {
      currentInstance[`${propName}pntr:baseValue`] = currentInstance[propName];
      delete currentInstance[propName];
      currentInstance[hasBeenSetProp] = true;
    }
    if (!PointerStatesAware.prototype.hasOwnProperty(propName)) {
      propsWithInterceptors[propName] = 1;
      const baseValueProp = `${propName}pntr:baseValue`;
      const appliedValueProp = `${propName}pntr:appliedValue`;
      Object.defineProperty(PointerStatesAware.prototype, propName, {
        get() {
          const superGetter = getSuperGetter(propName);
          return superGetter ? superGetter.call(this) : appliedValueProp in this ? this[appliedValueProp] : this[baseValueProp];
        },
        set(value) {
          this[baseValueProp] = value;
        }
      });
    }
  }
  function actuallySet(instance, propName, value) {
    const superSetter = getSuperSetter(propName);
    if (superSetter) {
      superSetter.call(instance, value);
    } else {
      instance[`${propName}pntr:appliedValue`] = value;
    }
  }
  function getSuperGetter(propName) {
    let proto2 = BaseFacadeClass.prototype;
    if (propName in proto2) {
      while (proto2) {
        let desc = Object.getOwnPropertyDescriptor(proto2, propName);
        if (desc && desc.get) {
          return desc.get;
        }
        proto2 = Object.getPrototypeOf(proto2);
      }
    }
    return null;
  }
  function getSuperSetter(propName) {
    let proto2 = BaseFacadeClass.prototype;
    if (propName in proto2) {
      while (proto2) {
        let desc = Object.getOwnPropertyDescriptor(proto2, propName);
        if (desc && desc.set) {
          return desc.set;
        }
        proto2 = Object.getPrototypeOf(proto2);
      }
    }
    return null;
  }
  function hoverOverHandler(e) {
    e.currentTarget[isHoveringProp] = true;
    afterPointerStateChange(e);
  }
  function hoverOutHandler(e) {
    e.currentTarget[isHoveringProp] = e.currentTarget[isActiveProp] = false;
    afterPointerStateChange(e);
  }
  function activeDownHandler(e) {
    e.currentTarget[isActiveProp] = true;
    afterPointerStateChange(e);
  }
  function activeUpHandler(e) {
    e.currentTarget[isActiveProp] = false;
    afterPointerStateChange(e);
  }
  function afterPointerStateChange(e) {
    let highestFacade = e.currentTarget;
    let parent = highestFacade.parent;
    while (parent && parent.shouldUpdateChildren()) {
      if (parent.isPointerStateAware) {
        highestFacade = parent;
      }
      parent = parent.parent;
    }
    highestFacade.afterUpdate();
    highestFacade.requestRender();
  }
  return PointerStatesAware;
});
var List = class extends Facade {
  constructor(parent) {
    super(parent);
    this._orderedItemKeys = [];
  }
  afterUpdate() {
    let { data, template } = this;
    let hasData = data && data.length && Array.isArray(data);
    if (true) {
      if (data && !Array.isArray(data)) {
        throw new Error('ListFacade "data" must be an array.');
      }
      if (!template || typeof template !== "object") {
        throw new Error('ListFacade "template" must be an object.');
      }
      if (!template || typeof template.key !== "function") {
        throw new Error('ListFacade template must define a "key" function.');
      }
      if (!template || typeof template.facade !== "function") {
        throw new Error('ListFacade template must define a "facade".');
      }
    }
    if (this.shouldUpdateChildren()) {
      let oldDict = this._itemsDict || null;
      let newDict = this._itemsDict = hasData ? /* @__PURE__ */ Object.create(null) : null;
      let orderedItemKeys = this._orderedItemKeys;
      if (hasData) {
        orderedItemKeys.length = data.length;
        for (let i = 0, len = data.length; i < len; i++) {
          let childData = data[i];
          let key = template.key(childData, i, data);
          let facadeClass = template.facade;
          if (true) {
            if (key == null) {
              throw new Error('ListFacade template "key" function must return a key.');
            }
            if (newDict[key]) {
              console.warn(`Duplicate key in list: ${key}`);
            }
          }
          while (newDict[key]) {
            key += "|dupe";
          }
          let transition = typeof template.transition === "function" ? template.transition(childData, i, data) : template.transition;
          let animation = typeof template.animation === "function" ? template.animation(childData, i, data) : template.animation;
          let exitAnimation = typeof template.exitAnimation === "function" ? template.exitAnimation(childData, i, data) : template.exitAnimation;
          if (transition || animation || exitAnimation) {
            facadeClass = extendAsAnimatable(facadeClass);
          }
          let pointerStates = template.pointerStates;
          if (pointerStates === "function" ? pointerStates(childData, i, data) : pointerStates) {
            facadeClass = extendAsPointerStatesAware(facadeClass);
          }
          let oldImpl = oldDict && oldDict[key];
          let newImpl;
          if (oldImpl && oldImpl.constructor === facadeClass) {
            newImpl = oldImpl;
          } else {
            if (oldImpl)
              oldImpl.destructor();
            newImpl = new facadeClass(this);
          }
          newImpl.transition = transition;
          newImpl.animation = animation;
          for (let prop in template) {
            if (template.hasOwnProperty(prop) && !Facade.isSpecialDescriptorProperty(prop)) {
              newImpl[prop] = typeof template[prop] === "function" ? template[prop](childData, i, data) : template[prop];
            }
          }
          newImpl.afterUpdate();
          newDict[key] = newImpl;
          orderedItemKeys[i] = key;
        }
      }
      if (oldDict) {
        for (let key in oldDict) {
          if (!newDict || !newDict[key]) {
            oldDict[key].destructor();
          }
        }
      }
    }
    super.afterUpdate();
  }
  /**
   * Override to selectively prevent updating the ListFacade's items on `afterUpdate`, for
   * potential performance gain.
   * @returns {boolean}
   */
  shouldUpdateChildren() {
    return true;
  }
  /**
   * Walk this facade's descendant tree, invoking a function for it and each descendant.
   * The iteration order will match the order in which the `data` items were declared. It may
   * also include items that have been queued for removal but not yet removed, e.g. facades
   * in the process of an `exitAnimation`.
   * @param {Function} fn
   * @param {Object} [thisArg]
   */
  traverse(fn, thisArg) {
    fn.call(thisArg, this);
    let keys = this._orderedItemKeys;
    let dict = this._itemsDict;
    for (let i = 0, len = keys.length; i < len; i++) {
      dict[keys[i]].traverse(fn, thisArg);
    }
  }
  /**
   * Iterate over this facade's direct child facades, invoking a function for each.
   * The iteration order will match the order in which the `data` items were declared. It may
   * also include items that have been queued for removal but not yet removed, e.g. facades
   * in the process of an `exitAnimation`.
   * @param {Function} fn
   * @param {Object} [thisArg]
   */
  forEachChild(fn, thisArg) {
    let keys = this._orderedItemKeys;
    let dict = this._itemsDict;
    for (let i = 0, len = keys.length; i < len; i++) {
      fn.call(thisArg, dict[keys[i]], keys[i]);
    }
  }
  destructor() {
    this.isDestroying = true;
    let dict = this._itemsDict;
    if (dict) {
      for (let key in dict) {
        dict[key].destructor();
      }
    }
    super.destructor();
  }
};
var TEMP_ARRAY$1 = [null];
var ParentFacade = class extends Facade {
  constructor(parent) {
    super(parent);
    this.children = null;
    this._orderedChildKeys = [];
  }
  afterUpdate() {
    if (this.shouldUpdateChildren()) {
      this.updateChildren(this.describeChildren());
    }
    super.afterUpdate();
  }
  /**
   * Return the descriptor(s) for the actual children to be created and managed. By default
   * this simply returns the value of the `children` property set by the parent, but you can
   * override it to customize how the child content should be structured, for instance to wrap
   * the `children` within a deeper structure, add in anonymous child siblings, or modify the
   * `children` configurations.
   * @protected
   * @return {FacadeDescriptor | Array<FacadeDescriptor>}
   */
  describeChildren() {
    return this.children;
  }
  /**
   * Override to selectively prevent traversing to child nodes on `afterUpdate`, for
   * potential performance gain.
   * @returns {boolean}
   */
  shouldUpdateChildren() {
    return true;
  }
  updateChildren(children) {
    const oldDict = this._childrenDict || null;
    let newDict = this._childrenDict = null;
    const orderedChildKeys = this._orderedChildKeys;
    orderedChildKeys.length = 0;
    if (children) {
      if (!Array.isArray(children)) {
        TEMP_ARRAY$1[0] = children;
        children = TEMP_ARRAY$1;
      }
      for (let i = 0, len = children.length; i < len; i++) {
        let childDesc = children[i];
        if (!childDesc)
          continue;
        if (!newDict) {
          newDict = this._childrenDict = /* @__PURE__ */ Object.create(null);
        }
        const isJSX = isReactElement(childDesc);
        let propsObj = isJSX ? childDesc.props : childDesc;
        let facadeClass = isJSX ? childDesc.type : childDesc.facade;
        let key = childDesc.key;
        if (!key) {
          let j = 0;
          do {
            key = `auto:${facadeClass.name}:${j++}`;
          } while (newDict[key]);
        }
        if (true) {
          if (typeof facadeClass !== "function") {
            throw new Error('All scene objects must have a "facade" property pointing to a class/constructor');
          }
        }
        if (newDict[key]) {
          console.warn(`Duplicate key in children: ${key}`);
          while (newDict[key]) {
            key += "|dupe";
          }
        }
        let transition = propsObj.transition;
        let animation = propsObj.animation;
        if (transition || animation || propsObj.exitAnimation) {
          facadeClass = extendAsAnimatable(facadeClass);
        }
        if (propsObj.pointerStates) {
          facadeClass = extendAsPointerStatesAware(facadeClass);
        }
        let oldImpl = oldDict && oldDict[key];
        let newImpl;
        if (oldImpl && oldImpl.constructor === facadeClass) {
          newImpl = oldImpl;
        } else {
          if (oldImpl)
            oldImpl.destructor();
          newImpl = new facadeClass(this);
        }
        newImpl.transition = transition;
        newImpl.animation = animation;
        for (let prop in propsObj) {
          if (propsObj.hasOwnProperty(prop) && !Facade.isSpecialDescriptorProperty(prop)) {
            newImpl[prop] = propsObj[prop];
          }
        }
        newDict[key] = newImpl;
        orderedChildKeys.push(key);
        newImpl.afterUpdate();
      }
    }
    if (oldDict) {
      for (let key in oldDict) {
        if (!newDict || !newDict[key]) {
          oldDict[key].destructor();
        }
      }
    }
  }
  getChildByKey(key) {
    let dict = this._childrenDict;
    return dict && dict[key] || null;
  }
  /**
   * Walk this facade's descendant tree, invoking a function for it and each descendant.
   * The iteration order will match the order in which the `children` were declared. It may
   * also include items that have been queued for removal but not yet removed, e.g. facades
   * in the process of an `exitAnimation`.
   * @param {Function} fn
   * @param {Object} [thisArg]
   */
  traverse(fn, thisArg) {
    fn.call(thisArg, this);
    const keys = this._orderedChildKeys;
    const dict = this._childrenDict;
    for (let i = 0, len = keys.length; i < len; i++) {
      dict[keys[i]].traverse(fn, thisArg);
    }
  }
  /**
   * Iterate over this facade's direct child facades, invoking a function for each.
   * The iteration order will match the order in which the `children` were declared. It may
   * also include items that have been queued for removal but not yet removed, e.g. facades
   * in the process of an `exitAnimation`.
   * @param {Function} fn
   * @param {Object} [thisArg]
   */
  forEachChild(fn, thisArg) {
    const keys = this._orderedChildKeys;
    const dict = this._childrenDict;
    for (let i = 0, len = keys.length; i < len; i++) {
      fn.call(thisArg, dict[keys[i]], keys[i]);
    }
  }
  destructor() {
    this.isDestroying = true;
    let dict = this._childrenDict;
    if (dict) {
      for (let key in dict) {
        dict[key].destructor();
      }
    }
    super.destructor();
  }
};
var pointerMotionEventProps = [
  "onMouseOver",
  "onMouseOut",
  "onMouseMove",
  "onDragStart",
  "onDrag",
  "onDragEnter",
  "onDragOver",
  "onDragLeave"
];
var pointerActionEventProps = [
  "onMouseDown",
  "onMouseUp",
  "onClick",
  "onDoubleClick",
  "onDrop",
  "onDragEnd",
  "onWheel"
];
var pointerActionEventTypes = pointerActionEventProps.map(eventPropToType);
var pointerMotionEventTypes = pointerMotionEventProps.map(eventPropToType);
var pointerEventProps = pointerMotionEventProps.concat(pointerActionEventProps);
var pointerEventTypes = pointerMotionEventTypes.concat(pointerActionEventTypes);
function eventPropToType(prop) {
  return prop === "onDoubleClick" ? "dblclick" : prop.replace(/^on/, "").toLowerCase();
}
var PointerEventTarget = class extends ParentFacade {
  /**
   * Determine if this PointerEventTarget should intercept pointer events:
   * - By default only facades with a pointer event listener assigned will be counted, to prevent being blocked by unwanted objects
   * - If an object should definitely block events from objects behind it, set `pointerEvents:true`
   * - If an object has one of the pointer event properties but should be ignored in picking, set `pointerEvents:false`
   */
  interceptsPointerEvents(eventRegistry) {
    if (this.pointerEvents === false) {
      return false;
    }
    if (this.pointerEvents) {
      return true;
    }
    for (let i = 0, len = pointerEventTypes.length; i < len; i++) {
      if (eventRegistry.hasFacadeListenersOfType(this, pointerEventTypes[i])) {
        return true;
      }
    }
  }
};
Object.defineProperty(PointerEventTarget.prototype, "isPointerEventTarget", { value: true });
pointerEventProps.forEach((propName) => {
  Facade.defineEventProperty(PointerEventTarget, propName, eventPropToType(propName));
});
function EventRegistry() {
  const byEventType = /* @__PURE__ */ Object.create(null);
  this.addListenerForFacade = (facade, type, handler) => {
    const listenersOfType = byEventType[type] || (byEventType[type] = {
      count: 0,
      byFacadeId: /* @__PURE__ */ Object.create(null)
    });
    const facadeId = facade.$facadeId;
    const oldHandlers = listenersOfType.byFacadeId[facadeId];
    if (!oldHandlers) {
      listenersOfType.count++;
      listenersOfType.byFacadeId[facadeId] = handler;
    } else if (Array.isArray(oldHandlers)) {
      if (oldHandlers.indexOf(handler) === -1) {
        listenersOfType.count++;
        oldHandlers.push(handler);
      }
    } else if (oldHandlers !== handler) {
      listenersOfType.count++;
      listenersOfType.byFacadeId[facadeId] = [oldHandlers, handler];
    }
  };
  this.removeListenerForFacade = (facade, type, handler) => {
    const listenersOfType = byEventType[type];
    const facadeId = facade.$facadeId;
    const oldHandlers = listenersOfType && listenersOfType.byFacadeId[facadeId];
    if (oldHandlers === handler) {
      listenersOfType.count--;
      delete listenersOfType.byFacadeId[facadeId];
    } else if (Array.isArray(oldHandlers)) {
      const idx = oldHandlers.indexOf(handler);
      if (idx > -1) {
        listenersOfType.count--;
        if (oldHandlers.length === 1) {
          delete listenersOfType.byFacadeId[facadeId];
        } else {
          oldHandlers.splice(idx, 1);
        }
      }
    }
  };
  this.removeAllListenersForFacade = (facade) => {
    const facadeId = facade.$facadeId;
    for (let type in byEventType) {
      let facadeListeners = byEventType[type].byFacadeId[facadeId];
      if (facadeListeners) {
        byEventType[type].count -= Array.isArray(facadeListeners) ? facadeListeners.length : 1;
        delete byEventType[type].byFacadeId[facadeId];
      }
    }
  };
  this.hasFacadeListenersOfType = (facade, type) => {
    return byEventType[type] ? !!byEventType[type].byFacadeId[facade.$facadeId] : false;
  };
  this.hasAnyListenersOfType = (type) => {
    return byEventType[type] ? byEventType[type].count > 0 : false;
  };
  this.findBubblingEventTarget = (targetFacade, eventType) => {
    while (targetFacade) {
      if (this.hasFacadeListenersOfType(targetFacade, eventType)) {
        return targetFacade;
      }
      targetFacade = targetFacade.parent;
    }
    return null;
  };
  function tryCall(func, scope, arg1, arg2) {
    try {
      func.call(scope, arg1, arg2);
    } catch (err) {
      console.error(err);
    }
  }
  this.forEachFacadeListenerOfType = (facade, type, callback, scope) => {
    const listenersOfType = byEventType[type];
    const facadeId = facade.$facadeId;
    const handlers = listenersOfType && listenersOfType.byFacadeId[facadeId];
    if (handlers) {
      if (Array.isArray(handlers)) {
        for (let i = 0; i < handlers.length; i++) {
          tryCall(callback, scope, handlers[i], facadeId);
        }
      } else {
        tryCall(callback, scope, handlers, facadeId);
      }
    }
  };
  this.forEachListenerOfType = (type, callback, scope) => {
    const listenersOfType = byEventType[type];
    if (listenersOfType && listenersOfType.count > 0) {
      for (let facadeId in listenersOfType.byFacadeId) {
        const facadeListeners = listenersOfType.byFacadeId[facadeId];
        if (Array.isArray(facadeListeners)) {
          for (let i = 0; i < facadeListeners.length; i++) {
            tryCall(callback, scope, facadeListeners[i], facadeId);
          }
        } else {
          tryCall(callback, scope, facadeListeners, facadeId);
        }
      }
    }
  };
  this.dispatchEventOnFacade = (facade, event) => {
    let currentTarget = facade;
    function callHandler(handler) {
      handler.call(currentTarget, event);
    }
    event.target = facade;
    while (currentTarget && !event.propagationStopped) {
      event.currentTarget = currentTarget;
      this.forEachFacadeListenerOfType(currentTarget, event.type, callHandler, null);
      if (event.bubbles) {
        currentTarget = currentTarget.parent;
      } else {
        break;
      }
    }
  };
}
var TAP_DISTANCE_THRESHOLD = 10;
var TAP_GESTURE_MAX_DUR = 300;
var TAP_DBLCLICK_MAX_DUR = 300;
var DEFAULT_EVENT_SOURCE = {};
var domPointerMotionEventTypes = [
  "mousemove",
  "mouseout",
  "touchmove"
];
var domPointerActionEventTypes = [
  "mousedown",
  "mouseup",
  "click",
  "dblclick",
  "wheel",
  "touchstart",
  "touchend",
  "touchcancel"
];
var dropEventTypes = [
  "mouseup",
  "touchend",
  "touchcancel"
];
var pointerActionEventTypeMappings = {
  "touchstart": "mousedown",
  "touchend": "mouseup",
  "touchcancel": "mouseup"
};
var touchDragPropsToNormalize = ["clientX", "clientY", "screenX", "screenY", "pageX", "pageY"];
var SyntheticEvent = class {
  constructor(nativeEvent, type, target, relatedTarget, extraProps) {
    for (let prop in nativeEvent) {
      if (typeof nativeEvent[prop] !== "function") {
        this[prop] = nativeEvent[prop];
      }
    }
    this.target = target;
    this.relatedTarget = relatedTarget;
    this.type = type;
    this.nativeEvent = nativeEvent;
    assign(this, extraProps);
    if (nativeEvent.touches) {
      let touches = isTouchEndOrCancel(nativeEvent) ? nativeEvent.changedTouches : nativeEvent.touches;
      if (touches.length === 1) {
        touchDragPropsToNormalize.forEach((prop) => {
          this[prop] = touches[0][prop];
        });
      }
    }
  }
  preventDefault() {
    this.defaultPrevented = true;
    this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.propagationStopped = true;
    this.nativeEvent.stopPropagation();
  }
};
function isTouchEndOrCancel(e) {
  return e.type === "touchend" || e.type === "touchcancel";
}
function killEvent(e) {
  e.stopPropagation();
  e.preventDefault();
}
var WorldBaseFacade = class extends ParentFacade {
  constructor(element) {
    super(null);
    this.width = this.height = 1;
    this._element = element;
    this._htmlOverlays = /* @__PURE__ */ Object.create(null);
    this.eventRegistry = new EventRegistry();
    this._onPointerMotionEvent = this._onPointerMotionEvent.bind(this);
    this._onPointerActionEvent = this._onPointerActionEvent.bind(this);
    this._onDropEvent = this._onDropEvent.bind(this);
    this._togglePointerListeners(true);
  }
  afterUpdate() {
    this._queueRender();
    super.afterUpdate();
  }
  onNotifyWorld(source, message, data) {
    let handler = this._notifyWorldHandlers[message];
    if (handler) {
      handler.call(this, source, data);
    }
  }
  _isContinuousRender() {
    return this.continuousRender;
  }
  /**
   * @property {{requestAnimationFrame, cancelAnimationFrame}} renderingScheduler
   * The object holding `requestAnimationFrame` and `cancelAnimationFrame` scheduling
   * functions. Defaults to `window` but can be switched to another implementation, e.g.
   * to use an XRSession's custom scheduler.
   */
  set renderingScheduler(scheduler) {
    scheduler = scheduler || window;
    if (scheduler !== this.renderingScheduler) {
      const activeHandle = this._nextFrameTimer;
      if (activeHandle) {
        this.renderingScheduler.cancelAnimationFrame(activeHandle);
        this._nextFrameTimer = null;
      }
      this._renderingScheduler = scheduler;
    }
  }
  get renderingScheduler() {
    return this._renderingScheduler || window;
  }
  // Schedule a render pass on the next frame
  _queueRender() {
    if (!this._nextFrameTimer) {
      const handler = this._nextFrameHandler || (this._nextFrameHandler = (...args) => {
        let { onStatsUpdate, onBeforeRender, onAfterRender } = this;
        let start = onStatsUpdate && Date.now();
        if (onBeforeRender)
          onBeforeRender(this);
        this.doRender(...args);
        if (onStatsUpdate) {
          let now = Date.now();
          onStatsUpdate({
            "Render CPU Time (ms)": now - start,
            "Time Between Frames (ms)": this._lastFrameTime ? now - this._lastFrameTime : "?",
            "FPS": this._lastFrameTime ? Math.round(1e3 / (now - this._lastFrameTime)) : "?"
          });
          this._lastFrameTime = now;
        }
        this._doRenderHtmlItems();
        if (onAfterRender)
          onAfterRender(this);
        this._nextFrameTimer = null;
        if (this._isContinuousRender()) {
          this._queueRender();
        }
      });
      this._nextFrameTimer = this.renderingScheduler.requestAnimationFrame(handler);
    }
  }
  /**
   * @abstract
   */
  doRender() {
  }
  /**
   * @abstract
   */
  getFacadeUserSpaceXYZ() {
  }
  _doRenderHtmlItems() {
    if (this.renderHtmlItems) {
      let htmlItemsData = [];
      let overlayFacades = this._htmlOverlays;
      for (let key in overlayFacades) {
        let facade = overlayFacades[key];
        let data = this.getFacadeUserSpaceXYZ(facade);
        if (data.z >= 0) {
          data.key = facade.$facadeId;
          data.html = facade.html;
          data.exact = facade.exact;
          htmlItemsData.push(data);
        }
      }
      this.renderHtmlItems(htmlItemsData);
    }
  }
  /**
   * Hook allowing world implementations to pre-normalize native pointer events, for instance
   * computing derived worldspace properties that are simpler for downstream code to use.
   * @param {Event} e
   * @protected
   */
  _normalizePointerEvent(e) {
  }
  /**
   * Entry point for handling events related to pointer motion (e.g. mouse or touch movement).
   * This will be called by the code that wraps this World facade to bridge native DOM events
   * into the Troika world.
   * @param {Event} e
   */
  _onPointerMotionEvent(e) {
    this._normalizePointerEvent(e);
    const eventState = this._getPointerEventState(e);
    if (pointerMotionEventTypes.some(this.eventRegistry.hasAnyListenersOfType)) {
      const hoverInfo = e.type === "mouseout" || isTouchEndOrCancel(e) ? null : this._findHoverTarget(e);
      let lastHovered = eventState.hoveredFacade;
      let hovered = eventState.hoveredFacade = hoverInfo && hoverInfo.facade;
      let dragInfo = eventState.dragInfo;
      if (dragInfo) {
        if (!dragInfo.dragStartFired) {
          this._firePointerEvent("dragstart", dragInfo.dragStartEvent, dragInfo.draggedFacade, null, hoverInfo);
          dragInfo.dragStartFired = true;
        }
        this._firePointerEvent("drag", e, dragInfo.draggedFacade, null, hoverInfo);
      }
      if (hovered !== lastHovered) {
        if (lastHovered) {
          this._firePointerEvent("mouseout", e, lastHovered, hovered, hoverInfo);
          if (dragInfo) {
            this._firePointerEvent("dragleave", e, lastHovered, hovered, hoverInfo);
          }
        }
        if (hovered) {
          this._firePointerEvent("mouseover", e, hovered, lastHovered, hoverInfo);
          if (dragInfo) {
            this._firePointerEvent("dragenter", e, hovered, lastHovered, hoverInfo);
          }
        }
      }
      if (hovered) {
        this._firePointerEvent("mousemove", e, hovered, null, hoverInfo);
        if (dragInfo) {
          this._firePointerEvent("dragover", e, hovered, null, hoverInfo);
        }
      }
    }
    let tapInfo = eventState.tapInfo;
    if (tapInfo && e.type === "touchmove") {
      let touch = e.changedTouches[0];
      if (touch && Math.sqrt(Math.pow(touch.clientX - tapInfo.x, 2) + Math.pow(touch.clientY - tapInfo.y, 2)) > TAP_DISTANCE_THRESHOLD) {
        eventState.tapInfo = null;
      }
    }
  }
  /**
   * Entry point for handling events related to pointer motion (e.g. mouse clicks or touch taps).
   * This will be called by the code that wraps this World facade to bridge native DOM events
   * into the Troika world.
   * @param {Event} e
   */
  _onPointerActionEvent(e) {
    this._normalizePointerEvent(e);
    if (dropEventTypes.indexOf(e.type) > -1) {
      this._onDropEvent(e);
    }
    if (e.type === "touchstart") {
      if (e.touches.length === 1) {
        this._onPointerMotionEvent(e);
      }
      this._enableContextMenu(false);
    }
    const eventRegistry = this.eventRegistry;
    if (eventRegistry.hasAnyListenersOfType("dragstart") || pointerActionEventTypes.some(eventRegistry.hasAnyListenersOfType)) {
      let hoverInfo = this._findHoverTarget(e);
      let facade = hoverInfo && hoverInfo.facade;
      if (facade) {
        const eventState = this._getPointerEventState(e);
        this._firePointerEvent(pointerActionEventTypeMappings[e.type] || e.type, e, facade, null, hoverInfo);
        if (eventRegistry.findBubblingEventTarget(facade, "click") || eventRegistry.findBubblingEventTarget(facade, "dblclick")) {
          let tapInfo = eventState.tapInfo;
          if (e.type === "touchstart" && e.touches.length === 1) {
            eventState.tapInfo = {
              facade,
              x: e.touches[0].clientX,
              y: e.touches[0].clientY,
              startTime: Date.now(),
              isDblClick: tapInfo && Date.now() - tapInfo.startTime < TAP_DBLCLICK_MAX_DUR
            };
          } else {
            if (tapInfo && tapInfo.facade === facade && e.type === "touchend" && e.touches.length === 0 && e.changedTouches.length === 1 && Date.now() - tapInfo.startTime < TAP_GESTURE_MAX_DUR) {
              this._firePointerEvent("click", e, facade, null, hoverInfo);
              if (tapInfo.isDblClick) {
                this._firePointerEvent("dblclick", e, facade, null, hoverInfo);
              }
            }
          }
        }
        if (e.type === "mousedown" || e.type === "touchstart") {
          const dragger = eventRegistry.findBubblingEventTarget(facade, "dragstart");
          if (dragger) {
            let dragStartEvent = new SyntheticEvent(e, "dragstart", dragger, null, { intersection: hoverInfo });
            eventState.dragInfo = {
              draggedFacade: dragger,
              dragStartFired: false,
              dragStartEvent
            };
            this._toggleDropListeners(true);
          }
        }
      }
      e.preventDefault();
    }
    if (isTouchEndOrCancel(e)) {
      if (e.changedTouches.length === 1) {
        this._onPointerMotionEvent(e);
      }
      this._enableContextMenu(true);
    }
  }
  _onDropEvent(e) {
    const eventState = this._getPointerEventState(e);
    let dragInfo = eventState.dragInfo;
    if (dragInfo) {
      this._normalizePointerEvent(e);
      let hoverInfo = this._findHoverTarget(e);
      let targetFacade = hoverInfo && hoverInfo.facade;
      if (targetFacade) {
        this._firePointerEvent("drop", e, targetFacade, null, hoverInfo);
      }
      this._firePointerEvent("dragend", e, dragInfo.draggedFacade, null, hoverInfo);
      this._toggleDropListeners(false);
      eventState.dragInfo = null;
    }
  }
  _firePointerEvent(eventType, originalEvent, targetFacade, relatedTargetFacade, intersection) {
    let newEvent = originalEvent instanceof SyntheticEvent ? originalEvent : new SyntheticEvent(
      originalEvent,
      eventType,
      targetFacade,
      relatedTargetFacade,
      {
        bubbles: true,
        intersection
      }
    );
    this.eventRegistry.dispatchEventOnFacade(targetFacade, newEvent);
  }
  _getPointerEventState(e) {
    const states = this._pointerEventStates || (this._pointerEventStates = /* @__PURE__ */ new WeakMap());
    const eventSource = e.eventSource || DEFAULT_EVENT_SOURCE;
    let eventState = states.get(eventSource);
    if (!eventState) {
      states.set(eventSource, eventState = {});
    }
    return eventState;
  }
  _toggleDropListeners(on) {
    dropEventTypes.forEach((type) => {
      document[(on ? "add" : "remove") + "EventListener"](type, this._onDropEvent, true);
    });
  }
  _togglePointerListeners(on) {
    let canvas = this._element;
    if (canvas && on !== this._pointerListenersAttached) {
      let method = (on ? "add" : "remove") + "EventListener";
      domPointerMotionEventTypes.forEach((type) => {
        canvas[method](type, this._onPointerMotionEvent, false);
      });
      domPointerActionEventTypes.forEach((type) => {
        canvas[method](type, this._onPointerActionEvent, false);
      });
      this._pointerListenersAttached = on;
    }
  }
  _enableContextMenu(enable) {
    let canvas = this._element;
    if (canvas) {
      canvas[(enable ? "remove" : "add") + "EventListener"]("contextmenu", killEvent, true);
    }
  }
  /**
   * @abstract
   * Given a pointer-related Event, find and return all facade objects that are intersected
   * by that event. If any hits are found, this should return an array of objects that contain
   * at least `facade` and `distance` properties. Any additional properties will be exposed to
   * event listeners on the synthetic event object as an `intersection` property.
   * @param {Event} e
   * @param {Function} [filterFn]
   * @return {Array<{facade, distance, ?distanceBias, ...}>|null}
   */
  getFacadesAtEvent(e, filterFn) {
    throw new Error("getFacadesAtEvent: no impl");
  }
  _findHoverTarget(e) {
    if (e.touches && e.touches.length > 1) {
      return null;
    }
    let allHits = this.getFacadesAtEvent(
      e,
      (facade) => facade.isPointerEventTarget && facade.interceptsPointerEvents(this.eventRegistry)
    );
    if (allHits) {
      let closestHit = allHits[0];
      for (let i = 1; i < allHits.length; i++) {
        if (allHits[i].distance < closestHit.distance || allHits[i].distance === closestHit.distance && (allHits[i].distanceBias || 0) < (closestHit.distanceBias || 0)) {
          closestHit = allHits[i];
        }
      }
      return closestHit;
    }
    return null;
  }
  destructor() {
    if (this._nextFrameTimer) {
      this.renderingScheduler.cancelAnimationFrame(this._nextFrameTimer);
    }
    this._togglePointerListeners(false);
    this._toggleDropListeners(false);
    super.destructor();
  }
};
Object.defineProperty(WorldBaseFacade.prototype, "isWorld", { value: true });
WorldBaseFacade.prototype._notifyWorldHandlers = {
  needsRender() {
    this._queueRender();
  },
  addEventListener(source, data) {
    this.eventRegistry.addListenerForFacade(source, data.type, data.handler);
  },
  removeEventListener(source, data) {
    this.eventRegistry.removeListenerForFacade(source, data.type, data.handler);
  },
  removeAllEventListeners(source) {
    this.eventRegistry.removeAllListenersForFacade(source);
  },
  dispatchEvent(source, event) {
    if (!(event instanceof SyntheticEvent)) {
      event = new SyntheticEvent(event, event.type, event.target, event.relatedTarget);
    }
    this.eventRegistry.dispatchEventOnFacade(source, event);
  },
  addHtmlOverlay(source) {
    this._htmlOverlays[source.$facadeId] = source;
  },
  removeHtmlOverlay(source) {
    delete this._htmlOverlays[source.$facadeId];
  },
  statsUpdate(source, data) {
    let onStatsUpdate = this.onStatsUpdate;
    if (onStatsUpdate)
      onStatsUpdate(data);
  }
};
var CT_STYLES = {
  position: "absolute",
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  pointerEvents: "none",
  transformStyle: "preserve-3d"
};
var HtmlOverlayContent = class extends import_react.default.Component {
  shouldComponentUpdate(newProps) {
    return newProps.html !== this.props.html || (newProps.html.props && newProps.html.props.shouldUpdateOnMove) === true;
  }
  render() {
    let html = this.props.html;
    return typeof html === "string" ? import_react.default.createElement("span", null, html) : import_react.default.cloneElement(html);
  }
};
HtmlOverlayContent.displayName = "Canvas3D.HtmlOverlayContent";
HtmlOverlayContent.propTypes = {
  html: import_prop_types.default.node
};
var HtmlOverlay = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.setItems = this.setItems.bind(this);
    this.state = {
      items: null
    };
  }
  shouldComponentUpdate(newProps, newState) {
    let oldState = this.state;
    return newState.items && newState.items.length || oldState.items && oldState.items.length;
  }
  setItems(items) {
    let lastItems = this.state.items;
    if (items && items.length || lastItems && lastItems.length) {
      this.setState({ items: items || null });
    }
  }
  render() {
    let items = this.state.items;
    let round = Math.round;
    return items && items.length ? import_react.default.createElement(
      "div",
      {
        className: "troika_html_overlay",
        style: CT_STYLES
      },
      items.map(({ key, html, x, y, z, exact }) => {
        if (!exact) {
          x = round(x);
          y = round(y);
        }
        return import_react.default.createElement(
          "div",
          {
            key,
            style: {
              position: "absolute",
              transform: `translate3d(${x}px, ${y}px, ${-z}px)`
            }
          },
          import_react.default.createElement(HtmlOverlayContent, { html })
        );
      })
    ) : null;
  }
};
HtmlOverlay.displayName = "Canvas3D.HtmlOverlay";
var style = {
  position: "absolute",
  top: 0,
  right: 0,
  background: "rgba(0,0,0,.5)",
  font: "11px sans-serif",
  padding: 10
};
var Stats = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this.state = { stats: {} };
  }
  setStats(stats) {
    this.setState({ stats });
  }
  render() {
    let stats = this.state.stats;
    return import_react.default.createElement(
      "div",
      { style },
      Object.keys(stats).sort().map(
        (key) => import_react.default.createElement("div", { key }, `${key}: ${stats[key]}`)
      )
    );
  }
};
var defaultCanvasStyle = { width: "100%", height: "100%" };
var CanvasBase = class extends import_react.default.Component {
  constructor(props) {
    super(props);
    this._stats = {};
    this.updateStats = this.updateStats.bind(this);
    this.renderHtmlItems = this.renderHtmlItems.bind(this);
    this._bindHtmlOverlayRef = this._bindHtmlOverlayRef.bind(this);
    this._bindCanvasRef = this._bindCanvasRef.bind(this);
    this._bindStatsRef = this._bindStatsRef.bind(this);
  }
  componentDidUpdate() {
    this.updateWorld();
  }
  initWorld(canvas) {
    const world = new this.props.worldFacade(canvas);
    world.renderHtmlItems = this.renderHtmlItems;
    return world;
  }
  updateWorld() {
    const world = this._world;
    if (world) {
      const { props } = this;
      let useStats = props.stats;
      let start = useStats && Date.now();
      world.width = props.width;
      world.height = props.height;
      world.pixelRatio = props.pixelRatio;
      world.continuousRender = props.continuousRender;
      world.onStatsUpdate = useStats ? this.updateStats : null;
      assign(world, props.worldProps);
      world.afterUpdate();
      if (useStats) {
        this.updateStats({ "Last World Update (ms)": Date.now() - start });
      }
    }
  }
  destroyWorld() {
    if (this._world) {
      this._world.destructor();
      delete this._world;
    }
    clearTimeout(this._statsDelay);
  }
  renderHtmlItems(items) {
    if (this._htmlOverlayRef) {
      this._htmlOverlayRef.setItems(items);
    }
  }
  updateStats(stats) {
    this._stats = assign({}, this._stats, stats);
    if (!this._statsDelay) {
      this._statsDelay = setTimeout(() => {
        this._statsDelay = null;
        let ref = this._statsRef;
        if (ref) {
          ref.setStats(this._stats);
        }
      }, 250);
    }
  }
  _bindHtmlOverlayRef(cmp) {
    this._htmlOverlayRef = cmp;
  }
  _bindCanvasRef(canvas) {
    if (canvas) {
      try {
        this._world = this.initWorld(canvas);
        this.updateWorld();
      } catch (e) {
        console.warn(`Troika.${this.constructor.displayName}: world init failed, using fallback content.`, e);
        this._failedWorldInit = true;
        this._world = null;
        this.forceUpdate();
      }
    } else {
      this.destroyWorld();
    }
    const cb = this.props.onCanvasRef;
    if (cb)
      cb(canvas);
  }
  _bindStatsRef(ref) {
    this._statsRef = ref;
  }
  render() {
    let { props } = this;
    return import_react.default.createElement(
      "div",
      {
        className: `troika ${props.className || ""}`,
        style: {
          position: "relative",
          overflow: "hidden",
          width: props.width,
          height: props.height,
          cursor: props.cursor,
          userSelect: "none"
        }
      },
      this._failedWorldInit ? this.props.children : import_react.default.createElement(
        "canvas",
        {
          className: "troika_canvas",
          ref: this._bindCanvasRef,
          style: props.canvasStyle || defaultCanvasStyle
        }
      ),
      import_react.default.createElement(HtmlOverlay, { ref: this._bindHtmlOverlayRef }),
      props.stats ? import_react.default.createElement(Stats, { ref: this._bindStatsRef }) : null
    );
  }
};
CanvasBase.commonPropTypes = {
  width: import_prop_types.default.number.isRequired,
  height: import_prop_types.default.number.isRequired,
  pixelRatio: import_prop_types.default.number,
  worldFacade: import_prop_types.default.func,
  worldProps: import_prop_types.default.object,
  canvasStyle: import_prop_types.default.object,
  className: import_prop_types.default.string,
  continuousRender: import_prop_types.default.bool,
  onCanvasRef: import_prop_types.default.func,
  stats: import_prop_types.default.bool,
  cursor: import_prop_types.default.string
};

// node_modules/troika-3d/dist/troika-3d.esm.js
var import_react2 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());
var { assign: assign2, forOwn: forOwn2 } = utils;
var singletonVec3 = new Vector3();
var singletonVec3b = new Vector3();
var notifyWorldGetter = /* @__PURE__ */ function() {
  const obj = {
    callback: function(pos) {
      obj.value = pos;
    },
    value: null
  };
  return obj;
}();
var removedEvent = { type: "removed" };
var singletonIntersects = [];
function ascDistanceSort(a, b) {
  return a.distance - b.distance;
}
function canObjectBeOrphaned(obj) {
  return obj.isRenderable === false && (!obj.children.length || obj.children.every(canObjectBeOrphaned));
}
var _worldMatrixVersion = 0;
var _geometrySphereVersion = 0;
var Object3DFacade = class extends PointerEventTarget {
  constructor(parent, threeObject) {
    super(parent);
    if (!threeObject) {
      threeObject = this.initThreeObject();
    }
    threeObject.matrixAutoUpdate = false;
    this.threeObject = threeObject;
    threeObject.$facade = this;
    let isRenderable = threeObject.isRenderable !== false;
    if (!isRenderable) {
      threeObject.layers.mask = 0;
    }
    while (parent) {
      if (parent.isObject3DFacade) {
        this._parentObject3DFacade = parent;
        if (isRenderable) {
          this._addToThreeObjectTree();
        }
        break;
      }
      parent = parent.parent;
    }
    this.notifyWorld("object3DAdded");
  }
  /**
   * Lifecycle method, called at constructor time, that creates and returns a Three.js `Object3D`
   * instance which will become the `threeObject` for this facade. This is a more ergonomic
   * alternative than overriding the constructor to pass the `threeObject` as a second argument
   * to the super() call. By default it creates a plain Object3D marked as non-renderable so it
   * is not added to the Three.js tree.
   * @return {Object3D}
   * @protected
   */
  initThreeObject() {
    const obj = new Object3D();
    obj.isRenderable = false;
    return obj;
  }
  afterUpdate() {
    this.updateMatrices();
    this._checkBoundsChange();
    if (this._worldMatrixVersion > this._worldMatrixVersionAfterLastUpdate) {
      if (!this.shouldUpdateChildren()) {
        this.traverse((facade, rootFacade) => {
          if (facade !== rootFacade && facade.updateMatrices) {
            facade.updateMatrices();
            facade._checkBoundsChange();
          }
        }, this);
      }
      this._worldMatrixVersionAfterLastUpdate = this._worldMatrixVersion;
    }
    super.afterUpdate();
    this._flushQueuedChildRemovals();
  }
  /**
   * Update the underlying threeObject's `matrix` and `matrixWorld` to the current state if necessary.
   * This bypasses the `updateMatrix` and `updateMatrixWorld` methods of the threejs objects with a more
   * efficient approach that doesn't require traversing the entire tree prior to every render. This is possible
   * since we control the update lifecycle; as long as this is called from the `afterUpdate` lifecycle
   * method or later, it can be safely assumed that the world matrices of all ancestors have already been
   * similarly updated so the result should always be accurate.
   */
  updateMatrices() {
    let threeObj = this.threeObject;
    let parent3DFacade = this._parentObject3DFacade;
    let needsWorldMatrixUpdate;
    if (this._matrixChanged) {
      threeObj.matrix.compose(threeObj.position, threeObj.quaternion, threeObj.scale);
      this._matrixChanged = false;
      needsWorldMatrixUpdate = true;
    } else {
      needsWorldMatrixUpdate = parent3DFacade && parent3DFacade._worldMatrixVersion > this._worldMatrixVersion;
    }
    if (needsWorldMatrixUpdate) {
      if (parent3DFacade) {
        threeObj.matrixWorld.multiplyMatrices(parent3DFacade.threeObject.matrixWorld, threeObj.matrix);
      } else {
        threeObj.matrixWorld.copy(threeObj.matrix);
      }
      let threeKids = threeObj.children;
      for (let i = 0, len = threeKids.length; i < len; i++) {
        if (!threeKids[i].$facade) {
          threeKids[i].updateMatrixWorld(true);
        }
      }
      this.markWorldMatrixDirty();
    }
  }
  /**
   * If the `threeObject.matrixWorld` is modified manually instead of via the individual transformation
   * properties, you can call this to tell the facade its caches need to be recalculated.
   */
  markWorldMatrixDirty() {
    this._worldMatrixVersion = ++_worldMatrixVersion;
    this._boundsChanged = true;
  }
  _checkBoundsChange() {
    let changed = this._boundsChanged;
    if (!changed) {
      const geomSphere = this._getGeometryBoundingSphere();
      if (geomSphere && geomSphere.version !== this._lastGeometrySphereVersion) {
        changed = true;
        this._lastGeometrySphereVersion = geomSphere.version;
      }
    }
    if (changed) {
      this.notifyWorld("object3DBoundsChanged");
      this._boundsChanged = false;
    }
  }
  /**
   * Get this object's current position in world space
   * @param {Vector3} [vec3] - optional Vector3 object to populate with the position;
   *                  if not passed in a new one will be created.
   * @returns {Vector3}
   */
  getWorldPosition(vec3) {
    this.updateMatrices();
    return (vec3 || new Vector3()).setFromMatrixPosition(this.threeObject.matrixWorld);
  }
  /**
   * Get the current position vector of the world's camera.
   * @param {Vector3} [vec3] - optional Vector3 object to populate with the position;
   *                  if not passed in a new one will be created.
   * @returns {Vector3}
   */
  getCameraPosition(vec3) {
    vec3 = vec3 || new Vector3();
    this.notifyWorld("getCameraPosition", vec3);
    return vec3;
  }
  /**
   * Get the facade object for the world's camera. Can be used to get to low-level info
   * about the camera such as its various matrices, but be careful not to make modifications
   * to the camera as that can lead to things getting out of sync.
   * @returns {Camera3DFacade}
   */
  getCameraFacade() {
    notifyWorldGetter.value = null;
    this.notifyWorld("getCameraFacade", notifyWorldGetter);
    return notifyWorldGetter.value;
  }
  /**
   * Calculate the distance in world units between this object's origin and the camera.
   * @returns {Number}
   */
  getCameraDistance() {
    let cameraPos = this.getCameraPosition(singletonVec3b);
    let objectPos = this.getWorldPosition(singletonVec3);
    return cameraPos.distanceTo(objectPos);
  }
  /**
   * Get the current projected user space position for this object, or for a specific position
   * in its object space.
   * @returns {Vector3} x and y are in screen pixels, z is worldspace distance from camera. The
   *                    z may be negative, which means it is out of view behind the camera.
   */
  getProjectedPosition(x, y, z) {
    this.updateMatrices();
    notifyWorldGetter.value = null;
    notifyWorldGetter.worldPosition = singletonVec3.set(x || 0, y || 0, z || 0).applyMatrix4(this.threeObject.matrixWorld);
    this.notifyWorld("projectWorldPosition", notifyWorldGetter);
    return notifyWorldGetter.value;
  }
  /**
   * Get the facade object for the world's scene.
   * @returns {Scene3DFacade}
   */
  getSceneFacade() {
    notifyWorldGetter.value = null;
    this.notifyWorld("getSceneFacade", notifyWorldGetter);
    return notifyWorldGetter.value;
  }
  /**
   * Return a {@link Sphere} encompassing the bounds of this object in worldspace, or `null` if
   * it has no physical bounds. This is used for optimized raycasting.
   *
   * The default implementation attempts to be as efficient as possible, only updating the sphere
   * when necessary, and assumes the threeObject has a geometry that accurately describes its bounds.
   * Override this method to provide custom bounds calculation logic, for example when additional meshes
   * need to be checked or a vertex shader manipulates the geometry; you'll probably also need to override
   * {@link #raycast} to match.
   *
   * TODO: this needs to be easier to override without having to reimplement large chunks of logic
   */
  getBoundingSphere() {
    let geomSphere = this._getGeometryBoundingSphere();
    if (!geomSphere)
      return null;
    this.updateMatrices();
    let sphere = this._boundingSphere;
    if (!sphere) {
      sphere = this._boundingSphere = new Sphere();
    }
    if (sphere._geometrySphereVersion !== geomSphere.version || sphere._worldMatrixVersion !== this._worldMatrixVersion) {
      sphere.copy(geomSphere);
      sphere.applyMatrix4(this.threeObject.matrixWorld);
      sphere._worldMatrixVersion = this._worldMatrixVersion;
      sphere._geometrySphereVersion = geomSphere.version;
    }
    return sphere;
  }
  /**
   * Ensure the object's geometry, if any, has an up-to-date bounding Sphere, and return that Sphere.
   * The returned Sphere will be assigned a unique `version` property when it is modified, which can
   * be used elsewhere for tracking changes.
   * @private
   */
  _getGeometryBoundingSphere() {
    const geometry = this.getGeometry();
    if (geometry) {
      let geomSphere = geometry.boundingSphere;
      let geomSphereChanged = false;
      if (geomSphere) {
        if (geometry.isBufferGeometry) {
          const posAttr = geometry.attributes.position;
          if (posAttr && geomSphere._posAttrVersion !== posAttr.version) {
            geometry.computeBoundingSphere();
            geomSphere._posAttrVersion = posAttr.version;
            geomSphereChanged = true;
          }
        } else {
          if (!geometry._lastBoundingSphere || !geomSphere.equals(geometry._lastBoundingSphere)) {
            geometry._lastBoundingSphere = geomSphere.clone();
            geomSphereChanged = true;
          }
        }
      } else {
        geometry.computeBoundingSphere();
        geomSphere = geometry.boundingSphere;
        geomSphereChanged = true;
      }
      if (geomSphereChanged) {
        geomSphere.version = ++_geometrySphereVersion;
      }
      return geomSphere;
    } else {
      return null;
    }
  }
  /**
   * @protected Extension point for subclasses that don't use their threeObject's geometry, e.g. Instanceable
   */
  getGeometry() {
    const obj = this.threeObject;
    return obj && obj.geometry;
  }
  /**
   * Determine if this facade's threeObject intersects a Raycaster. Override this method to provide
   * custom raycasting logic, for example when additional meshes need to be checked or a vertex shader
   * manipulates the geometry; you'll probably also need to override {@link #getBoundingSphere} to match.
   *
   * The return value can be:
   *   - An array of hit objects for this facade, matching the format returned by `Raycaster.intersectObject`
   *   - `null`, if this facade has no hits
   */
  raycast(raycaster2) {
    return this.threeObject ? this._raycastObject(this.threeObject, raycaster2) : null;
  }
  /**
   * Custom optimized raycast that, unlike Raycaster.intersectObject(), avoids creating a
   * new array unless there are actually hits. It also supports the custom `raycastSide`
   * override property, hit on sides other than the material's configured `side`.
   * @protected
   */
  _raycastObject(obj, raycaster2) {
    if (obj.visible) {
      singletonIntersects.length = 0;
      let origSide = null;
      const raycastSide = this.raycastSide;
      if (raycastSide != null) {
        origSide = obj.material.side;
        obj.material.side = raycastSide;
      }
      obj.raycast(raycaster2, singletonIntersects);
      if (origSide !== null) {
        obj.material.side = origSide;
      }
      if (singletonIntersects.length) {
        singletonIntersects.sort(ascDistanceSort);
        return singletonIntersects.slice();
      }
    }
    return null;
  }
  _addToThreeObjectTree() {
    let parent = this._parentObject3DFacade;
    if (parent) {
      if (this.threeObject.parent !== parent.threeObject) {
        parent.threeObject.add(this.threeObject);
        parent._addToThreeObjectTree();
      }
    }
  }
  _queueRemoveChildObject3D(threeObjectId) {
    let removeChildIds = this._removeChildIds || (this._removeChildIds = /* @__PURE__ */ Object.create(null));
    removeChildIds[threeObjectId] = true;
  }
  _flushQueuedChildRemovals() {
    if (this._removeChildIds) {
      let threeObject = this.threeObject;
      let removeChildIds = this._removeChildIds;
      threeObject.children = threeObject.children.filter((child) => {
        if (child.id in removeChildIds) {
          child.parent = null;
          child.dispatchEvent(removedEvent);
          return false;
        }
        return true;
      });
      let parentObj3D = this._parentObject3DFacade;
      if (canObjectBeOrphaned(threeObject) && parentObj3D && parentObj3D.threeObject === threeObject.parent) {
        parentObj3D._queueRemoveChildObject3D(threeObject.id);
        parentObj3D._flushQueuedChildRemovals();
      }
      this._removeChildIds = null;
    }
  }
  destructor() {
    this.notifyWorld("object3DRemoved");
    let parentObj3D = this._parentObject3DFacade;
    if (parentObj3D) {
      parentObj3D._queueRemoveChildObject3D(this.threeObject.id);
    }
    delete this.threeObject;
    super.destructor();
  }
};
["castShadow", "receiveShadow", "renderOrder", "visible"].forEach((prop) => {
  Object.defineProperty(Object3DFacade.prototype, prop, {
    get() {
      return this.threeObject[prop];
    },
    set(value) {
      this.threeObject[prop] = value;
    }
  });
});
Object3DFacade.prototype.raycastSide = null;
forOwn2({
  position: {
    x: "x",
    y: "y",
    z: "z"
  },
  scale: {
    x: "scaleX",
    y: "scaleY",
    z: "scaleZ"
  },
  rotation: {
    x: "rotateX",
    y: "rotateY",
    z: "rotateZ",
    order: "rotateOrder"
  },
  quaternion: {
    x: "quaternionX",
    y: "quaternionY",
    z: "quaternionZ",
    w: "quaternionW"
  }
}, (attrs, aspect) => {
  forOwn2(attrs, (propName, attr) => {
    Object.defineProperty(Object3DFacade.prototype, propName, {
      get: new Function(`return function ${propName}$get() {
  return this.threeObject.${aspect}.${attr}
}`)(),
      set: new Function(`return function ${propName}$set(value) {
  //let obj = this.threeObject.${aspect}
  if (this.threeObject.${aspect}.${attr} !== value) {
    this.threeObject.${aspect}.${attr} = value
    if (!this._matrixChanged) {
      this._matrixChanged = true
    }
  }
}`)()
    });
  });
});
Object.defineProperty(Object3DFacade.prototype, "scale", {
  get() {
    return this.threeObject.scale.x;
  },
  set(value) {
    const scaleObj = this.threeObject.scale;
    if (value !== scaleObj.x || value !== scaleObj.y || value !== scaleObj.z) {
      scaleObj.x = scaleObj.y = scaleObj.z = value;
      if (!this._matrixChanged) {
        this._matrixChanged = true;
      }
    }
  }
});
Object.defineProperty(Object3DFacade.prototype, "isObject3DFacade", { value: true });
assign2(Object3DFacade.prototype, {
  threeObject: null,
  _parentObject3DFacade: null,
  _removeChildIds: null,
  _matrixChanged: true,
  _worldMatrixVersion: -1,
  _worldMatrixVersionAfterLastUpdate: -1,
  _boundingSphereChanged: false
});
Facade.defineEventProperty(Object3DFacade, "onBeforeRender", "beforerender");
Facade.defineEventProperty(Object3DFacade, "onAfterRender", "afterrender");
var noop2 = function() {
};
var tempRaycaster = new Raycaster();
var tempVec2 = new Vector2();
var tempVec3 = new Vector3();
var tempMat4 = new Matrix4();
var tempQuat = new Quaternion();
var lookAtUp = new Vector3(0, 1, 0);
var _projectionMatrixVersion = 0;
function createCameraFacade(threeJsCameraClass, projectionProps, otherProps) {
  class Camera3DFacade extends Object3DFacade {
    constructor(parent) {
      super(parent);
      this.lookAt = this.up = null;
      this._projectionChanged = false;
      this._frustum = new Frustum();
    }
    initThreeObject() {
      const camera = new threeJsCameraClass();
      camera.updateMatrixWorld = noop2;
      return camera;
    }
    afterUpdate() {
      if (this.lookAt) {
        tempVec3.copy(this.lookAt);
        lookAtUp.copy(this.up || Object3D.DefaultUp);
        tempMat4.lookAt(this.threeObject.position, tempVec3, lookAtUp);
        tempQuat.setFromRotationMatrix(tempMat4);
        this.quaternionX = tempQuat.x;
        this.quaternionY = tempQuat.y;
        this.quaternionZ = tempQuat.z;
        this.quaternionW = tempQuat.w;
      }
      super.afterUpdate();
    }
    updateMatrices() {
      let camObj = this.threeObject;
      if (this._projectionChanged) {
        camObj.updateProjectionMatrix();
        this._projectionChanged = false;
        this._projectionMatrixVersion = _projectionMatrixVersion++;
      }
      let matrixVersionBeforeUpdate = this._worldMatrixVersion;
      super.updateMatrices();
      if (matrixVersionBeforeUpdate !== this._worldMatrixVersion) {
        invertMatrix4(camObj.matrixWorld, camObj.matrixWorldInverse);
      }
    }
    /**
     * Utility method that returns a Frustum object which is initialized to match this camera's
     * current state. This can be used for example to optimize updates to the Facade tree by
     * avoiding work for objects that fall outside the camera's view.
     *
     * You can access this by calling `this.getCameraFacade().getFrustum()` from any Object3DFacade's
     * `afterUpdate` lifecycle method or later.
     *
     * Be careful that this Frustum does not get modified after it is requested, as it is cached for
     * the lifetime of the camera's current world matrix and modifiying it would result in bad state
     * for other code requesting it within that lifetime.
     *
     * @return {Frustum}
     */
    getFrustum() {
      this.updateMatrices();
      let frustum = this._frustum;
      let { _worldMatrixVersion: _worldMatrixVersion2, _projectionMatrixVersion: _projectionMatrixVersion2 } = this;
      if (frustum._lastWorldMatrixVersion !== _worldMatrixVersion2 || frustum._lastProjMatrixVersion !== _projectionMatrixVersion2) {
        let camObj = this.threeObject;
        let matrix = new Matrix4().multiplyMatrices(camObj.projectionMatrix, camObj.matrixWorldInverse);
        frustum.setFromMatrix(matrix);
        frustum._lastWorldMatrixVersion = _worldMatrixVersion2;
        frustum._lastProjMatrixVersion = _projectionMatrixVersion2;
      }
      return frustum;
    }
    /**
     * Given a set of camera projection coordinates (u,v in the range [-1, 1]), return a `Ray`
     * representing that line of sight in worldspace.
     * @param {number} u
     * @param {number} v
     * @return Ray
     */
    getRayAtProjectedCoords(u, v) {
      const ray = tempRaycaster.ray = new Ray();
      tempRaycaster.setFromCamera(tempVec2.set(u, v), this.threeObject);
      return ray;
    }
  }
  function defineProp(prop, affectsProjection) {
    Object.defineProperty(Camera3DFacade.prototype, prop, {
      set(val) {
        if (val !== this.threeObject[prop]) {
          this.threeObject[prop] = val;
          if (affectsProjection)
            this._projectionChanged = true;
        }
      },
      get() {
        return this.threeObject[prop];
      }
    });
  }
  projectionProps.forEach((prop) => {
    defineProp(prop, true);
  });
  if (otherProps) {
    otherProps.forEach((prop) => {
      defineProp(prop, false);
    });
  }
  return Camera3DFacade;
}
var PerspectiveCamera3DFacade = createCameraFacade(PerspectiveCamera, ["fov", "aspect", "near", "far"], ["focus", "filmGauge", "filmOffset"]);
var OrthographicCamera3DFacade = createCameraFacade(OrthographicCamera, ["left", "right", "top", "bottom", "near", "far"]);
var Group3DFacade = class extends Object3DFacade {
  initThreeObject() {
    let group = new Group();
    group.isRenderable = false;
    return group;
  }
};
var HtmlOverlay3DFacade = class extends Object3DFacade {
  constructor(parent) {
    let obj = new Object3D();
    obj.isRenderable = false;
    super(parent, obj);
    this.html = null;
    this.exact = false;
    this.notifyWorld("addHtmlOverlay", this);
  }
  destructor() {
    this.notifyWorld("removeHtmlOverlay", this);
    super.destructor();
  }
};
var Light3DFacade = class extends Object3DFacade {
  set color(c) {
    this.threeObject.color.set(c);
  }
  get color() {
    return this.threeObject.color.getHex();
  }
  // Shadow map configurable by deep object copy:
  get shadow() {
    return this.threeObject.shadow;
  }
  set shadow(val) {
    utils.assignDeep(this.threeObject.shadow, val);
  }
};
["intensity", "distance", "angle", "penumbra", "decay", "castShadow", "width", "height"].forEach((propName) => {
  Object.defineProperty(Light3DFacade.prototype, propName, {
    get() {
      return this.threeObject[propName];
    },
    set(value) {
      this.threeObject[propName] = value;
    }
  });
});
function createLightFacade(ThreeJsLightClass, HelperClass, customProtoDefs) {
  const Cls = class extends Light3DFacade {
    initThreeObject() {
      return new ThreeJsLightClass();
    }
    set showHelper(showHelper) {
      let helper = this._helper;
      if (!!showHelper !== !!helper) {
        if (showHelper) {
          this.threeObject.add(this._helper = new HelperClass(this.threeObject));
        } else if (helper) {
          helper.dispose();
          this.threeObject.remove(helper);
          this._helper = null;
        }
      }
    }
    afterUpdate() {
      super.afterUpdate();
      if (this._helper) {
        this._helper.update();
      }
    }
  };
  if (customProtoDefs) {
    Object.defineProperties(Cls.prototype, customProtoDefs);
  }
  return Cls;
}
var AmbientLight3DFacade = createLightFacade(AmbientLight);
var DirectionalLight3DFacade = createLightFacade(DirectionalLight, DirectionalLightHelper);
var SpotLight3DFacade = createLightFacade(SpotLight, SpotLightHelper);
var PointLight3DFacade = createLightFacade(PointLight, PointLightHelper);
var HemisphereLight3DFacade = createLightFacade(HemisphereLight, HemisphereLightHelper, {
  groundColor: {
    set(c) {
      this.threeObject.groundColor.set(c);
    },
    get() {
      return this.threeObject.groundColor.getHex();
    }
  }
});
var RectAreaLight3DFacade = createLightFacade(RectAreaLight);
var inverseFunction = `
#if __VERSION__ < 300
// matrix inversion utility for pre-ES3 - credit https://github.com/stackgl/glsl-inverse
mat3 inverse(mat3 m) {
  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];
  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];
  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];

  float b01 = a22 * a11 - a12 * a21;
  float b11 = -a22 * a10 + a12 * a20;
  float b21 = a21 * a10 - a11 * a20;

  float det = a00 * b01 + a01 * b11 + a02 * b21;

  return mat3(
    b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),
    b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),
    b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)
  ) / det;
}
#endif
`;
var vertexCommonDefs = `
attribute vec4 troika_modelMatrixRow0;
attribute vec4 troika_modelMatrixRow1;
attribute vec4 troika_modelMatrixRow2;
mat4 troika_modelMatrix;
mat4 troika_modelViewMatrix;
mat3 troika_normalMatrix;
`;
var modelMatrixVarAssignment = `
troika_modelMatrix = mat4(
  %0.x, %1.x, %2.x, 0.0,
  %0.y, %1.y, %2.y, 0.0,
  %0.z, %1.z, %2.z, 0.0,
  %0.w, %1.w, %2.w, 1.0
);
`.replace(/%/g, "troika_modelMatrixRow");
var modelViewMatrixVarAssignment = `
troika_modelViewMatrix = viewMatrix * troika_modelMatrix;
`;
var normalMatrixVarAssignment = `
troika_normalMatrix = transposeMat3(inverse(mat3(troika_modelViewMatrix)));
`;
var modelMatrixRefRE = /\bmodelMatrix\b/g;
var modelViewMatrixRefRE = /\bmodelViewMatrix\b/g;
var normalMatrixRefRE = /\bnormalMatrix\b/g;
var precededByUniformRE = /\buniform\s+(int|float|vec[234])\s+$/;
var attrRefReplacer = (name, index, str) => precededByUniformRE.test(str.substr(0, index)) ? name : `troika_${name}`;
var varyingRefReplacer = (name, index, str) => precededByUniformRE.test(str.substr(0, index)) ? name : `troika_vary_${name}`;
var CACHE = /* @__PURE__ */ new WeakMap();
function getInstancingDerivedMaterial(baseMaterial, instanceUniforms) {
  let instanceUniformsKey = instanceUniforms ? instanceUniforms.sort().join("|") : "";
  let derived = CACHE.get(baseMaterial);
  if (!derived || derived._instanceUniformsKey !== instanceUniformsKey) {
    derived = createDerivedMaterial(baseMaterial, {
      defines: {
        TROIKA_INSTANCED_UNIFORMS: instanceUniformsKey
      },
      customRewriter({ vertexShader, fragmentShader }) {
        return upgradeShaders(vertexShader, fragmentShader, instanceUniforms);
      }
    });
    derived._instanceUniformsKey = instanceUniformsKey;
    CACHE.set(baseMaterial, derived);
  }
  return derived;
}
function upgradeShaders(vertexShader, fragmentShader, instanceUniforms) {
  let usesModelMatrix = modelMatrixRefRE.test(vertexShader);
  let usesModelViewMatrix = modelViewMatrixRefRE.test(vertexShader);
  let usesNormalMatrix = normalMatrixRefRE.test(vertexShader);
  let vertexUniforms = getShaderUniformTypes(vertexShader);
  let fragmentUniforms = getShaderUniformTypes(fragmentShader);
  let vertexDeclarations = [vertexCommonDefs];
  let vertexAssignments = [];
  let fragmentDeclarations = [];
  if (usesModelMatrix || usesModelViewMatrix || usesNormalMatrix) {
    vertexShader = vertexShader.replace(modelMatrixRefRE, attrRefReplacer);
    vertexAssignments.push(modelMatrixVarAssignment);
  }
  if (usesModelViewMatrix || usesNormalMatrix) {
    vertexShader = vertexShader.replace(modelViewMatrixRefRE, attrRefReplacer);
    vertexAssignments.push(modelViewMatrixVarAssignment);
  }
  if (usesNormalMatrix) {
    vertexShader = vertexShader.replace(normalMatrixRefRE, attrRefReplacer);
    vertexAssignments.push(normalMatrixVarAssignment);
    if (!/\binverse\s*\(/.test(vertexShader)) {
      vertexDeclarations.push(inverseFunction);
    }
  }
  if (instanceUniforms) {
    instanceUniforms.forEach((name) => {
      let vertType = vertexUniforms[name];
      let fragType = fragmentUniforms[name];
      if (vertType || fragType) {
        let finder = new RegExp(`\\b${name}\\b`, "g");
        vertexDeclarations.push(`attribute ${vertType || fragType} troika_${name};`);
        if (vertType) {
          vertexShader = vertexShader.replace(finder, attrRefReplacer);
        }
        if (fragType) {
          fragmentShader = fragmentShader.replace(finder, varyingRefReplacer);
          let varyingDecl = `varying ${fragType} troika_vary_${name};`;
          vertexDeclarations.push(varyingDecl);
          fragmentDeclarations.push(varyingDecl);
          vertexAssignments.push(`troika_vary_${name} = troika_${name};`);
        }
      }
    });
  }
  vertexShader = `
${vertexDeclarations.join("\n")}
${vertexShader.replace(voidMainRegExp, `
  $&
  ${vertexAssignments.join("\n")}
`)}`;
  if (fragmentDeclarations.length) {
    fragmentShader = `
${fragmentDeclarations.join("\n")}
${fragmentShader}`;
  }
  return { vertexShader, fragmentShader };
}
var { assign: assign$1 } = utils;
var INSTANCE_BATCH_SIZE = 128;
var DYNAMIC_DRAW = 35048;
var InstancingManager = class extends Group3DFacade {
  constructor(parent) {
    super(parent);
    this._instanceables = /* @__PURE__ */ Object.create(null);
    this._batchGeometryPool = new BatchGeometryPool();
    this._needsRebatch = true;
    this.addEventListener("beforerender", this._setupBatchObjects.bind(this));
    this.addEventListener("afterrender", this._teardownBatchObjects.bind(this));
  }
  onNotifyWorld(source, message, data) {
    let handler = this._notifyWorldHandlers[message];
    if (handler) {
      handler.call(this, source, data);
    } else if (this.parent) {
      this.parent.onNotifyWorld(source, message, data);
    }
  }
  _setupBatchObjects(renderer, scene, camera) {
    let instanceables = this._instanceables;
    let batchObjectsByKey = this._batchObjectsByKey;
    let needsRebatch = this._needsRebatch;
    if (!needsRebatch) {
      for (let key in batchObjectsByKey) {
        let batchObj = batchObjectsByKey[key][0];
        if (this._getBatchKey(batchObj.$troikaBatchBaseObj) !== key) {
          needsRebatch = true;
          break;
        }
      }
    }
    if (needsRebatch) {
      batchObjectsByKey = this._batchObjectsByKey = /* @__PURE__ */ Object.create(null);
      let geometryPool = this._batchGeometryPool;
      for (let facadeId in instanceables) {
        let facade = instanceables[facadeId];
        let instanceObject = facade.threeObject;
        let protoObject = facade.instancedThreeObject;
        if (protoObject && instanceObject.visible) {
          let batchKey = this._getBatchKey(protoObject);
          let instanceUniforms = this._getInstanceUniformNames(protoObject);
          let batchObjects = batchObjectsByKey[batchKey] || (batchObjectsByKey[batchKey] = []);
          let batchObject = batchObjects[batchObjects.length - 1];
          let batchGeometry = batchObject && batchObject.geometry;
          if (!batchGeometry || getInstanceCount(batchGeometry) === INSTANCE_BATCH_SIZE) {
            batchObject = this._getBatchObject(protoObject);
            batchGeometry = batchObject.geometry;
            let attrs2 = batchGeometry._instanceAttrs.matrix;
            for (let row = 0; row < 3; row++) {
              attrs2[row].version++;
            }
            if (instanceUniforms) {
              attrs2 = batchGeometry._instanceAttrs.uniforms;
              for (let i = instanceUniforms.length; i--; ) {
                attrs2[instanceUniforms[i]].version++;
              }
            }
            batchObjects.push(batchObject);
          }
          let attrOffset = getInstanceCount(batchGeometry);
          setInstanceCount(batchGeometry, attrOffset + 1);
          let attrs = batchGeometry._instanceAttrs.matrix;
          let elements = instanceObject.matrixWorld.elements;
          attrs[0].setXYZW(attrOffset, elements[0], elements[4], elements[8], elements[12]);
          attrs[1].setXYZW(attrOffset, elements[1], elements[5], elements[9], elements[13]);
          attrs[2].setXYZW(attrOffset, elements[2], elements[6], elements[10], elements[14]);
          if (instanceUniforms) {
            attrs = batchGeometry._instanceAttrs.uniforms;
            for (let i = instanceUniforms.length; i--; ) {
              let uniform = instanceUniforms[i];
              let attr = attrs[uniform];
              let facadeUniforms = facade._instanceUniforms;
              let value = facadeUniforms && uniform in facadeUniforms ? facadeUniforms[uniform] : getDefaultUniformValue(protoObject.material, uniform);
              setAttributeValue(attr, attrOffset, value);
            }
          }
          facade._instancingBatchObject = batchObject;
          facade._instancingBatchAttrOffset = attrOffset;
        } else {
          facade._instancingBatchObject = facade._instancingBatchAttrOffset = null;
        }
      }
      geometryPool.disposeUnused();
    }
    let batchCount = 0;
    let batchGrpCount = 0;
    let instanceCount = 0;
    for (let id in batchObjectsByKey) {
      let batchObjects = batchObjectsByKey[id];
      scene.children.push.apply(scene.children, batchObjects);
      batchGrpCount++;
      for (let i = batchObjects.length; i--; ) {
        batchCount++;
        instanceCount += getInstanceCount(batchObjects[i].geometry);
      }
    }
    this.notifyWorld("statsUpdate", {
      "Instancing Batch Groups": batchGrpCount,
      "Instancing Batches": batchCount,
      "Instanced Objects": instanceCount
    });
    this._needsRebatch = false;
  }
  _onInstanceAdded(facade) {
    this._instanceables[facade.$facadeId] = facade;
    this._needsRebatch = true;
  }
  _onInstanceRemoved(facade) {
    delete this._instanceables[facade.$facadeId];
    this._needsRebatch = true;
  }
  _onInstanceChanged(facade) {
    this._needsRebatch = true;
  }
  _onInstanceMatrixChanged(facade) {
    if (!this._needsRebatch) {
      let protoObject = facade.instancedThreeObject;
      let batchObject = facade._instancingBatchObject;
      let attrOffset = facade._instancingBatchAttrOffset;
      if (protoObject && batchObject && this._getBatchKey(protoObject) === this._getBatchKey(batchObject)) {
        let attrs = batchObject.geometry._instanceAttrs.matrix;
        let elements = facade.threeObject.matrixWorld.elements;
        attrs[0].setXYZW(attrOffset, elements[0], elements[4], elements[8], elements[12]).version++;
        attrs[1].setXYZW(attrOffset, elements[1], elements[5], elements[9], elements[13]).version++;
        attrs[2].setXYZW(attrOffset, elements[2], elements[6], elements[10], elements[14]).version++;
      } else {
        facade._instancingBatchObject = facade._instancingBatchAttrOffset = null;
        this._needsRebatch = true;
      }
    }
  }
  _onInstanceUniformChanged(facade, uniformName) {
    if (!this._needsRebatch) {
      let protoObject = facade.instancedThreeObject;
      let batchObject = facade._instancingBatchObject;
      let attr;
      if (protoObject && batchObject && this._getBatchKey(protoObject) === this._getBatchKey(batchObject) && (attr = batchObject.geometry._instanceAttrs.uniforms[uniformName])) {
        setAttributeValue(attr, facade._instancingBatchAttrOffset, facade._instanceUniforms[uniformName]);
        attr.version++;
      } else {
        facade._instancingBatchObject = facade._instancingBatchAttrOffset = null;
        this._needsRebatch = true;
      }
    }
  }
  _getBatchKey(object) {
    let cache = this._batchKeysCache || (this._batchKeysCache = /* @__PURE__ */ Object.create(null));
    let key = cache && cache[object.id];
    if (!key) {
      let uniforms = this._getInstanceUniformNames(object);
      key = `${object.geometry.id}|${object.material.id}|${uniforms ? uniforms.sort().join(",") : ""}`;
      cache[object.id] = key;
    }
    return key;
  }
  _getInstanceUniformNames(object) {
    let namesSet = object._instanceUniformNames;
    if (!namesSet)
      return null;
    let cache = this._uniformNamesCache || (this._uniformNamesCache = /* @__PURE__ */ new Map());
    let namesArray = cache.get(namesSet);
    if (!namesArray) {
      namesArray = Array.from(namesSet);
      cache.set(namesSet, namesArray);
    }
    return namesArray;
  }
  _getInstanceUniformSizes(material, uniformNames) {
    let cache = this._uniformSizesCache || (this._uniformSizesCache = /* @__PURE__ */ new Map());
    let result = cache.get(material);
    if (!result) {
      result = /* @__PURE__ */ Object.create(null);
      if (uniformNames) {
        uniformNames.forEach((name) => {
          let size = getUniformItemSize(material, name);
          if (size > 0) {
            result[name] = size;
          } else {
            console.warn(`Could not determine item size for uniform ${name}`);
          }
        });
      }
      cache.set(material, result);
    }
    return result;
  }
  _getBatchObject(instancedObject) {
    let { geometry, material } = instancedObject;
    if (!geometry.isBufferGeometry) {
      throw new Error("Instanceable proto object must use a BufferGeometry");
    }
    let batchKey = this._getBatchKey(instancedObject);
    let uniformNames = this._getInstanceUniformNames(instancedObject);
    let uniformSizes = this._getInstanceUniformSizes(material, uniformNames);
    let batchGeometry = this._batchGeometryPool.borrow(batchKey, geometry, uniformSizes);
    setInstanceCount(batchGeometry, 0);
    let batchMaterial = getInstancingDerivedMaterial(material, uniformNames);
    let depthMaterial, distanceMaterial;
    let batchObject = Object.create(instancedObject, {
      // Redefine properties rather than setting them so we don't inadvertently trigger setters on
      // the base object:
      geometry: { value: batchGeometry },
      material: { value: batchMaterial },
      visible: { value: true },
      frustumCulled: { value: false },
      // Lazy getters for shadow materials:
      customDepthMaterial: {
        get() {
          if (!depthMaterial) {
            depthMaterial = batchMaterial.getDepthMaterial();
            depthMaterial.isShaderMaterial = true;
            depthMaterial.uniformsGroups = depthMaterial.uniformsGroups || [];
          }
          return depthMaterial;
        }
      },
      customDistanceMaterial: {
        get() {
          if (!distanceMaterial) {
            distanceMaterial = batchMaterial.getDistanceMaterial();
            distanceMaterial.isShaderMaterial = true;
            distanceMaterial.uniformsGroups = distanceMaterial.uniformsGroups || [];
            distanceMaterial.uniforms = assign$1({
              viewMatrix: { value: new Matrix4() }
            }, distanceMaterial.uniforms);
          }
          return distanceMaterial;
        }
      },
      // (*!) Hack for updating viewMatrix uniform on the distance material - see explanation above.
      modelViewMatrix: {
        value: function() {
          const modelViewMatrix = new Matrix4();
          modelViewMatrix.multiplyMatrices = function(viewMatrix, matrixWorld) {
            if (distanceMaterial) {
              distanceMaterial.uniforms.viewMatrix.value.copy(viewMatrix);
              distanceMaterial.uniformsNeedUpdate = true;
            }
            return Matrix4.prototype.multiplyMatrices.call(this, viewMatrix, matrixWorld);
          };
          return modelViewMatrix;
        }()
      }
    });
    batchObject.$troikaBatchBaseObj = instancedObject;
    batchObject.$troikaInstancingManager = this;
    return batchObject;
  }
  _teardownBatchObjects(renderer, scene, camera) {
    this._batchGeometryPool.releaseAll();
    this._batchKeysCache = null;
    this._uniformNamesCache = null;
    this._uniformSizesCache = null;
    scene.children = scene.children.filter((obj) => obj.$troikaInstancingManager !== this);
  }
  destructor() {
    let pool = this._batchGeometryPool;
    pool.releaseAll();
    pool.disposeUnused();
    super.destructor();
  }
};
var BatchGeometryPool = class {
  constructor() {
    this._poolsByKey = /* @__PURE__ */ Object.create(null);
  }
  borrow(key, baseGeometry, instanceUniformSizes) {
    let poolsByKey = this._poolsByKey;
    let pool = poolsByKey[key] || (poolsByKey[key] = { geometries: [], firstFree: 0 });
    let batchGeometry = pool.geometries[pool.firstFree++];
    if (!batchGeometry) {
      batchGeometry = new InstancedBufferGeometry();
      assign$1(batchGeometry, baseGeometry);
      batchGeometry.attributes = assign$1({}, baseGeometry.attributes);
      let instanceAttrs = batchGeometry._instanceAttrs = { matrix: [], uniforms: /* @__PURE__ */ Object.create(null) };
      for (let row = 0; row < 3; row++) {
        let attr = new InstancedBufferAttribute(new Float32Array(INSTANCE_BATCH_SIZE * 4), 4);
        if (attr.setUsage) {
          attr.setUsage(DYNAMIC_DRAW);
        } else {
          attr.dynamic = true;
        }
        batchGeometry.attributes[`troika_modelMatrixRow${row}`] = attr;
        instanceAttrs.matrix[row] = attr;
      }
      for (let name in instanceUniformSizes) {
        let itemSize = instanceUniformSizes[name];
        let attr = new InstancedBufferAttribute(new Float32Array(INSTANCE_BATCH_SIZE * itemSize), itemSize);
        if (attr.setUsage) {
          attr.setUsage(DYNAMIC_DRAW);
        } else {
          attr.dynamic = true;
        }
        batchGeometry.attributes[`troika_${name}`] = attr;
        instanceAttrs.uniforms[name] = attr;
      }
      pool.geometries.push(batchGeometry);
    }
    return batchGeometry;
  }
  releaseAll() {
    let pools = this._poolsByKey;
    if (pools) {
      for (let key in pools) {
        pools[key].firstFree = 0;
      }
    }
  }
  disposeUnused() {
    let pools = this._poolsByKey;
    if (pools) {
      for (let key in pools) {
        let { firstFree, geometries: geometries2 } = pools[key];
        for (let i = firstFree, len = geometries2.length; i < len; i++) {
          let attrs = geometries2[i].attributes;
          for (let attrName in attrs) {
            if (attrs.hasOwnProperty(attrName) && attrName.indexOf("troika_") !== 0) {
              delete attrs[attrName];
            }
          }
          try {
            geometries2[i].dispose();
          } catch (e) {
          }
          geometries2[i]._instanceAttrs = null;
        }
        geometries2.length = firstFree;
      }
    }
  }
};
var proto = InstancingManager.prototype;
proto._notifyWorldHandlers = {
  instanceableAdded: proto._onInstanceAdded,
  instanceableRemoved: proto._onInstanceRemoved,
  instanceableChanged: proto._onInstanceChanged,
  instanceableMatrixChanged: proto._onInstanceMatrixChanged,
  instanceableUniformChanged: proto._onInstanceUniformChanged
};
function setAttributeValue(attr, offset, value) {
  let size = attr.itemSize;
  if (size === 1) {
    attr.setX(offset, value);
  } else if (size === 2) {
    attr.setXY(offset, value.x, value.y);
  } else if (size === 3) {
    if (value.isColor) {
      attr.setXYZ(offset, value.r, value.g, value.b);
    } else {
      attr.setXYZ(offset, value.x, value.y, value.z);
    }
  } else if (size === 4) {
    attr.setXYZW(offset, value.x, value.y, value.z, value.w);
  }
}
function getDefaultUniformValue(material, name) {
  let uniforms = material.uniforms;
  if (uniforms && uniforms[name]) {
    return uniforms[name].value;
  }
  uniforms = getShadersForMaterial(material).uniforms;
  if (uniforms && uniforms[name]) {
    return uniforms[name].value;
  }
  return null;
}
function getUniformItemSize(material, name) {
  return getItemSizeForValue(getDefaultUniformValue(material, name));
}
function getItemSizeForValue(value) {
  return value == null ? 0 : typeof value === "number" ? 1 : value.isVector2 ? 2 : value.isVector3 || value.isColor ? 3 : value.isVector4 ? 4 : Array.isArray(value) ? value.length : 0;
}
function getInstanceCount(geom) {
  return geom[geom.hasOwnProperty("instanceCount") ? "instanceCount" : "maxInstancedCount"];
}
function setInstanceCount(geom, count) {
  geom[geom.hasOwnProperty("instanceCount") ? "instanceCount" : "maxInstancedCount"] = count;
}
var LIGHT_TYPES = {
  ambient: AmbientLight3DFacade,
  directional: DirectionalLight3DFacade,
  spot: SpotLight3DFacade,
  point: PointLight3DFacade,
  hemisphere: HemisphereLight3DFacade
};
var RAY_INTERSECTION = [{ distance: Infinity }];
var INFINITE_SPHERE = new Sphere(void 0, Infinity);
var tempArr = [null];
var Scene3DFacade = class extends Object3DFacade {
  initThreeObject() {
    const scene = new Scene();
    if ("matrixWorldAutoUpdate" in scene) {
      scene.matrixWorldAutoUpdate = false;
    } else {
      scene.autoUpdate = false;
    }
    return scene;
  }
  afterUpdate() {
    let scene = this.threeObject;
    scene.background = this.background || null;
    scene.environment = this.environment || null;
    super.afterUpdate();
  }
  describeChildren() {
    let children = {
      key: "instancingMgr",
      facade: InstancingManager,
      children: this.objects
    };
    let { lights } = this;
    if (lights) {
      children = [children];
      if (!Array.isArray(lights)) {
        tempArr[0] = lights;
        lights = tempArr;
      }
      lights.forEach((def, i) => {
        let facade = def.facade || LIGHT_TYPES[def.type];
        if (typeof facade === "function") {
          let realDef = utils.assign({}, def);
          delete realDef.type;
          realDef.key = def.key || `light${i}`;
          realDef.facade = facade;
          children.push(realDef);
        }
      });
    }
    return children;
  }
  set fog(def) {
    let fogObj = this._fogObj;
    if (def) {
      let isExp2 = "density" in def;
      let fogClass = isExp2 ? FogExp2 : Fog;
      if (!fogObj || !(fogObj instanceof fogClass)) {
        fogObj = this._fogObj = new fogClass();
      }
      fogObj.color.set(def.color);
      if (isExp2) {
        fogObj.density = def.density;
      } else {
        fogObj.near = def.near;
        fogObj.far = def.far;
      }
    } else {
      fogObj = this._fogObj = null;
    }
    this.threeObject.fog = fogObj;
  }
  getBoundingSphere() {
    return INFINITE_SPHERE;
  }
  raycast(raycaster2) {
    return RAY_INTERSECTION;
  }
};
var { assign: assign$2, forOwn: forOwn$1 } = utils;
var tempSphere = new Sphere();
var SQRT3 = Math.sqrt(3);
var PRECISION = 1e-8;
var BoundingSphereOctree = class {
  constructor() {
    this.root = null;
    this.keysToLeaves = /* @__PURE__ */ Object.create(null);
  }
  putSpheres(spheres) {
    forOwn$1(spheres, (sphere, key) => {
      this.putSphere(key, sphere);
    });
  }
  putSphere(key, sphere) {
    const { center, radius } = sphere;
    if (!sphere || isNaN(radius) || isNaN(center.x)) {
      console.warn("Invalid sphere", sphere);
      return;
    }
    center._roundedX = Math.round(center.x / PRECISION) * PRECISION;
    center._roundedY = Math.round(center.y / PRECISION) * PRECISION;
    center._roundedZ = Math.round(center.z / PRECISION) * PRECISION;
    this._putSphere(key, sphere);
  }
  _putSphere(key, sphere) {
    const { center } = sphere;
    const { root } = this;
    let { _roundedX, _roundedY, _roundedZ } = center;
    if (key in this.keysToLeaves) {
      return this._updateSphere(key, sphere);
    }
    if (!root) {
      const newRoot = new Octant();
      newRoot.isLeaf = true;
      newRoot.addSphereData(key, sphere);
      this.root = newRoot;
      this.keysToLeaves[key] = newRoot;
    } else if (root.isLeaf) {
      const oldRoot = this.root;
      const { dataX, dataY, dataZ } = root;
      if (dataX === _roundedX && dataY === _roundedY && dataZ === _roundedZ) {
        this._insertIntoOctant(key, sphere, root);
      } else {
        const newRoot = new Octant();
        const cx = newRoot.cx = Math.round((dataX + _roundedX) / 2);
        const cy = newRoot.cy = Math.round((dataY + _roundedY) / 2);
        const cz = newRoot.cz = Math.round((dataZ + _roundedZ) / 2);
        newRoot.cr = Math.ceil(Math.max(Math.abs(cx - dataX), Math.abs(cy - dataY), Math.abs(cz - dataZ)) + 1e-5);
        this.root = newRoot;
        oldRoot.forEachLeafSphere((_sphere, _key) => this._insertIntoOctant(_key, _sphere, newRoot));
        this._insertIntoOctant(key, sphere, newRoot);
      }
    } else {
      this._expandToCoverPoint(_roundedX, _roundedY, _roundedZ);
      this._insertIntoOctant(key, sphere, this.root);
    }
  }
  _expandToCoverPoint(x, y, z) {
    while (!this.root.containsPoint(x, y, z)) {
      const oldRoot = this.root;
      const { cx, cy, cz, cr } = oldRoot;
      const newRoot = new Octant();
      newRoot.maxRadius = oldRoot.maxRadius;
      newRoot.sphereCount = oldRoot.sphereCount;
      newRoot.leafCount = oldRoot.leafCount;
      newRoot.cx = cx + cr * (x < cx ? -1 : 1);
      newRoot.cy = cy + cr * (y < cy ? -1 : 1);
      newRoot.cz = cz + cr * (z < cz ? -1 : 1);
      newRoot.cr = cr * 2;
      const octantIdx = newRoot.getSubOctantIndexForPoint(cx, cy, cz);
      oldRoot.parent = newRoot;
      oldRoot.index = octantIdx;
      newRoot[octantIdx] = oldRoot;
      this.root = newRoot;
    }
  }
  _insertIntoOctant(key, sphere, octant) {
    const { center, radius } = sphere;
    const { _roundedX, _roundedY, _roundedZ } = center;
    if (octant.isLeaf) {
      const { dataX, dataY, dataZ } = octant;
      if (_roundedX === dataX && _roundedY === dataY && _roundedZ === dataZ) {
        octant.addSphereData(key, sphere);
        for (let oct = octant.parent; oct; oct = oct.parent) {
          if (radius > oct.maxRadius) {
            oct.maxRadius = radius;
          }
        }
        this.keysToLeaves[key] = octant;
      } else {
        const newBranch = _createBranchFromLeaf(octant);
        octant.parent[octant.index] = newBranch;
        newBranch.addOctantForPoint(octant, dataX, dataY, dataZ);
        this._insertIntoOctant(key, sphere, newBranch);
      }
    } else {
      octant.sphereCount++;
      const subOctantIndex = octant.getSubOctantIndexForPoint(_roundedX, _roundedY, _roundedZ);
      let subOctant = octant[subOctantIndex];
      if (!subOctant) {
        const newLeaf = new Octant();
        newLeaf.isLeaf = true;
        octant.addOctantForPoint(newLeaf, _roundedX, _roundedY, _roundedZ);
        newLeaf.addSphereData(key, sphere);
        for (let oct = newLeaf.parent; oct; oct = oct.parent) {
          if (radius > oct.maxRadius) {
            oct.maxRadius = radius;
          }
          oct.leafCount++;
        }
        this.keysToLeaves[key] = newLeaf;
      } else {
        return this._insertIntoOctant(key, sphere, subOctant);
      }
    }
  }
  removeSphere(key) {
    let leafOctant = this.keysToLeaves[key];
    if (!leafOctant) {
      return;
    }
    let oct = leafOctant.parent;
    while (oct) {
      oct.sphereCount--;
      oct = oct.parent;
    }
    if (leafOctant.sphereCount > 1) {
      leafOctant.removeSphereData(key);
      leafOctant.updateMaxRadii();
    } else {
      oct = leafOctant;
      let lowestRemainingOctant;
      do {
        const parent = oct.parent;
        lowestRemainingOctant = parent;
        if (parent) {
          parent[oct.index] = null;
        }
        oct = oct.parent;
      } while (oct && oct.sphereCount === 0);
      if (!lowestRemainingOctant) {
        this.root = null;
        return;
      }
      let highestSingleLeafBranch = null;
      oct = lowestRemainingOctant;
      while (oct) {
        oct.leafCount--;
        if (oct.leafCount === 1) {
          highestSingleLeafBranch = oct;
        }
        oct = oct.parent;
      }
      if (highestSingleLeafBranch) {
        let leaf = this._findSingleLeaf(highestSingleLeafBranch);
        const parent = highestSingleLeafBranch.parent;
        if (parent) {
          parent.addOctantForPoint(leaf, leaf.cx, leaf.cy, leaf.cz);
          parent.updateMaxRadii();
        } else {
          this.root = leaf;
        }
      } else {
        lowestRemainingOctant.updateMaxRadii();
      }
    }
    delete this.keysToLeaves[key];
  }
  _updateSphere(key, sphere) {
    let leaf = this.keysToLeaves[key];
    const center = sphere.center;
    const { _roundedX, _roundedY, _roundedZ } = center;
    if (leaf.containsPoint(_roundedX, _roundedY, _roundedZ)) {
      const isMulti = leaf.sphereCount > 1;
      const hasMoved = _roundedX !== leaf.dataX || _roundedY !== leaf.dataY || _roundedZ !== leaf.dataZ;
      if (isMulti && hasMoved) {
        leaf.removeSphereData(key);
        leaf.updateMaxRadii();
        this._insertIntoOctant(key, sphere, leaf);
      } else {
        if (hasMoved) {
          leaf.dataX = _roundedX;
          leaf.dataY = _roundedY;
          leaf.dataZ = _roundedZ;
        }
        if (sphere.radius !== leaf.maxRadius) {
          leaf.updateMaxRadii();
        }
      }
    } else {
      this.removeSphere(key);
      this._putSphere(key, sphere);
    }
  }
  // Optimized utility for finding single descendant leaf without creating a function
  _findSingleLeaf(octant) {
    let leaf;
    function visit(oct) {
      if (oct.isLeaf)
        leaf = oct;
    }
    function find(oct) {
      leaf = null;
      this.walkBranch(oct, visit);
      return leaf;
    }
    this._findSingleLeaf = find;
    return find.call(this, octant);
  }
  /**
   * Perform a depth-first walk of the tree structure, invoking a `callback` function for
   * each node. The `callback` will be passed the current tree node object, and will be invoked
   * for parent branch nodes first before their child nodes.
   *
   * If the function returns `false` for a branch node, none of that branch's children will be
   * visited; this is how you can efficiently query the tree by filtering out the majority of branches.
   *
   * @param {Function} callback
   */
  walkTree(callback) {
    if (this.root) {
      this.walkBranch(this.root, callback);
    }
  }
  walkBranch(root, callback) {
    if (callback(root) !== false && !root.isLeaf) {
      for (let i = 0; i < 8; i++) {
        if (root[i] !== null) {
          this.walkBranch(root[i], callback);
        }
      }
    }
  }
  /**
   * Given a {@link Ray}, search the octree for any spheres that intersect that ray and invoke
   * the given `callback` function, passing it the sphere and its key as arguments.
   * TODO need to handle near/far
   *
   * @param {Ray} ray
   * @param {Function} callback
   * @param {Object} scope
   */
  forEachSphereOnRay(ray, callback, scope) {
    return this._forEachMatchingSphere(ray.intersectsSphere.bind(ray), callback, scope);
  }
  forEachIntersectingSphere(sphere, callback, scope) {
    return this._forEachMatchingSphere(sphere.intersectsSphere.bind(sphere), callback, scope);
  }
  _forEachMatchingSphere(testFn, callback, scope) {
    function visitSphere(sphere, key) {
      if (testFn(sphere)) {
        callback.call(scope, sphere, key);
      }
    }
    this.walkTree((octant) => {
      if (octant.isLeaf) {
        octant.forEachLeafSphere(visitSphere);
      } else {
        tempSphere.center.set(octant.cx, octant.cy, octant.cz);
        tempSphere.radius = octant.cr * SQRT3 + octant.maxRadius;
        if (!testFn(tempSphere)) {
          return false;
        }
      }
      return true;
    });
  }
};
var Octant = class {
  containsPoint(x, y, z) {
    const { cx, cy, cz, cr } = this;
    return x >= cx - cr && x < cx + cr && y >= cy - cr && y < cy + cr && z >= cz - cr && z < cz + cr;
  }
  getSubOctantIndexForPoint(x, y, z) {
    return (z < this.cz ? 0 : 4) + (y < this.cy ? 0 : 2) + (x < this.cx ? 0 : 1);
  }
  addOctantForPoint(subOctant, x, y, z) {
    const index = this.getSubOctantIndexForPoint(x, y, z);
    const subCR = this.cr / 2;
    subOctant.parent = this;
    subOctant.index = index;
    subOctant.cx = this.cx + subCR * (x < this.cx ? -1 : 1);
    subOctant.cy = this.cy + subCR * (y < this.cy ? -1 : 1);
    subOctant.cz = this.cz + subCR * (z < this.cz ? -1 : 1);
    subOctant.cr = subCR;
    this[index] = subOctant;
    return subOctant;
  }
  findMaxSphereRadius() {
    let maxRadius = 0;
    if (this.isLeaf) {
      const data = this.data;
      if (this.sphereCount > 1) {
        for (let key in data) {
          const r = data[key].radius;
          if (r > maxRadius)
            maxRadius = r;
        }
      } else {
        maxRadius = data.radius;
      }
    } else {
      for (let i = 0; i < 8; i++) {
        if (this[i] !== null && this[i].maxRadius > maxRadius) {
          maxRadius = this[i].maxRadius;
        }
      }
    }
    return maxRadius;
  }
  updateMaxRadii() {
    let maxRadius = this.findMaxSphereRadius();
    if (maxRadius > this.maxRadius) {
      let octant = this;
      while (octant) {
        if (maxRadius > octant.maxRadius) {
          octant.maxRadius = maxRadius;
        }
        octant = octant.parent;
      }
    } else if (maxRadius < this.maxRadius) {
      this.maxRadius = maxRadius;
      if (this.parent) {
        this.parent.updateMaxRadii();
      }
    }
  }
  addSphereData(key, sphere) {
    const count = this.sphereCount++;
    if (count === 0) {
      this.leafCount = 1;
      this.data = sphere;
      this.dataKey = key;
      const { _roundedX, _roundedY, _roundedZ } = sphere.center;
      this.dataX = _roundedX;
      this.dataY = _roundedY;
      this.dataZ = _roundedZ;
    } else if (count === 1) {
      const oldSphere = this.data;
      const newData = this.data = /* @__PURE__ */ Object.create(null);
      newData[this.dataKey] = oldSphere;
      newData[key] = sphere;
      this.dataKey = null;
    } else if (count > 1) {
      this.data[key] = sphere;
    }
    if (sphere.radius > this.maxRadius) {
      this.maxRadius = sphere.radius;
    }
  }
  removeSphereData(key) {
    const data = this.data;
    if (data) {
      const count = this.sphereCount--;
      if (count > 2) {
        delete data[key];
      } else if (count === 2) {
        for (let _key in data) {
          if (_key !== key) {
            this.dataKey = _key;
            this.data = data[_key];
            break;
          }
        }
      } else {
        this.data = null;
      }
    }
  }
  forEachLeafSphere(fn, scope) {
    const data = this.data;
    if (data) {
      if (this.sphereCount > 1) {
        for (let key in data) {
          fn.call(scope, data[key], key);
        }
      } else {
        fn.call(scope, data, this.dataKey);
      }
    }
  }
};
assign$2(Octant.prototype, {
  // Relationships
  parent: null,
  index: -1,
  // Cube bounds
  cx: 0,
  //center x
  cy: 0,
  //center y
  cz: 0,
  //center z
  cr: 0,
  //cubic radius (dist from center to edge)
  // Sub-octants
  0: null,
  1: null,
  2: null,
  3: null,
  4: null,
  5: null,
  6: null,
  7: null,
  // Leaf data
  // For a single-item leaf (probably the vast majority) `data` will be the Sphere object and `dataKey`
  // will be its key. For a multi-item leaf, `data` will be an object of key->Sphere mappings and
  // `dataKey` will be null. I'm not a huge fan of the asymmetry but this lets us avoid an extra
  // sub-object for the majority of leaves while keeping the Octant's shape predictable for the JS engine.
  isLeaf: false,
  data: null,
  dataKey: null,
  // The first sphere added to the leaf will have its center position copied for easier access and
  // to avoid issues with the Sphere objects being mutated elsewhere.
  dataX: 0,
  dataY: 0,
  dataZ: 0,
  // Stats
  sphereCount: 0,
  leafCount: 0,
  maxRadius: 0
});
var _createBranchFromLeaf = /* @__PURE__ */ function() {
  const copyProps = ["parent", "index", "cx", "cy", "cz", "cr", "sphereCount", "leafCount", "maxRadius"];
  return function(leaf) {
    const branch = new Octant();
    for (let i = copyProps.length; i--; ) {
      branch[copyProps[i]] = leaf[copyProps[i]];
    }
    return branch;
  };
}();
var { assign: assign$3 } = utils;
var tmpVec2 = new Vector2();
var tmpVec3 = new Vector3();
var raycaster = new Raycaster();
var World3DFacade = class extends WorldBaseFacade {
  constructor(canvas) {
    super(canvas);
    this._object3DFacadesById = /* @__PURE__ */ Object.create(null);
    this._onBgClick = this._onBgClick.bind(this);
  }
  afterUpdate() {
    let { width, height, antialias, backgroundColor, contextAttributes, _element: canvas } = this;
    let renderer = this._threeRenderer;
    const RendererClass = this.rendererClass || WebGLRenderer;
    if (!renderer || !(renderer instanceof RendererClass)) {
      if (renderer) {
        renderer.dispose();
      }
      contextAttributes = assign$3({
        alpha: true,
        antialias
      }, contextAttributes);
      const context = canvas.getContext("webgl2", contextAttributes) || void 0;
      if (!context) {
        console.info("webgl2 init failed, trying webgl");
      }
      renderer = this._threeRenderer = new RendererClass(assign$3({
        canvas,
        context
      }, contextAttributes));
    }
    const shadows = this.shadows;
    renderer.shadowMap.enabled = !!shadows;
    if (shadows && typeof shadows === "object") {
      assign$3(renderer.shadowMap, shadows);
    }
    if (backgroundColor !== this._bgColor) {
      renderer.setClearColor(new Color(backgroundColor || 0), backgroundColor != null ? 1 : 0);
      this._bgColor = backgroundColor;
    }
    renderer.outputEncoding = this.outputEncoding || LinearSRGBColorSpace;
    renderer.toneMapping = this.toneMapping || NoToneMapping;
    this._updateDrawingBufferSize(width, height, this.pixelRatio || window.devicePixelRatio || 1);
    super.afterUpdate();
  }
  describeChildren() {
    return [
      this._getCameraDef(),
      this._getSceneDef()
    ];
  }
  /**
   * Build a normalized definition for the camera facade
   * @protected
   */
  _getCameraDef() {
    const { camera } = this;
    return assign$3({
      key: "camera",
      facade: PerspectiveCamera3DFacade,
      aspect: this.width / this.height
    }, camera);
  }
  /**
   * Build a normalized definition for the scene facade
   * @protected
   */
  _getSceneDef() {
    return {
      key: "scene",
      facade: Scene3DFacade,
      lights: this.lights,
      objects: this.objects,
      fog: this.fog,
      background: this.background,
      environment: this.environment,
      onClick: this.onBackgroundClick ? this._onBgClick : null
    };
  }
  /**
   * Update the renderer's drawing buffer size
   * @protected
   */
  _updateDrawingBufferSize(width, height, pixelRatio) {
    const renderer = this._threeRenderer;
    renderer.getSize(tmpVec2);
    if (tmpVec2.width !== width || tmpVec2.height !== height || renderer.getPixelRatio() !== pixelRatio) {
      renderer.setDrawingBufferSize(width, height, pixelRatio);
    }
  }
  doRender() {
    let sceneFacade = this.getChildByKey("scene");
    let scene = sceneFacade.threeObject;
    let camera = this.getChildByKey("camera").threeObject;
    let renderer = this._threeRenderer;
    let registry = this.eventRegistry;
    function invokeHandler(handler, facadeId) {
      handler.call(this._object3DFacadesById[facadeId], renderer, scene, camera);
    }
    registry.forEachListenerOfType("beforerender", invokeHandler, this);
    renderer.render(scene, camera);
    registry.forEachListenerOfType("afterrender", invokeHandler, this);
    let onStatsUpdate = this.onStatsUpdate;
    if (onStatsUpdate) {
      const { memory, render } = renderer.info;
      const stats = {
        "WebGL Draw Calls": render.calls,
        "WebGL Geometries": memory.geometries,
        "WebGL Textures": memory.textures,
        "WebGL Triangles": render.triangles
      };
      if (render.points) {
        stats["WebGL Points"] = render.points;
      }
      if (render.lines) {
        stats["WebGL Lines"] = render.lines;
      }
      onStatsUpdate(stats);
    }
  }
  /**
   * Implementation of abstract
   */
  getFacadeUserSpaceXYZ(facade) {
    let matrixEls = facade.threeObject.matrixWorld.elements;
    return this.projectWorldPosition(matrixEls[12], matrixEls[13], matrixEls[14]);
  }
  projectWorldPosition(x, y, z) {
    tmpVec3.set(x, y, z);
    let camera = this.getChildByKey("camera");
    camera.updateMatrices();
    camera = camera.threeObject;
    tmpVec3.applyMatrix4(camera.matrixWorldInverse);
    let signedDistance = tmpVec3.length() * (tmpVec3.z > 0 ? -1 : 1);
    tmpVec3.applyMatrix4(camera.projectionMatrix);
    let screenX = (tmpVec3.x + 1) * this.width / 2;
    let screenY = (1 - tmpVec3.y) * this.height / 2;
    return new Vector3(screenX, screenY, signedDistance);
  }
  /**
   * @override
   * In 3D worlds, we will normalize all pointer events so they always carry a `ray` property;
   * handlers for these events should then only rely on that, which is guaranteed to be present,
   * unlike `clientX/Y` etc. which are only present for pointer events originating from a screen.
   */
  _normalizePointerEvent(e) {
    if (!e.ray) {
      let posInfo = e;
      if (e.touches) {
        let touches = /^touch(end|cancel)$/.test(e.type) ? e.changedTouches : e.touches;
        if (touches.length === 1) {
          posInfo = touches[0];
        }
      }
      const canvasRect = e.target.getBoundingClientRect();
      let width = canvasRect.width || this.width;
      let height = canvasRect.height || this.height;
      let u = ((posInfo.clientX || 0) - (canvasRect.left || 0)) / width * 2 - 1;
      let v = ((posInfo.clientY || 0) - (canvasRect.top || 0)) / height * -2 + 1;
      let camera = this.getChildByKey("camera");
      camera.updateMatrices();
      e.ray = camera.getRayAtProjectedCoords(u, v);
    }
    super._normalizePointerEvent(e);
  }
  /**
   * @override Implementation of abstract
   * @return {Array<{facade, distance, ?distanceBias, ...}>|null}
   */
  getFacadesAtEvent(e, filterFn) {
    return e.ray ? this.getFacadesOnRay(e.ray, filterFn) : null;
  }
  getFacadesOnRay(ray, filterFn) {
    const octree = this._updateOctree();
    let allHits = null;
    if (octree) {
      raycaster.ray = ray;
      octree.forEachSphereOnRay(ray, (sphere, facadeId) => {
        const facadesById = this._object3DFacadesById;
        const facade = facadesById && facadesById[facadeId];
        const hits = facade && (!filterFn || filterFn(facade)) && facade.raycast && facade.raycast(raycaster);
        if (hits && hits[0]) {
          hits[0].facade = facade;
          (allHits || (allHits = [])).push(hits[0]);
        }
      });
    }
    return allHits;
  }
  _updateOctree() {
    let octree = this._boundingSphereOctree;
    const changes = this._octreeChangeset;
    if (changes) {
      if (!octree) {
        octree = this._boundingSphereOctree = new BoundingSphereOctree();
      }
      const { remove, put } = changes;
      if (remove) {
        for (let facadeId in remove) {
          octree.removeSphere(facadeId);
        }
      }
      if (put) {
        for (let facadeId in put) {
          const facade = this._object3DFacadesById[facadeId];
          if (facade && !facade.isDestroying && !(remove && remove[facadeId])) {
            const sphere = facade.getBoundingSphere && facade.getBoundingSphere();
            if (sphere) {
              octree.putSphere(facadeId, sphere);
            } else {
              octree.removeSphere(facadeId);
            }
          }
        }
      }
      this._octreeChangeset = null;
    }
    return octree;
  }
  _queueForOctreeChange(changeType, facade) {
    const changes = this._octreeChangeset || (this._octreeChangeset = {});
    const map = changes[changeType] || (changes[changeType] = /* @__PURE__ */ Object.create(null));
    map[facade.$facadeId] = facade;
  }
  _onBgClick(e) {
    if (e.target === e.currentTarget) {
      this.onBackgroundClick(e);
    }
  }
  destructor() {
    super.destructor();
    this._threeRenderer.dispose();
  }
};
World3DFacade.prototype._notifyWorldHandlers = assign$3(
  Object.create(WorldBaseFacade.prototype._notifyWorldHandlers),
  {
    getCameraPosition(source, outputVec3) {
      outputVec3.setFromMatrixPosition(this.getChildByKey("camera").threeObject.matrixWorld);
    },
    getCameraFacade(source, data) {
      data.callback(this.getChildByKey("camera"));
    },
    getSceneFacade(source, data) {
      data.callback(this.getChildByKey("scene"));
    },
    projectWorldPosition(source, data) {
      let pos = data.worldPosition;
      data.callback(this.projectWorldPosition(pos.x, pos.y, pos.z));
    },
    object3DAdded(source) {
      this._object3DFacadesById[source.$facadeId] = source;
      this._queueForOctreeChange("put", source);
    },
    object3DBoundsChanged(source) {
      this._queueForOctreeChange("put", source);
    },
    object3DRemoved(source) {
      delete this._object3DFacadesById[source.$facadeId];
      this._queueForOctreeChange("remove", source);
    },
    rayPointerMotion(source, ray) {
      const e = new MouseEvent("mousemove");
      e.isRayEvent = true;
      e.ray = ray;
      e.eventSource = source;
      this._onPointerMotionEvent(e);
    },
    rayPointerAction(source, eventParams) {
      const e = new (eventParams.type === "wheel" ? WheelEvent : MouseEvent)(eventParams.type, eventParams);
      e.isRayEvent = true;
      e.ray = eventParams.ray;
      e.eventSource = source;
      this._onPointerActionEvent(e);
    }
  }
);
var refireableEvents = [
  "onMouseOver",
  "onMouseOut",
  "onMouseMove",
  "onMouseDown",
  "onMouseUp",
  "onClick",
  "onDoubleClick"
];
function makeWorldTextureProvider(WrappedFacadeClass) {
  return class WorldTextureProvider extends WrappedFacadeClass {
    constructor(parent) {
      super(parent);
      this.worldTexture = new CanvasTexture();
      const refire = this._refireAsInnerEvent.bind(this);
      refireableEvents.forEach((prop) => {
        let userFn;
        function wrapperFn(e) {
          refire(e);
          if (userFn)
            userFn.call(this, e);
        }
        this[prop] = wrapperFn;
        Object.defineProperty(this, prop, {
          set(val) {
            userFn = val;
          },
          get() {
            return wrapperFn;
          }
        });
      });
    }
    afterUpdate() {
      let innerWorld = this._worldFacade;
      let newWorldConfig = this.textureWorld;
      if (!innerWorld || !newWorldConfig || !(innerWorld instanceof newWorldConfig.facade)) {
        if (innerWorld) {
          innerWorld.onAfterRender = null;
          innerWorld.destructor();
        }
        if (newWorldConfig) {
          this.worldTexture.dispose();
          const canvas = document.createElement("canvas");
          canvas.width = newWorldConfig.width;
          canvas.height = newWorldConfig.height;
          this.worldTexture = new CanvasTexture(canvas);
          innerWorld = this._worldFacade = new newWorldConfig.facade(canvas);
          innerWorld.onAfterRender = () => {
            this.worldTexture.needsUpdate = true;
            this.requestRender();
          };
        }
      }
      if (innerWorld) {
        innerWorld.renderingScheduler = this._getOuterWorld().renderingScheduler;
        utils.assign(innerWorld, newWorldConfig, { pixelRatio: 1 });
        innerWorld.afterUpdate();
      }
      super.afterUpdate();
    }
    _refireAsInnerEvent(e) {
      const world = this._worldFacade;
      if (world) {
        const uv = e.intersection && e.intersection.uv;
        const x = uv ? Math.round(uv.x * world.width) : -1;
        const y = uv ? Math.round((1 - uv.y) * world.height) : -1;
        const nativeEvent = e.nativeEvent || e;
        const innerEvent = document.createEvent("MouseEvents");
        innerEvent.initMouseEvent(
          nativeEvent.type,
          true,
          true,
          window,
          nativeEvent.detail,
          x,
          y,
          x,
          y,
          nativeEvent.ctrlKey,
          nativeEvent.altKey,
          nativeEvent.shiftKey,
          nativeEvent.metaKey,
          nativeEvent.button,
          null
        );
        this.worldTexture.image.dispatchEvent(innerEvent);
      }
    }
    _getOuterWorld() {
      let outerWorld = this;
      while (outerWorld && !outerWorld.isWorld) {
        outerWorld = outerWorld.parent;
      }
      return outerWorld;
    }
    destructor() {
      const world = this._worldFacade;
      if (world) {
        world.onAfterRender = null;
        world.destructor();
      }
      this.worldTexture.dispose();
      super.destructor();
    }
  };
}
var Instanceable3DFacade = class extends Object3DFacade {
  constructor(parent) {
    let obj = new Object3D();
    obj.isRenderable = false;
    obj.$troikaVisible = obj.visible;
    Object.defineProperty(obj, "visible", visibilityPropDef);
    super(parent, obj);
    this.notifyWorld("instanceableAdded");
  }
  /**
   * @property {Object3D} instancedThreeObject
   * Sets the Mesh instance to use for batching this instance with others that
   * reference the same Mesh.
   */
  /**
   * Sets this instance's value for a shader uniform.
   * @param {String} name
   * @param {Number|Vector2|Vector3|Vector4|Color} value
   */
  setInstanceUniform(name, value) {
    let values = this._instanceUniforms || (this._instanceUniforms = /* @__PURE__ */ Object.create(null));
    if (values[name] !== value) {
      const obj = this.instancedThreeObject;
      if (obj && !(name in values)) {
        const names = obj._instanceUniformNames || (obj._instanceUniformNames = /* @__PURE__ */ new Set());
        names.add(name);
      }
      values[name] = value;
      this.notifyWorld("instanceableUniformChanged", name);
    }
  }
  afterUpdate() {
    const newObj = this.instancedThreeObject;
    const oldObj = this._instancedObj;
    if (newObj !== oldObj) {
      if (newObj && this._instanceUniforms) {
        const names = newObj._instanceUniformNames || (newObj._instanceUniformNames = /* @__PURE__ */ new Set());
        for (let name in this._instanceUniforms) {
          names.add(name);
        }
      }
      this._instancedObj = newObj;
      this.notifyWorld("instanceableChanged");
      this._boundsChanged = true;
    }
    super.afterUpdate();
  }
  updateMatrices() {
    const prevMatrixVersion = this._worldMatrixVersion;
    super.updateMatrices();
    if (this._worldMatrixVersion !== prevMatrixVersion && this.threeObject.$troikaVisible) {
      this.notifyWorld("instanceableMatrixChanged");
    }
  }
  destructor() {
    this.notifyWorld("instanceableRemoved");
    super.destructor();
  }
  // Custom bounding sphere calc
  getGeometry() {
    let instancedObj = this.instancedThreeObject;
    return instancedObj && instancedObj.geometry;
  }
  // Custom raycasting based on current geometry and transform
  raycast(raycaster2) {
    let { instancedThreeObject, threeObject } = this;
    if (instancedThreeObject && threeObject) {
      let origMatrix = instancedThreeObject.matrixWorld;
      instancedThreeObject.matrixWorld = threeObject.matrixWorld;
      let result = this._raycastObject(instancedThreeObject, raycaster2);
      instancedThreeObject.matrixWorld = origMatrix;
      return result;
    }
    return null;
  }
};
var visibilityPropDef = {
  set(visible) {
    if (visible !== this.$troikaVisible) {
      this.$troikaVisible = visible;
      this.$facade.notifyWorld("instanceableChanged");
    }
  },
  get() {
    return this.$troikaVisible;
  }
};
utils.assign(Instanceable3DFacade.prototype, {
  _lastInstancedMatrixVersion: -1,
  _instancedThreeObject: null
});
var dummyGeometry = new BufferGeometry();
var dummyMaterial = new MeshBasicMaterial();
var MESH_MATERIALS = {
  "basic": MeshBasicMaterial,
  "depth": MeshDepthMaterial,
  "distance": MeshDistanceMaterial,
  "lambert": MeshLambertMaterial,
  "matcap": MeshMatcapMaterial,
  "normal": MeshNormalMaterial,
  "phong": MeshPhongMaterial,
  "physical": MeshPhysicalMaterial,
  "standard": MeshStandardMaterial,
  "toon": MeshToonMaterial
};
var MeshFacade = class extends Object3DFacade {
  constructor(parent) {
    super(parent);
    this.material = "standard";
    this.autoDisposeGeometry = false;
    this.autoDisposeMaterial = false;
    this._dirtyMtlProps = null;
  }
  initThreeObject() {
    return new Mesh(dummyGeometry, dummyMaterial);
  }
  afterUpdate() {
    let { geometry, material, threeObject } = this;
    if ((geometry || dummyGeometry) !== threeObject.geometry) {
      if (this.autoDisposeGeometry) {
        threeObject.geometry.dispose();
      }
      threeObject.geometry = geometry || dummyGeometry;
    }
    if (material !== this._lastMtl) {
      this._lastMtl = material;
      if (typeof material === "string") {
        material = new (MESH_MATERIALS[material] || MeshStandardMaterial)();
      } else if (material && material.isMaterial)
        ;
      else if (typeof material === "function") {
        material = new material();
      } else {
        material = new MeshStandardMaterial();
      }
      if (threeObject.material !== material) {
        if (this.autoDisposeMaterial) {
          threeObject.material.dispose();
        }
        threeObject.material = material;
      }
    }
    const dirties = this._dirtyMtlProps;
    if (dirties) {
      threeObject.material.setValues(dirties);
      this._dirtyMtlProps = null;
    }
    super.afterUpdate();
  }
  destructor() {
    if (this.autoDisposeGeometry) {
      this.threeObject.geometry.dispose();
    }
    if (this.autoDisposeMaterial) {
      this.threeObject.material.dispose();
    }
    super.destructor();
  }
};
var ignoreMaterialProps = { type: 1, id: 1, uuid: 1, version: 1 };
Object.keys(MESH_MATERIALS).forEach((key) => {
  let material = new MESH_MATERIALS[key]();
  for (let mtlProp in material) {
    if (material.hasOwnProperty(mtlProp) && !ignoreMaterialProps.hasOwnProperty(mtlProp)) {
      Object.defineProperty(MeshFacade.prototype, `material.${mtlProp}`, {
        enumerable: true,
        configurable: true,
        get() {
          const dirties = this._dirtyMtlProps;
          return dirties && mtlProp in dirties ? dirties[mtlProp] : this.threeObject.material[mtlProp];
        },
        set(value) {
          const dirties = this._dirtyMtlProps || (this._dirtyMtlProps = /* @__PURE__ */ Object.create(null));
          dirties[mtlProp] = value;
        }
      });
    }
  }
});
var getBoxGeometry = utils.memoize(() => {
  return new BoxGeometry(1, 1, 1, 1, 1);
});
var BoxFacade = class extends MeshFacade {
  get geometry() {
    return getBoxGeometry();
  }
  set width(width) {
    this.scaleX = width;
  }
  get width() {
    return this.scaleX;
  }
  set height(height) {
    this.scaleY = height;
  }
  get height() {
    return this.scaleY;
  }
  set depth(width) {
    this.scaleZ = width;
  }
  get depth() {
    return this.scaleZ;
  }
};
var geometries = Object.create(null, [
  ["low", 32],
  ["medium", 64],
  ["high", 128]
].reduce((descr, [name, segments]) => {
  descr[name] = {
    get: utils.memoize(
      () => new CircleGeometry(1, segments).rotateX(-Math.PI / 2)
    )
  };
  return descr;
}, {}));
function getCircleGeometry(detail) {
  return geometries[detail] || geometries.medium;
}
var CircleFacade = class extends MeshFacade {
  constructor(parent) {
    super(parent);
    this["material.side"] = this["material.shadowSide"] = DoubleSide;
  }
  get geometry() {
    return getCircleGeometry(this.detail);
  }
  set radius(r) {
    this.scaleX = this.scaleZ = r;
  }
  get radius() {
    return this.scaleX;
  }
};
var CubeFacade = class extends MeshFacade {
  get geometry() {
    return getBoxGeometry();
  }
  set size(size) {
    this.scale = size;
  }
  get size() {
    return this.scale;
  }
};
var getGeometry = utils.memoize(() => {
  return new PlaneGeometry(1, 1, 1, 1).rotateX(-Math.PI / 2);
});
var PlaneFacade = class extends MeshFacade {
  constructor(parent) {
    super(parent);
    this["material.side"] = this["material.shadowSide"] = DoubleSide;
  }
  get geometry() {
    return getGeometry();
  }
  set width(width) {
    this.scaleX = width;
  }
  get width() {
    return this.scaleX;
  }
  set depth(width) {
    this.scaleZ = width;
  }
  get depth() {
    return this.scaleZ;
  }
};
var geometries$1 = Object.create(null, [
  ["low", 16, 12],
  ["medium", 32, 24],
  ["high", 64, 48]
].reduce((descr, [name, wSegs, hSegs]) => {
  descr[name] = {
    get: utils.memoize(() => new SphereGeometry(1, wSegs, hSegs))
  };
  return descr;
}, {}));
function getSphereGeometry(detail) {
  return geometries$1[detail] || geometries$1.medium;
}
var SphereFacade = class extends MeshFacade {
  get geometry() {
    return getSphereGeometry(this.detail);
  }
  set radius(r) {
    this.scale = r;
  }
  get radius() {
    return this.scale;
  }
};
var Canvas3D = class extends CanvasBase {
  constructor(props) {
    super(props);
    this._onCanvasRef = (canvas) => {
      let fn = this.context.onCanvasRef;
      if (fn)
        fn(canvas);
      fn = this.props.onCanvasRef;
      if (fn)
        fn(canvas);
    };
  }
  render() {
    const { props, context } = this;
    return import_react2.default.createElement(
      CanvasBase,
      utils.assign({}, props, {
        onCanvasRef: this._onCanvasRef,
        canvasStyle: props.canvasStyle || context.canvasStyle,
        worldFacade: props.worldFacade || context.worldFacade || World3DFacade,
        worldProps: utils.assign(
          {
            antialias: props.antialias,
            rendererClass: props.rendererClass,
            backgroundColor: props.backgroundColor,
            background: props.background,
            environment: props.environment,
            outputEncoding: props.outputEncoding,
            toneMapping: props.toneMapping,
            shadows: props.shadows,
            camera: props.camera,
            lights: props.lights,
            objects: props.objects,
            fog: props.fog,
            onBackgroundClick: props.onBackgroundClick
          },
          context.worldProps,
          props.worldProps
        )
      }),
      props.children
    );
  }
};
Canvas3D.displayName = "Canvas3D";
Canvas3D.propTypes = utils.assignIf(
  {
    backgroundColor: import_prop_types2.default.any,
    background: import_prop_types2.default.any,
    environment: import_prop_types2.default.any,
    outputEncoding: import_prop_types2.default.number,
    toneMapping: import_prop_types2.default.number,
    lights: import_prop_types2.default.array,
    camera: import_prop_types2.default.object,
    fog: import_prop_types2.default.object,
    objects: import_prop_types2.default.oneOfType([import_prop_types2.default.array, import_prop_types2.default.object]).isRequired,
    antialias: import_prop_types2.default.bool,
    onBackgroundClick: import_prop_types2.default.func,
    rendererClass: import_prop_types2.default.func
  },
  CanvasBase.commonPropTypes
);
Canvas3D.contextType = import_react2.default.createContext({
  worldFacade: World3DFacade,
  worldProps: {},
  onCanvasRef: null,
  canvasStyle: null
});

export {
  Tween,
  MultiTween,
  setAnimationScheduler,
  Runner,
  SpringTween,
  Facade,
  List,
  ParentFacade,
  Object3DFacade,
  PerspectiveCamera3DFacade,
  OrthographicCamera3DFacade,
  Group3DFacade,
  HtmlOverlay3DFacade,
  AmbientLight3DFacade,
  DirectionalLight3DFacade,
  SpotLight3DFacade,
  PointLight3DFacade,
  HemisphereLight3DFacade,
  RectAreaLight3DFacade,
  InstancingManager,
  Scene3DFacade,
  World3DFacade,
  makeWorldTextureProvider,
  Instanceable3DFacade,
  MeshFacade,
  BoxFacade,
  CircleFacade,
  CubeFacade,
  PlaneFacade,
  SphereFacade,
  Canvas3D
};
/*! Bundled license information:

react/cjs/react.development.js:
  (** @license React v16.14.0
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-G2LT4ZHJ.js.map
